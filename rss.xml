<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>探险</title>
  
  
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://yeomanye.github.io/"/>
  <updated>2017-12-09T15:40:31.482Z</updated>
  <id>http://yeomanye.github.io/</id>
  
  <author>
    <name>FWHeart</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序开发概述</title>
    <link href="http://yeomanye.github.io/2017/10/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/"/>
    <id>http://yeomanye.github.io/2017/10/28/微信小程序开发概述/</id>
    <published>2017-10-27T16:00:00.000Z</published>
    <updated>2017-12-09T15:40:31.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序开发概述"><a href="#微信小程序开发概述" class="headerlink" title="微信小程序开发概述"></a>微信小程序开发概述</h1><p>由于微信的使用人数众多，因此微信小程序也受到许多企业公司的推崇。除此之外小程序还有开发简单容易，用户流量较大的优点，因此学习小程序还是很有意义的。</p><a id="more"></a><h2 id="开发入门"><a href="#开发入门" class="headerlink" title="开发入门"></a>开发入门</h2><p>浏览器环境的前端html、css、js分别对应于微信中的wxml、wxss、js文件。与浏览器环境不同的是每个页面(Page)和整个应用(App)都有对应名称的json文件用于配置，project.config.json文件用于开发环境的配置。</p><p><img src="wx架构.png" alt="wx架构"></p><h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><p>wxml(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>wxml页面数据绑定使用双括号的形式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">data-ml</span>=<span class="string">"&#123;&#123;a&#125;&#125;"</span>&gt;</span> &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>数据是单向绑定的，只有通过setData方法改变Page的data对象中的属性才能改变页面中对应表达式中的值</p><h3 id="条件渲染与列表渲染"><a href="#条件渲染与列表渲染" class="headerlink" title="条件渲染与列表渲染"></a>条件渲染与列表渲染</h3><p>条件渲染与列表渲染相当于，vue中的组件</p><p>条件渲染<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;length &gt; 5&#125;&#125;"</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;length &gt; 2&#125;&#125;"</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>wx:if是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。<br>相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。</p><p>列表渲染<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;array&#125;&#125;"</span> <span class="attr">wx:for-index</span>=<span class="string">"idx"</span> <span class="attr">wx:for-item</span>=<span class="string">"itemName"</span> <span class="attr">wx:key</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">  &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code>的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。<br>wx:key的两种值：字符串代表item中的某个熟悉;*this代表循环中的item本身</p><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>template定义的模板可以在任意地方引用<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"odd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> odd <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"even"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> even <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">src</span>=<span class="string">"header.wxml"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- header.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span> header <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>import可以在该文件中使用目标文件定义的template<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"item.wxml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"item"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;text: 'forbar'&#125;&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>相比于include使用import可以设置数据</p><p>import具有作用域的概念，C导入B，B导入A。C中只能获取B中的模板，而不能获取B中导入的A中的。</p><h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>wxss是小程序用于描述页面的样式语言，该语言与css基本相同。</p><p>新增加了rpx(responsive pixel)响应式单位，该单位可以根据屏幕宽度进行自适应。<br>样式导入@import “common.wxss”;</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>导出模块可以使用CommonJS机制和ES6的模块机制</p><p>CommonJS<br>每个js模块都在自己的作用域中，导出模块需要使用exports或module.exports<br>导入使用require,但是不支持绝对路径。</p><p>ES6<br>使用ES6的模块机制导出模块，导入使用import…from等关键字，导出使用export default关键字</p><h2 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h2><p>路由是指导航到页面的方式，路由的种类有：navigateTo、redirectTo、switchTab、reLaunch、navigateBack</p><p>除了navigateTo、switchTab的方式是隐藏当前页面其他的方式都会卸载当前页面。</p><p>navigateTo, redirectTo 只能打开非 tabBar 页面。<br>switchTab 只能打开 tabBar 页面。<br>reLaunch 可以打开任意页面。</p><p>具体见表<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/route.html" target="_blank" rel="noopener">路由</a></p><h2 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h2><p>小程序中事件分为冒泡和非冒泡两种类型。</p><p>事件的生命周期阶段与浏览器中相同都是先捕获后冒泡。</p><p>绑定事件的方式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">bindtap</span>=<span class="string">"handleTap1"</span>&gt;</span></span><br><span class="line">  outer view</span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"middle"</span> <span class="attr">catchtap</span>=<span class="string">"handleTap2"</span>&gt;</span></span><br><span class="line">    middle view</span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"inner"</span> <span class="attr">bindtap</span>=<span class="string">"handleTap3"</span>&gt;</span></span><br><span class="line">      inner view</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"inner"</span> <span class="attr">bind:touchstart</span>=<span class="string">"handleTap3"</span> <span class="attr">capture-bind:touchstart</span>=<span class="string">"handleTap4"</span>&gt;</span></span><br><span class="line">    inner view</span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>bind事件发生在冒泡阶段，且不阻止事件向上冒泡</li><li>capture-bind事件发生在捕获阶段，且不阻止事件捕获</li><li>catch事件发生在冒泡阶段，阻止事件向上冒泡</li><li>capture-catch事件发生在捕获阶段，阻止事件捕获</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>小程序提供了许多组件，常见的有：</p><ul><li>view相当于div</li><li>text相当于span</li><li>navigator相当于a</li><li>image相当于img</li><li>canvas相当于canvas</li><li>contact-button客户会话，从此处发送的消息，会在微信小程序后台接收到</li></ul><p>小程序中表单form组件不同于浏览器的地方是，无法像浏览器一样通过给表单配置action让页面直接跳转。需要对表单设置submit事件，在submit中获取数据处理跳转逻辑，要获取数据表单项必须要有name属性，这点与浏览器中一致。</p><p>小程序中的button除了像浏览器中一样可以通过form-type属性设置为submit、reset与表单相关的按钮之外。<br>还可以通过设置open-type属性设置为特别的按钮:</p><ul><li>contact(打开客服会话)</li><li>share(触发用户转发)</li><li>getUserInfo(获取用户信息，可以在bindgetuserinfo回调中取到用户信息)</li><li>getPhoneNumber(获取用户手机号，可以从bindgetphonenumber中取得)</li></ul><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><p>小程序中阻止事件冒泡，使用的是catchXX方法(事件还分为冒泡和非冒泡两种)</p><p>没有阻止默认行为的方法</p><p>使用wx.canvasToTempFilePath方法生成图片，如果canvas使用图片进行了绘制，那图片必须是本地图片。而且在微信基础库版本1.5.4下，使用本地图片需要导出两次才能在开发者工具上的canvas看到图片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wx.downloadFile(&#123;</span><br><span class="line">       url: url,</span><br><span class="line">       success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">         <span class="comment">// console.log('下载图片文件')</span></span><br><span class="line">         <span class="comment">// console.log(res)</span></span><br><span class="line">         ctx.drawImage(res.tempFilePath, left, top, width, height);</span><br><span class="line">         ctx.draw();</span><br><span class="line">         wx.canvasToTempFilePath(&#123;</span><br><span class="line">           canvasId: <span class="string">'photoid'</span>,</span><br><span class="line">           success(res) &#123;</span><br><span class="line">             wx.canvasToTempFilePath(&#123;</span><br><span class="line">               canvasId: <span class="string">'photoid'</span>,</span><br><span class="line">               success(res) &#123;</span><br><span class="line">                 <span class="comment">//...</span></span><br><span class="line">               &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微信小程序开发概述&quot;&gt;&lt;a href=&quot;#微信小程序开发概述&quot; class=&quot;headerlink&quot; title=&quot;微信小程序开发概述&quot;&gt;&lt;/a&gt;微信小程序开发概述&lt;/h1&gt;&lt;p&gt;由于微信的使用人数众多，因此微信小程序也受到许多企业公司的推崇。除此之外小程序还有开发简单容易，用户流量较大的优点，因此学习小程序还是很有意义的。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="http://yeomanye.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="软件" scheme="http://yeomanye.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>客户端存储技术</title>
    <link href="http://yeomanye.github.io/2017/10/15/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/"/>
    <id>http://yeomanye.github.io/2017/10/15/客户端存储技术/</id>
    <published>2017-10-14T16:00:00.000Z</published>
    <updated>2017-12-09T15:40:31.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端存储技术"><a href="#客户端存储技术" class="headerlink" title="客户端存储技术"></a>客户端存储技术</h1><p>介绍浏览器的客户端存储技术，包括：Cookie、Storage、IndexedDB、Application Cache和已经过时但还是很常见的Web SQL，以及一些其他的还未普及的存储技术:Cache Storage、FileSystem API。</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>特点：</p><ul><li>具有大小限制,4~8k</li><li>绑定到域名，对同一个域名的请求会自动带上cookie请求头</li><li>能够给cookie设置有效时间</li></ul><p>cookie使用key=value的形式记录用户信息，多个键值对之间使用;分隔</p><p>前端通过操纵document下的cookie属性直接操纵cookie<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie</span><br><span class="line"><span class="comment">//"irstime=1492081681236; uuid_tt_dd=242117069142"</span></span><br></pre></td></tr></table></figure></p><p>与cookie相关的请求头有两个，一个是Set-Cookie(用在响应中,用于设置cookie和附加信息。一个Set-Cookie可以设置一对或多对键值对),一个是Cookie(用在请求时，表示发送的cookie)</p><p>Set-Cookie格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;name&gt;=&lt;value&gt;[; &lt;name&gt;=&lt;value&gt;]...</span><br><span class="line">       [; expires=&lt;date&gt;][; domain=&lt;domain_name&gt;]</span><br><span class="line">       [; path=&lt;some_path&gt;][; secure][; httponly]</span><br></pre></td></tr></table></figure></p><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>Storage分为本地存储（Local Storage）和会话存储（Session Storage）。两者使 用完全相同的API，但本地存储会持久存在（或者直到用户清除），而会话存储只要浏览器 关闭就会消失。存储的键值只能为字符串，storage存储的键值也是和域名相挂钩的。</p><p>API<br>localStorge.setItem:设置特定键值；<br>localStorge.getItem:检索特定的键值；<br>localStorge.removeItem:删除键值及其相关联的值；<br>localStorge.clear:删除所有的键值（只限定于发出请求的特定域名）</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 数据库使用key-value键值对储存数据，IndexedDB 是事务模式的数据库(任何操作都发生在事务中)，API 基本上是异步的(使用事件模型)。</p><p>IndexedDB是一个基于JavaScript的面向对象的数据库。<br>允许存储和检索用键索引的对象; 可以存储结构化克隆算法支持的任何对象;IndexedDB也遵循同源策略。</p><p>结构化克隆支持的对象：RegExp、Blob、File、Filelist、ImageData、CanvasPixelArray(克隆力度将会跟原始对象相同)、可以正确复制有循环引用的对象。</p><p>不支持的对象:</p><ul><li>Error、Function、DOM节点</li><li>对象的某些特定参数也不会被保留<ul><li>RegExp 对象的 lastIndex 字段不会被保留</li><li>属性描述符，setters 以及 getters（以及其他类似元数据的功能）同样不会被复制。例如，如果一个对象用属性描述符标记为 read-only，它将会被复制为 read-write，因为这是默认的情况下。</li><li>原形链上的属性也不会被追踪以及复制。</li></ul></li></ul><p>初始化数据库<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> localDatabase = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">localDatabase.indexedDB = <span class="built_in">window</span>.indexedDB || <span class="built_in">window</span>.webkitIndexedDB || <span class="built_in">window</span>.mozIndexedDB || <span class="built_in">window</span>.msIndexedDB;</span><br><span class="line">localDatabase.IDBKeyRange = <span class="built_in">window</span>.IDBKeyRange || <span class="built_in">window</span>.webkitIDBKeyRange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DB = <span class="string">"db_user"</span>,VERSION = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开数据库*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openDB</span>(<span class="params">dbName, version, objStore, columnArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> db = localDatabase.db;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (db) db.close();</span><br><span class="line">        version = version || <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 打开数据库</span></span><br><span class="line">        <span class="keyword">var</span> openRequest = localDatabase.indexedDB.open(dbName, version);</span><br><span class="line">        <span class="comment">// 成功打开数据库</span></span><br><span class="line">        openRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            localDatabase.db = openRequest.result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建或删除存储对象只能在此进行</span></span><br><span class="line">        openRequest.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> db = e.currentTarget.result;</span><br><span class="line">            <span class="keyword">if</span> (!db.objectStoreNames.contains(objStore)) &#123;</span><br><span class="line">                <span class="comment">//创建存储对象并设置主键</span></span><br><span class="line">                <span class="keyword">var</span> store = db.createObjectStore(objStore, &#123;</span><br><span class="line">                    keyPath: <span class="string">"id"</span></span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 创建索引，方便根据字段进行搜索</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = columnArr.length; i &lt; len; i++) &#123;</span><br><span class="line">                    store.createIndex(columnArr[i], columnArr[i], &#123;</span><br><span class="line">                        unique: <span class="literal">false</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"创建存储对象成功"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        openRequest.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(e.message);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入和删除数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*添加数据*/</span></span><br><span class="line"><span class="keyword">var</span> request = localDatabase.db.transaction(objStore, <span class="string">"readwrite"</span>).objectStore(objStore).add(obj);</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加成功！</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除数据*/</span></span><br><span class="line"><span class="keyword">var</span> request = db.transaction([<span class="string">"customers"</span>], <span class="string">"readwrite"</span>).objectStore(<span class="string">"customers"</span>).delete(<span class="string">"444-44-4444"</span>);</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 删除数据成功！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用索引获取单个值，使用游标获取多个值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用索引获取单个值*/</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(objStore),</span><br><span class="line">    store = transaction.objectStore(objStore),</span><br><span class="line">    request = store.get(key);</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(evt.target.result));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用游标获取多个值 */</span></span><br><span class="line"><span class="keyword">var</span> recordArr = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryAllRecords</span>(<span class="params">objStore</span>) </span>&#123;</span><br><span class="line">    recordArr = [];</span><br><span class="line">    <span class="keyword">var</span> db = localDatabase.db;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> transaction = db.transaction(objStore),</span><br><span class="line">            store = transaction.objectStore(objStore),</span><br><span class="line">            request = store.openCursor();</span><br><span class="line"></span><br><span class="line">        request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cursor = evt.target.result,</span><br><span class="line">                jsonStr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">                <span class="keyword">var</span> records = cursor.value;</span><br><span class="line">                jsonStr = jsonStr + <span class="built_in">JSON</span>.stringify(records);</span><br><span class="line">                <span class="built_in">console</span>.log(jsonStr);</span><br><span class="line">                recordArr.push(records);</span><br><span class="line">                cursor.continue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多IDB代码见:<a href="https://gist.githubusercontent.com/YeomanYe/f526062c431ddb241a5d670aa461cd0b/raw/60836747c6eb25a4a230ef7347dacf2565902f8b/IDB_Util.js" target="_blank" rel="noopener">IDB_Util</a></p><h2 id="Application-Cache"><a href="#Application-Cache" class="headerlink" title="Application Cache"></a>Application Cache</h2><p>Application Cache使用的是一套缓存列表。所谓列表，只是一个非常简单的文本文档，其中列举了所有应该或不应该通过缓存机制处理的资源条目，从而指导浏览器下载特定文件、加以保存并在必要时予以使用——而不必再向服务器发出重复请求。</p><p>要使用Application Cache，我们需要首先在包含有缓存对象文件的网站中保存一个扩展名为.appcache的文本文件。根据所使用Web服务器的具体类型，我们可能需要为.appcache文件创建一个自定义MIME类型以确保它们能够正确作用于浏览器并可被作为应用程序缓存文件读取。</p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 以上折行必需要写</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line"># 这部分写需要缓存的资源文件列表</span><br><span class="line"># 可以是相对路径也可以是绝对路径</span><br><span class="line">index.html</span><br><span class="line">index.css</span><br><span class="line">images/logo.png</span><br><span class="line">js/main.js</span><br><span class="line">http://img.baidu.com/js/tangram-base-1.5.2.1.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line"># 可选</span><br><span class="line"># 这一部分是要绕过缓存直接读取的文件</span><br><span class="line">login.php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line"># 可选</span><br><span class="line"># 这部分写当访问缓存失败后，备用访问的资源</span><br><span class="line"># 每行两个文件，第一个是访问源，第二个是替换文件*.html /offline.html</span><br></pre></td></tr></table></figure></p><p>html文件中的设置<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"demo.cache"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>apache服务器中，定义<br><code>tAddType text/cache-manifest .cache</code></p><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>更新manifest文件<br>　　浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。<br>　　当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。</p><p>使用js的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appCache = <span class="built_in">window</span>.applicationCache;</span><br><span class="line"></span><br><span class="line">appCache.update(); <span class="comment">//尝试更新缓存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (appCache.status == <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</span><br><span class="line">  appCache.swapCache();  <span class="comment">//更新成功后，切换到新的缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Web-SQL"><a href="#Web-SQL" class="headerlink" title="Web SQL"></a>Web SQL</h3><p>web sql的规范工作已经被W3C停止，按照官方的说法是web sql后台使用的都是SQLite，但为了实现规范前台会有许多不同的实现。因此规范被停止。但是仍然有许多老系统、插件使用web sql，因此学习web sql对我们还是有着不小的好处。</p><p>Web SQL Database 规范中定义了三个核心方法：</p><ul><li>openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象</li><li>transaction：这个方法允许我们根据情况控制事务提交或回滚</li><li>executeSql：这个方法用于执行SQL 查询</li></ul><p>openDatabase<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(dbName, dbVersion, showName, size,callback);</span><br><span class="line"></span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    context.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS testTable (id unique, name)'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable (id, name) VALUES (0, "Byron")'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable (id, name) VALUES (1, "Casper")'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable (id, name) VALUES (2, "Frank")'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'SELECT * FROM testTable where id=? and name=?'</span>, [<span class="number">2</span>, <span class="string">'Frank'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">context, results</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> len = results.rows.length, i;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Got '</span> + len + <span class="string">' rows.'</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'id: '</span> + results.rows.item(i).id);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'name: '</span> + results.rows.item(i).name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, errorCallback);</span><br><span class="line">&#125;, successCallback, errorCallback);</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Cache-Storage"><a href="#Cache-Storage" class="headerlink" title="Cache Storage"></a>Cache Storage</h3><p>Cache Storage用来存储 Response 对象的。也就是说用来对 HTTP ，响应做缓存的。CacheStorage 在浏览器上的引用名叫 caches ，它定义在 ServiceWorker 的规范中。CacheStorage 是多个 Cache 的集合，而每个 Cache 可以存储多个 Response 对象。CacheStorage的设计风格也和ServiceWork一样都基于Promise。</p><ul><li>match() 返回promise,resolve为response对象，如果在任意一个cache中找到与key对应的响应对象</li><li>has() 返回promise对象,resolve为boolean，根据是否含有记录，得到不同的值</li><li>open() 返回promise，resolve为cache，如果不存在对应的cache，则新建一个</li><li>delete() 返回promise,resolve为boolean,如果删除cache成功则为true</li><li>keys() 返回promise,resolve为cache数组</li></ul><h4 id="使用cache-storage与service-worker建立离线应用"><a href="#使用cache-storage与service-worker建立离线应用" class="headerlink" title="使用cache storage与service worker建立离线应用"></a>使用cache storage与service worker建立离线应用</h4><p>在页面脚本中添加如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个serviceWorker</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./sw-demo-cache.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在sw-demo-cache.js中添加如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw-demo-cache.js</span></span><br><span class="line"><span class="keyword">var</span> VERSION = <span class="string">'v1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(VERSION).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//需要做缓存的文件</span></span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'./start.html'</span>,</span><br><span class="line">        <span class="string">'./static/jquery.min.js'</span>,</span><br><span class="line">        <span class="string">'./static/mm1.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存更新</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 如果当前版本和缓存版本不一致</span></span><br><span class="line">          <span class="keyword">if</span> (cacheName !== VERSION) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获请求并返回缓存数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    caches.open(VERSION).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      cache.put(event.request, response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> response.clone();</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//没法从缓存和请求中得到资源时的处理办法</span></span><br><span class="line">    <span class="keyword">return</span> caches.match(<span class="string">'./static/mm1.jpg'</span>);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="FileSystem-API"><a href="#FileSystem-API" class="headerlink" title="FileSystem API"></a>FileSystem API</h3><p>使用 FileSystem API，网络应用就可以创建、读取、导航用户本地文件系统中的沙盒部分以及向其中写入数据。但是目前FileSystem API并不普及，支持的只有chrome浏览器。FileSystem API提供了文件系统的管理、文件/目录的管理、文件的管理等API。刚兴趣的朋友可以阅读<a href="http://blog.csdn.net/u011069813/article/details/20306403#toc-file-writing" target="_blank" rel="noopener">探索FileSystem API</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB#使用索引" target="_blank" rel="noopener">使用IndexedDB</a><br><a href="http://www.cnblogs.com/blackbird/archive/2012/06/12/2546751.html" target="_blank" rel="noopener">application cache api</a><br><a href="http://www.cnblogs.com/dolphinX/p/3405335.html" target="_blank" rel="noopener">Web SQL Database</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener">CacheStorage 缓存存储</a><br><a href="http://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/" target="_blank" rel="noopener">借助Service Worker和cacheStorage缓存及离线开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;客户端存储技术&quot;&gt;&lt;a href=&quot;#客户端存储技术&quot; class=&quot;headerlink&quot; title=&quot;客户端存储技术&quot;&gt;&lt;/a&gt;客户端存储技术&lt;/h1&gt;&lt;p&gt;介绍浏览器的客户端存储技术，包括：Cookie、Storage、IndexedDB、Application Cache和已经过时但还是很常见的Web SQL，以及一些其他的还未普及的存储技术:Cache Storage、FileSystem API。&lt;/p&gt;
    
    </summary>
    
      <category term="存储" scheme="http://yeomanye.github.io/categories/%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="JavaScript" scheme="http://yeomanye.github.io/tags/JavaScript/"/>
    
      <category term="存储" scheme="http://yeomanye.github.io/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式与开发实践</title>
    <link href="http://yeomanye.github.io/2017/10/07/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yeomanye.github.io/2017/10/07/JavaScript设计模式与开发实践/</id>
    <published>2017-10-06T16:00:00.000Z</published>
    <updated>2017-12-09T15:40:31.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="评-JavaScript设计模式与开发实践"><a href="#评-JavaScript设计模式与开发实践" class="headerlink" title="[评]JavaScript设计模式与开发实践"></a>[评]JavaScript设计模式与开发实践</h1><p>这本书介绍了14种常见的设计模式的js实现，并且都配备了代码的实现。适合所有想深入了解前端、js写一手好代码的人员。</p><a id="more"></a><p><img src="resources/images/JavaScript设计模式与开发实践.png" alt="JavaScript设计模式与开发实践"></p><p>该书循序渐进的从设计模式需要使用的基础JS知识讲解起，然后介绍具体常用的14种设计模式，最后介绍设计模式遵循的一般准则。使读者循序渐进的提高代码的编写能力和组织技巧。书中还附有许多的实战例子，使读者能够更深入的认识设计模式的用途。</p><h2 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h2><p>使用Object.create(null)可以创建一个没有原型的对象。</p><p>使用字面量的方式创建的原型是Object</p><p>构造器不显式地返回任何数据，或者是返回一个非对象类型的数据则返回的对象为this</p><p>高阶函数是指至少满足下列条件之一的函数。</p><ul><li>函数可以作为参数被传递；</li><li>函数可以作为返回值输出。</li></ul><p>函数节流，用于经常性调用的函数中，减少调用的次数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = fn, <span class="comment">// 保存需要被延迟执行的函数引用</span></span><br><span class="line">    timer, <span class="comment">// 定时器</span></span><br><span class="line">    firstTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 是否是第一次调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">          , __me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">            <span class="comment">// 如果是第一次调用，不需延迟执行</span></span><br><span class="line">            __self.apply(__me, args);</span><br><span class="line">            <span class="keyword">return</span> firstTime = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="comment">// 如果定时器还在，说明前一次延迟执行还没有完成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 延迟一段时间执行</span></span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            __self.apply(__me, args);</span><br><span class="line">        &#125;, interval || <span class="number">500</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure></p><p>分时函数，一次性渲染大批量的数据造成浏览器卡死，应该使用延时函数分批量进行渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeChunk = <span class="function"><span class="keyword">function</span>(<span class="params">ary, fn, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj, t;</span><br><span class="line">    <span class="keyword">var</span> len = ary.length;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(count || <span class="number">1</span>, ary.length); i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = ary.shift();</span><br><span class="line">            fn(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        t = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ary.length === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果全部节点都已经被创建好</span></span><br><span class="line">                <span class="keyword">return</span> clearInterval(t);</span><br><span class="line">            &#125;</span><br><span class="line">            start();</span><br><span class="line">        &#125;, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 分批执行的时间间隔，也可以用参数的形式传入</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ary = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    ary.push(i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> renderFriendList = timeChunk(ary, <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = n;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;, <span class="number">8</span>);</span><br><span class="line">renderFriendList();</span><br></pre></td></tr></table></figure></p><p>惰性函数，第一次进入函数后改变函数的结构（解决如果不使用函数就没必要执行一遍逻辑）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, handler</span>) </span>&#123;</span><br><span class="line">            elem.attachEvent(<span class="string">'on'</span> + type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(elem, type, handler);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="第二部分-设计模式"><a href="#第二部分-设计模式" class="headerlink" title="第二部分 设计模式"></a>第二部分 设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p>当内层函数对象为null时调用函数生成对象，内层函数存在对象则返回对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">    div.style.display = <span class="string">'none'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    <span class="keyword">return</span> div;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createLoginLayer);</span><br></pre></td></tr></table></figure></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p><p>需要的数据类型一致，但获取数据的方式不一致时，可以使用该模式。如：</p><ul><li>排序函数，返回值都为数值，但排序算法可以指定。</li><li>表单验证，验证的逻辑和内容可以不同，但是验证的结果都是返回布尔值用于判断是否满足条件</li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。强调控制对象的行为，添加附加操作。</p><ul><li>虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建。对于实时性不是很高的系统，可以将多个ajax合并一起发送。</li><li>缓存代理:可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。</li></ul><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p><p>内部迭代器：内部迭代器已经完全定义好了迭代规则，完全接手整个迭代过程。each函数<br>外部迭代器：外部迭代器必须显式地请求迭代下一个元素。Iterator接口</p><p>迭代器模式只是规定循环访问一个聚合对象中的每个元素，但它没有规定顺序，因此实现迭代器可以有顺序、倒序、循环、终止(根据条件退出迭代)等等方式。</p><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><p>JS中DOM事件就是发布-订阅模式</p><p>发布-订阅模式适合用于多个模块依据一个数据的状态的情况。例如：根据用户是否登录，改变各模块状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">'http:// xxx.com?login'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 登录成功</span></span><br><span class="line">    login.trigger(<span class="string">'loginSucc'</span>, data);</span><br><span class="line">    <span class="comment">// 发布登录成功的消息</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> header = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// header 模块</span></span><br><span class="line">    login.listen(<span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        header.setAvatar(data.avatar);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setAvatar: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'设置 header 模块的头像'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> nav = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// nav 模块</span></span><br><span class="line">    login.listen(<span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        nav.setAvatar(data.avatar);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setAvatar: <span class="function"><span class="keyword">function</span>(<span class="params">avatar</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'设置 nav 模块的头像'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式最常见的应用场景是:在请求的发起者有很多种可能，请求的接收者有很多种可能，请求有多种可能时。使用命令模式构成一个松耦合的关系。</p><p>如点击按钮触发菜单刷新就可以使用命令模式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RefreshMenuBarCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        execute: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            receiver.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> setCommand = <span class="function"><span class="keyword">function</span>(<span class="params">button, command</span>) </span>&#123;</span><br><span class="line">    button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);</span><br><span class="line">setCommand(button1, refreshMenuBarCommand);</span><br></pre></td></tr></table></figure></p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式将对象组合成树形结构，以表示“部分整体”的层次结构。组合后的整体对象一般具有调用部分的方案。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性</p><p>树形菜单中使用组合模式将直接子节点，放入父节点下构成一个整体以便共同操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TreeNode = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.children.push(node);</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode.prototype.scan = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'显示节点名: '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, node, children = <span class="keyword">this</span>.children; node = children[i++]; ) &#123;</span><br><span class="line">        node.scan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><p>为了保证重写未实现的模板方法，可以使用：1.类型检查，2.默认使用抛出异常的方式实现需要重写的方法</p><p>放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> brew = param.brew || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 brew 方法'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> pourInCup = param.pourInCup || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 pourInCup 方法'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> addCondiments = param.addCondiments || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 addCondiments 方法'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span>.customerWantsCondiments() )&#123; <span class="comment">// 如果挂钩返回 true，则需要调料</span></span><br><span class="line">            <span class="keyword">this</span>.addCondiments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> Coffee = Beverage(&#123;</span><br><span class="line">    brew: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡咖啡'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    pourInCup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'把咖啡倒进杯子'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    addCondiments: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'加糖和牛奶'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    customerWantsCondiments: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.confirm(<span class="string">"请问需要加糖吗？"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br></pre></td></tr></table></figure><p>当我们用模板方法模式编写一个程序时，就意味着子类放弃了对自己的控制权，而是改为父类通知子类，哪些方法应该在什么时候被调用,相当于好莱坞原则。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量</p><ul><li>内部状态存储于对象内部。</li><li>内部状态可以被一些对象共享。</li><li>内部状态独立于具体的场景，通常不会改变。</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。</li></ul><p>使用对象池，减少创建对象的开销<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用对象池创建工厂</span></span><br><span class="line"><span class="keyword">var</span> objectPoolFactory = <span class="function"><span class="keyword">function</span>(<span class="params">createObjFn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectPool = [];</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = objectPool.length === <span class="number">0</span> ? createObjFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) : objectPool.shift();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;,</span><br><span class="line">        recover: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            objectPool.push(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// iframe对象池</span></span><br><span class="line"><span class="keyword">var</span> iframeFactory = objectPoolFactory(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        iframe.onload = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 防止 iframe 重复加载的 bug</span></span><br><span class="line">        iframeFactory.recover(iframe);</span><br><span class="line">        <span class="comment">// iframe 加载完成之后回收节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iframe;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> iframe1 = iframeFactory.create();</span><br><span class="line">iframe1.src = <span class="string">'http:// baidu.com'</span>;</span><br><span class="line"><span class="keyword">var</span> iframe2 = iframeFactory.create();</span><br><span class="line">iframe2.src = <span class="string">'http:// QQ.com'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> iframe3 = iframeFactory.create();</span><br><span class="line">    iframe3.src = <span class="string">'http:// 163.com'</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="string">'nextSuccessor'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getActiveUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// IE 上传控件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">"TXFTNActiveX.FTNUpload"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getFlashUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (supportFlash()) &#123;</span><br><span class="line">        <span class="comment">// Flash上传控件</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">'&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'</span>;</span><br><span class="line">        <span class="keyword">return</span> $(str).appendTo($(<span class="string">'body'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nextSuccessor'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getFormUpladObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 表单上传</span></span><br><span class="line">    <span class="keyword">return</span> $(<span class="string">'&lt;form&gt;&lt;input name="file" type="file"/&gt;&lt;/form&gt;'</span>).appendTo($(<span class="string">'body'</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUpladObj);</span><br><span class="line"><span class="built_in">console</span>.log(getUploadObj());</span><br></pre></td></tr></table></figure><p>责任链模式不仅适用于顺序判断的结构，而且适合于多个对象处理一个对象的结构（组合处理对象构成责任链）</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。</p><p>中介者模式与发布-订阅模式相似都是对象与对象之间状态相关联的模型。发布-订阅模式是一个发送者多个接收者，关联逻辑接收者各自维护；中介者模式是多个发送者一个或多个接收者，需要管理关联逻辑。</p><p>货物购买示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = &#123;</span><br><span class="line">    <span class="comment">// 手机库存</span></span><br><span class="line">    <span class="string">"red|32G"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">"red|16G"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"blue|32G"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"blue|16G"</span>: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mediator = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> colorSelect = <span class="built_in">document</span>.getElementById(<span class="string">'colorSelect'</span>),</span><br><span class="line">        memorySelect = <span class="built_in">document</span>.getElementById(<span class="string">'memorySelect'</span>),</span><br><span class="line">        numberInput = <span class="built_in">document</span>.getElementById(<span class="string">'numberInput'</span>),</span><br><span class="line">        colorInfo = <span class="built_in">document</span>.getElementById(<span class="string">'colorInfo'</span>),</span><br><span class="line">        memoryInfo = <span class="built_in">document</span>.getElementById(<span class="string">'memoryInfo'</span>),</span><br><span class="line">        numberInfo = <span class="built_in">document</span>.getElementById(<span class="string">'numberInfo'</span>),</span><br><span class="line">        nextBtn = <span class="built_in">document</span>.getElementById(<span class="string">'nextBtn'</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        changed: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> color = colorSelect.value, <span class="comment">// 颜色</span></span><br><span class="line">            memory = memorySelect.value, <span class="comment">// 内存</span></span><br><span class="line">            number = numberInput.value, <span class="comment">// 数量</span></span><br><span class="line">            stock = goods[color + <span class="string">'|'</span> + memory];</span><br><span class="line">            <span class="comment">// 颜色和内存对应的手机库存数量</span></span><br><span class="line">            <span class="keyword">if</span> (obj === colorSelect) &#123;</span><br><span class="line">                <span class="comment">// 如果改变的是选择颜色下拉框</span></span><br><span class="line">                colorInfo.innerHTML = color;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj === memorySelect) &#123;</span><br><span class="line">                memoryInfo.innerHTML = memory;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj === numberInput) &#123;</span><br><span class="line">                numberInfo.innerHTML = number;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!color) &#123;</span><br><span class="line">                nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">                nextBtn.innerHTML = <span class="string">'请选择手机颜色'</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!memory) &#123;</span><br><span class="line">                nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">                nextBtn.innerHTML = <span class="string">'请选择内存大小'</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (((number - <span class="number">0</span>) | <span class="number">0</span>) !== number - <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 输入购买数量是否为正整数</span></span><br><span class="line">                nextBtn.disabled = <span class="literal">true</span>;</span><br><span class="line">                nextBtn.innerHTML = <span class="string">'请输入正确的购买数量'</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextBtn.disabled = <span class="literal">false</span>;</span><br><span class="line">            nextBtn.innerHTML = <span class="string">'放入购物车'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 事件函数：</span></span><br><span class="line">colorSelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mediator.changed(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.onchange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mediator.changed(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">numberInput.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    mediator.changed(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他对象。</p><p>装饰者(decorator)能很好地描述这个模式，但从结构上看，包装器(wrapper)的说法更加贴切。装饰者模式将一个对象嵌入另一个对象之中，实际上相当于这个对象被另一个对象包装起来，形成一条包装链。</p><p>使用中间变量实现装饰模式存在两个问题：1.中间变量维护；2.this指向</p><p>AOP方式实现装饰器模式，原函数中的属性将会丢失<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> __self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>装饰器模式强调的是给装饰的对象添加新功能，代理模式强调的是控制对象的操作。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>状态模式的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p><p>toggle函数常用状态模式，在函数外部封装切换状态包含的逻辑，函数内部根据当前的状态调用对应的切换函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Light = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.currState = FSM.off;</span><br><span class="line">    <span class="comment">// 设置当前状态</span></span><br><span class="line">    <span class="keyword">this</span>.button = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Light.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line">      , self = <span class="keyword">this</span>;</span><br><span class="line">    button.innerHTML = <span class="string">'已关灯'</span>;</span><br><span class="line">    <span class="keyword">this</span>.button = <span class="built_in">document</span>.body.appendChild(button);</span><br><span class="line">    <span class="keyword">this</span>.button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.currState.buttonWasPressed.call(self);</span><br><span class="line">        <span class="comment">// 把请求委托给 FSM 状态机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> FSM = &#123;</span><br><span class="line">    off: &#123;</span><br><span class="line">        buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'关灯'</span>);</span><br><span class="line">            <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是开灯'</span>;</span><br><span class="line">            <span class="keyword">this</span>.currState = FSM.on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    on: &#123;</span><br><span class="line">        buttonWasPressed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'开灯'</span>);</span><br><span class="line">            <span class="keyword">this</span>.button.innerHTML = <span class="string">'下一次按我是关灯'</span>;</span><br><span class="line">            <span class="keyword">this</span>.currState = FSM.off;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> light = <span class="keyword">new</span> Light();</span><br><span class="line">light.init();</span><br></pre></td></tr></table></figure></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器又称为包装器(wrapper)，适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。</p><p>如果现有的接口已经能够正常工作，那我们就永远不会用上适配器模式。适配器模式是一种“亡羊补牢”的模式，没有人会在程序的设计之初就使用它。</p><h2 id="第三部分-设计原则和编程技巧"><a href="#第三部分-设计原则和编程技巧" class="headerlink" title="第三部分 设计原则和编程技巧"></a>第三部分 设计原则和编程技巧</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（SRP）的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。</p><p>在设计模式中体现该原则的模式有：代理模式、迭代器模式、单例模式(分离开单例创建和管理)和装饰器模式</p><h3 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h3><p>最少知识原则（LKP）说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。</p><p>使用最少知识原则的模式有：中介者模式、外观模式。</p><h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p>开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。</p><p>实现开放-封闭原则的方式：</p><ul><li>对象的动态特性(鸭子函数)</li><li>放置挂钩(hook)，将判断封装一个函数，根据函数结果来判断是否执行条件。</li><li>回调函数，可以认为是一种特殊的挂钩。</li></ul><p>设计模式就是给做的好的设计取个名字。几乎所有的设计模式都是遵守开放-封闭原则的，我们见到的好设计，通常都经得起开放封闭原则的考验。不管是具体的各种设计-模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等，都是为了让程序遵守开放-封闭原则而出现的。</p><h3 id="接口和面向接口编程"><a href="#接口和面向接口编程" class="headerlink" title="接口和面向接口编程"></a>接口和面向接口编程</h3><p>面向接口编程”其实是“面向超类型编程”。当对象的具体类型被隐藏在超类型身后时，这些对象就可以相互替换使用，我们的关注点才能从对象的类型上转移到对象的行为上。</p><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>提炼函数，一个函数不应该过长<br>合并重复代码片段<br>将分支语句提炼成函数<br>多重try…catch提炼成循环<br>提前让函数退出<br>传递对象参数代替过长的参数列表<br>使用return退出内层循环，将剩余的代码提炼为函数</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;评-JavaScript设计模式与开发实践&quot;&gt;&lt;a href=&quot;#评-JavaScript设计模式与开发实践&quot; class=&quot;headerlink&quot; title=&quot;[评]JavaScript设计模式与开发实践&quot;&gt;&lt;/a&gt;[评]JavaScript设计模式与开发实践&lt;/h1&gt;&lt;p&gt;这本书介绍了14种常见的设计模式的js实现，并且都配备了代码的实现。适合所有想深入了解前端、js写一手好代码的人员。&lt;/p&gt;
    
    </summary>
    
      <category term="书评" scheme="http://yeomanye.github.io/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
      <category term="JavaScript" scheme="http://yeomanye.github.io/tags/JavaScript/"/>
    
      <category term="设计模式" scheme="http://yeomanye.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTML5数据推送应用开发</title>
    <link href="http://yeomanye.github.io/2017/09/22/HTML5%E6%95%B0%E6%8D%AE%E6%8E%A8%E9%80%81%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    <id>http://yeomanye.github.io/2017/09/22/HTML5数据推送应用开发/</id>
    <published>2017-09-21T16:00:00.000Z</published>
    <updated>2017-12-09T15:40:31.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="评-HTML5数据推送应用开发"><a href="#评-HTML5数据推送应用开发" class="headerlink" title="[评]HTML5数据推送应用开发"></a>[评]HTML5数据推送应用开发</h1><p>《HTML5数据推送应用开发》不仅介绍了HTML5的服务器端推送接口SSE,还介绍了向后兼容方案，服务器端代码实现，性能优化最终打造一个产品级品质的产品。</p><a id="more"></a><p><img src="HTML5数据推送应用开发.jpg" alt="HTML5数据推送应用开发"></p><p>该书最适合有PHP基础，想要打造产品级品质的服务器端推送应用。第二适合，想要打造产品级品质的产品的人。如果只是想要学习服务器端推送的话，还是建议直接去看API。美中不足之处是后端使用了PHP语言，如果能用nodejs就好了。</p><h2 id="精彩部分"><a href="#精彩部分" class="headerlink" title="精彩部分"></a>精彩部分</h2><p><code>$( function(){ setTimeout( connect, 100); });</code> 我们用了一个 0.1 秒的延时因为有些版本的浏览器需要这样。比如，Safari的某些版本，如果不用延时，你可能会看到“加载菊花”一直在转呀转，我讨厌 100 毫秒这个“魔法数字”，但它确实有用。</p><p>一种数据存储的优化方案是用 setInterval 每隔 30 秒保存一次数据，而不是每次获得数据的时候。这显著地降低了CPU的使用。需要注意的事是，关闭浏览器时，在上一次保存之后传过来的数据会丢失。</p><p>产品级品质要求当出现错误时系统能自动修复，能适应现实世界的各种限制</p><p>只写一句 var d = JSON.parse( s); 是不够的，达到产品级品质要这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; <span class="keyword">var</span> d = <span class="built_in">JSON</span>.parse( s); &#125; </span><br><span class="line"><span class="keyword">catch</span> (e) &#123; <span class="built_in">console</span>.log(<span class="string">" BAD JSON:"</span> + s + <span class="string">"\ n"</span> + e); <span class="keyword">return</span>; &#125;</span><br></pre></td></tr></table></figure></p><p>能够准确的报告错误。</p><p>长连接可以简单地通过发送 SSE 注释行来维持。</p><p>发送 SSE 注释行和发送 SSE 数据行的区别在于后者触发了 EventObject 的消息事件处理程序，而前者没有触发。</p><p>没有使用SSE自带的重连机制有两个原因：第一个原因是只有套接字死得优雅干脆利落时浏览器才会重连；第二个原因很合理而且简单，代码要适用于向后兼容方案，这也是为什么长连接消息要像普通消息一样能用 JavaScript处理。</p><p>重连函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keepaliveSecs = <span class="number">20</span>,</span><br><span class="line">    keepaliveTimer = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 重连函数，将该函数放入数据处理和连接函数中，20秒没有收到消息，自动重连。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gotActivity</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(keepaliveTimer != <span class="literal">null</span>) clearTimeout(keepaliveTimer);</span><br><span class="line">    keepaliveTimer = setTimeout(connect,keepaliveSecs * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processOneLine</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    gotActivity();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连接函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    gotActivity();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.EventSource)startEventSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器关闭了套接字，浏览器会执行如下几步。</p><ul><li>设置 readyState （EventSource对象的一个属性）值为 EventSource.CONNECTING 。</li><li>调用 error 事件处理程序。</li><li>等待 retry 延时时间，然后重新连接。</li></ul><p>如果把发送长连接消息的时间间隔设置太长，浏览器（或者中转媒介）会认为出错了，并关闭套接字，尝试重连，这样整体上会造成更多负载。所以只能在 15 ~ 40 秒这个范围内调整重连时间</p><p>以通过在SSE消息中添加这一行来修改默认的内置重连时间：retry:10000</p><p>防止瞬间并发量过大的情况,将客户端的连接尝试随机地均摊在约定连接时间的前 60 内<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">temporarilyDisconnect</span>(<span class="params">secs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> millisecs = secs * <span class="number">1000</span>;</span><br><span class="line">    millisecs -= <span class="built_in">Math</span>.random() * <span class="number">60000</span>;</span><br><span class="line">    <span class="keyword">if</span> (millisecs &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (keepaliveTimer) &#123;</span><br><span class="line">        clearTimeout(keepaliveTimer);</span><br><span class="line">        keepaliveTimer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (es) &#123;</span><br><span class="line">        es.close();</span><br><span class="line">        es = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(connect, millisecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在id:字段使用JSON对象，有一件事需要注意：如果达到 100 多字节，就不能用GET请求了，需要用 Cookie。如果达到了几千字节，通过 HTTP 请求头发送时会有问题（记住是 SSE 发送这个请求头，我们不能控制它）。特别是当请求头的总大小（请求行，所有的请求头，包括user agent 和所有的 Cookie）超过 8 KB时，大部分网络服务软件会报错（返回 413 状态码）。</p><p>向后兼容方法长轮询的优化方案：</p><ul><li>让客户端慢一点，给长轮询设置时间间隔。</li><li>在服务器端为长轮询的客户端缓冲数据，以不超过一秒一次的频率给客户端发送数据。</li></ul><p>在服务器端为长轮询的客户端缓冲数据具体做法：<br>以不超过1秒1次的频率给客户端发送数据。这怎么工作？首先，记录下连接的时间（比如，18:30:00.000）。然后，假设在18:30:00.150时有数据要发送，这时先不发，设置一个850毫秒的延时，但在计时器触发之前（比如，在18:30:00.900时），又有要发给客户端的数据。继续等待，再等100毫秒，如果这100毫秒内没有新数据，那等100毫秒过后发送数据。这样，客户端会收到两份在一起的数据。<br>另一种情况，如果客户端在18:30:00.000时建立连接，但第一份数据在18:30:01.100（请求开始后1.1秒后）才产生该怎么办呢？这种情况就立即发送数据并且关闭连接。换句话，人为的延时只会在1秒的时间内有多个数据时才会引入，这实际上意味着只会在有大量数据时放慢速度，这正是我们想要的。</p><p>使用meta标签，在页面禁用js时自动连接到新页面<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span> =<span class="string">"refresh"</span> <span class="attr">content</span> =<span class="string">" 0; URL = longpoll.nojs.php"</span>/&gt;</span><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- php模板生成的新页面 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 当启用脚本后，会回到具有完整实时更新服务的网站 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">window</span>.location.href = <span class="string">"minimal_longpoll_test.html"</span> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用meta元素每隔一段时间刷新次页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">" refresh"</span> <span class="attr">content</span>=<span class="string">" 3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">" utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span> Update test when JS disabled <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>( Enable JavaScript for better responsiveness.)<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>浏览器有并行连接数的限制，一般是 6 个。如果超出了并行连接数新请求会静静的放到一个栈中，并且对那个服务器的所有其他通信（比如，请求新图片）也都会被搁置。</p><p>301 意思是需要使用一个新的 URL。<br>305 意思是应该使用一个代理<br>420 和 429，意味着连接请求太频繁了</p><p>使得IE8及更早的浏览器支持Object.keys<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.keys = <span class="built_in">Object</span>.keys || <span class="function"><span class="keyword">function</span> (<span class="params">o, k, r</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        r = [];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (k <span class="keyword">in</span> o)<span class="keyword">if</span> (o.hasOwnProperty(k))r.push(k);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> r;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使得IE7及更早版本支持JSON解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lte IE 7]&gt;</span></span><br><span class="line"><span class="comment">&lt;script src="json2.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></p><p>向后兼容方案只打开一条连接，然后持续的输出数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNewText</span>(<span class="params">s, prevOffset, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s)<span class="keyword">return</span> prevOffset;</span><br><span class="line">    <span class="keyword">var</span> lastLF = s.lastIndexOf(<span class="string">"\n"</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lastLF == <span class="number">0</span> || prevOffset == lastLF)<span class="keyword">return</span> prevOffset;</span><br><span class="line">    <span class="keyword">var</span> lines = s.substring(prevOffset, lastLF - <span class="number">1</span>).split(<span class="regexp">/\n/</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> ix <span class="keyword">in</span> lines)callback(lines[ix]);</span><br><span class="line">    <span class="keyword">return</span> lastLF; <span class="comment">//下一次的起始点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了避免内存溢出，需要监控字符串大小，一旦过大了，就关闭连接重连。该技术不能在IE上实现，因为IE上的xhr.readyState在4之前不会设置xhr.responseText的值。而这个技术的要点在于xhr.readyState永远不会成为4。</p><p>兼容方案iframe将数据加载到一个动态创建的<code>&lt;iframe&gt;</code>，然后去查看这个iframe的源码！<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Simple IFrame-Streaming Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">getNewText</span>(<span class="params">s, prevOffset, callback</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (!s)<span class="keyword">return</span> prevOffset;</span></span><br><span class="line"><span class="javascript">                 <span class="keyword">var</span> lastLF = s.lastIndexOf(<span class="string">"\n"</span>) + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (lastLF == <span class="number">0</span> || prevOffset == lastLF)<span class="keyword">return</span> prevOffset;</span></span><br><span class="line"><span class="javascript">                 <span class="keyword">var</span> lines = s.substring(prevOffset, lastLF - <span class="number">1</span>).split(<span class="regexp">/\n/</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> ix <span class="keyword">in</span> lines)callback(lines[ix]);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> lastLF; <span class="comment">//下一次的起始点</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"latest"</span>&gt;</span>Preparing...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"x"</span>&gt;</span>Preparing...<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">connectIframe</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span></span><br><span class="line"><span class="javascript">            iframe.setAttribute(<span class="string">"style"</span>, <span class="string">"display: none;"</span>);</span></span><br><span class="line"><span class="javascript">            iframe.setAttribute(<span class="string">"src"</span>, <span class="string">"abc_stream.php"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> prevOffset = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">            setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> s = iframe.contentWindow.document.body.innerHTML;</span></span><br><span class="line"><span class="javascript">                prevOffset = getNewText(s, prevOffset, <span class="function"><span class="keyword">function</span> (<span class="params">line</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.getElementById(<span class="string">"latest"</span>).innerHTML = line;</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">"x"</span>).innerHTML = s;</span></span><br><span class="line"><span class="undefined">            &#125;, 500);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">window</span>.postMessage) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"x"</span>).innerHTML = <span class="string">"OK"</span>;</span></span><br><span class="line"><span class="undefined">            setTimeout(connectIframe, 100);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"x"</span>).innerHTML = <span class="string">"Sorry!"</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">     </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用显式的 xhr 或者 longpoll 有两个小优势。首先它可以出现在服务端日志中，而 HTTP请求头通常不会，这可能有助于故障排查。其次，请求头方案会有一些风险，比如浏览器出 bug 而遗漏发送请求头，或者遗漏了连接符等。而发送 URL 参数完全是无风险的。</p><p>可以像处理其他 URL 一样对 SSE 脚本进行IP限制或密码保护。在Apache服务器下的.htaccess 文件来设置限制，比如:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Files</span> "<span class="attr">log_headers_ip_restrict.php</span>"&gt;</span></span><br><span class="line">    order deny,allow</span><br><span class="line">    deny from all</span><br><span class="line">    allow from 127.0.0.1</span><br><span class="line"><span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>表示只允许127.0.0.1的IP访问。</p><p>配置输入用户名和密码才能进行访问<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AuthUserFile /etc/apache2/sse_book_htpasswd</span><br><span class="line">AuthType Basic</span><br><span class="line">AuthName SSEBook</span><br><span class="line"><span class="tag">&lt;<span class="name">Files</span> "<span class="attr">log_headers_basic_auth.php</span>"&gt;</span></span><br><span class="line">  require valid-user</span><br><span class="line"><span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>/etc/apache2/sse_book_htpasswd文件中包含<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oreilly:AhsbB/t5vHsxA</span><br></pre></td></tr></table></figure></p><p>SSE不允许POST数据到服务端，也不允许指定HTTP请求头。</p><p>鉴权方式</p><ul><li>服务器认证，如Apache的http服务器配置.htaccess文件</li><li>使用Cookie进行认证</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;评-HTML5数据推送应用开发&quot;&gt;&lt;a href=&quot;#评-HTML5数据推送应用开发&quot; class=&quot;headerlink&quot; title=&quot;[评]HTML5数据推送应用开发&quot;&gt;&lt;/a&gt;[评]HTML5数据推送应用开发&lt;/h1&gt;&lt;p&gt;《HTML5数据推送应用开发》不仅介绍了HTML5的服务器端推送接口SSE,还介绍了向后兼容方案，服务器端代码实现，性能优化最终打造一个产品级品质的产品。&lt;/p&gt;
    
    </summary>
    
      <category term="书评" scheme="http://yeomanye.github.io/categories/%E4%B9%A6%E8%AF%84/"/>
    
    
      <category term="JavaScript" scheme="http://yeomanye.github.io/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://yeomanye.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Sublime插件推荐</title>
    <link href="http://yeomanye.github.io/2017/09/15/Sublime%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <id>http://yeomanye.github.io/2017/09/15/Sublime插件推荐/</id>
    <published>2017-09-14T16:00:00.000Z</published>
    <updated>2017-12-09T15:57:01.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sublime插件推荐"><a href="#Sublime插件推荐" class="headerlink" title="Sublime插件推荐"></a>Sublime插件推荐</h1><p>Sublime Text 是前Google工程师John Skinner编写的一个编辑器。虽然这个编辑器是闭源且收费(可以无限期试用)，但是因为这个编辑器强大的功能和美丽的外观，吸引了许许多多的用户，并为其构建了许多强大的插件。</p><a id="more"></a><h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><h3 id="A-File-Icon"><a href="#A-File-Icon" class="headerlink" title="A File Icon"></a><a href="https://github.com/ihodev/a-file-icon" target="_blank" rel="noopener">A File Icon</a></h3><p>用于给文件加上图标，效果如下：<br><img src="a-file-icon.png" alt="a-file-icon"></p><h3 id="AdvancedNewFile"><a href="#AdvancedNewFile" class="headerlink" title="AdvancedNewFile"></a><a href="https://github.com/skuroda/Sublime-AdvancedNewFile" target="_blank" rel="noopener">AdvancedNewFile</a></h3><p>使用快捷键打开路径输入框，以单前文件夹所在路径为相对路径，输入路径即可创建文件。</p><h3 id="AutoFileName"><a href="#AutoFileName" class="headerlink" title="AutoFileName"></a><a href="https://github.com/BoundInCode/AutoFileName" target="_blank" rel="noopener">AutoFileName</a></h3><p>自动提示文件路径，目前能够使用该插件的范围有:”string”,”css”,”sass”,”less”,”scss”</p><h3 id="Clickable-URLs"><a href="#Clickable-URLs" class="headerlink" title="Clickable URLs"></a><a href="https://github.com/leonid-shevtsov/ClickableUrls_SublimeText" target="_blank" rel="noopener">Clickable URLs</a></h3><p>能够打开编辑器中出现的URL，可以通过快捷键加鼠标点击的方式、可以右键URL选择菜单中的打开项。打开超链接使用的浏览器也可以在插件中配置。</p><h3 id="Color-Highlighter"><a href="#Color-Highlighter" class="headerlink" title="Color Highlighter"></a><a href="https://github.com/Monnoroch/ColorHighlighter" target="_blank" rel="noopener">Color Highlighter</a></h3><p>能够高亮代码中的颜色片段，支持各种形式的颜色，还有颜色值变换，和颜色值形式改变的功能。(不过我再win7系统下没法使用这两个功能)</p><p><img src="color-highlighter.png" alt="color-highlighter"></p><h3 id="Compare-Side-By-Side"><a href="#Compare-Side-By-Side" class="headerlink" title="Compare Side-By-Side"></a><a href="https://github.com/DougTy/sublime-compare-side-by-side/" target="_blank" rel="noopener">Compare Side-By-Side</a></h3><p>比较两个文本不同之处的插件</p><p><img src="compare-side-by-side.png" alt="compare-side-by-side"></p><h3 id="EasyMotion"><a href="#EasyMotion" class="headerlink" title="EasyMotion"></a><a href="https://github.com/jaredpar/EasyMotion" target="_blank" rel="noopener">EasyMotion</a></h3><p>跳转到特定位置，默认情况</p><ul><li><code>ctrl+;</code>+任意字符，出现跳转标记，点击标记对应按键，跳转到对应位置</li><li><code>ctrl+;</code>+enter,跳转到某一行的行首或行尾</li></ul><p>个人感觉还是sublime自带的vim模式好用点</p><p><img src="easy-motion.png" alt="easy-motion"></p><h3 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a><a href="https://github.com/sindresorhus/editorconfig-sublime" target="_blank" rel="noopener">EditorConfig</a></h3><p>根据.editorconfig文件配置的代码风格，来设置sublime中的编码风格。</p><p><a href="http://blog.csdn.net/gextreme/article/details/23794837" target="_blank" rel="noopener">EditorConfig配置</a></p><h3 id="Insert-Nums"><a href="#Insert-Nums" class="headerlink" title="Insert Nums"></a><a href="https://github.com/jbrooksuk/InsertNums" target="_blank" rel="noopener">Insert Nums</a></h3><p>插入递增序列，可以是递增数字，也可以是字母。</p><h3 id="SideBar-Folder"><a href="#SideBar-Folder" class="headerlink" title="SideBar Folder"></a><a href="https://github.com/titoBouzout/SideBarFolders" target="_blank" rel="noopener">SideBar Folder</a></h3><p>安装后，Sublime菜单栏上会多出一个Folders项，用于管理文件夹和文件夹使用的记录。安装了该插件后sublime可以打开多个文件夹。</p><h3 id="zeal"><a href="#zeal" class="headerlink" title="zeal"></a><a href="https://github.com/vaanwd/Zeal" target="_blank" rel="noopener">zeal</a></h3><p>在sublime中快速唤出zeal查看API文档</p><h3 id="ConvertToUTF8"><a href="#ConvertToUTF8" class="headerlink" title="ConvertToUTF8"></a><a href="https://github.com/seanliang/ConvertToUTF8/blob/master/README.zh_CN.md" target="_blank" rel="noopener">ConvertToUTF8</a></h3><p>可以打开Sublime不支持的编码格式（如：GBK、GB2312、BIG5），也可以将文件保存成这些格式。</p><h3 id="ColorPicker"><a href="#ColorPicker" class="headerlink" title="ColorPicker"></a><a href="https://github.com/weslly/ColorPicker" target="_blank" rel="noopener">ColorPicker</a></h3><p>打开颜色选择器选择颜色后会以HEX的格式输出颜色值。</p><p><img src="color-picker.png" alt="color-picker"></p><h3 id="SublimeTextTrans"><a href="#SublimeTextTrans" class="headerlink" title="SublimeTextTrans"></a><a href="https://github.com/vhanla/SublimeTextTrans" target="_blank" rel="noopener">SublimeTextTrans</a></h3><p>将sublime的背景设置为透明</p><p><img src="sublime-text-trans.png" alt="sublime-text-trans"></p><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a><a href="https://github.com/wbond/sublime_terminal" target="_blank" rel="noopener">Terminal</a></h3><p>在sublime中直接打开终端，可以定位到文件所在的位置。</p><h3 id="SublimeREPL"><a href="#SublimeREPL" class="headerlink" title="SublimeREPL"></a><a href="https://github.com/wuub/SublimeREPL" target="_blank" rel="noopener">SublimeREPL</a></h3><p>能够在sublime中使用REPL，包括:Python、Ruby、NodeJS等各种语言的REPL。</p><h3 id="Themr"><a href="#Themr" class="headerlink" title="Themr"></a><a href="https://github.com/benweier/Themr" target="_blank" rel="noopener">Themr</a></h3><p>主题选择器，能够设置主题为最爱主题<code>Add current theme to favorites</code>，还能够随机选择主题。</p><ul><li><code>ctrl+f5</code>全部主题</li><li><code>ctrl+shift+f5</code>最喜欢的主题</li></ul><h3 id="All-Autocomplete"><a href="#All-Autocomplete" class="headerlink" title="All Autocomplete"></a><a href="https://github.com/alienhard/SublimeAllAutocomplete" target="_blank" rel="noopener">All Autocomplete</a></h3><p>从所有打开的页面中查找匹配的词得出智能提示，sublime默认只从当前页面查找匹配词，生成智能提示。</p><h2 id="Markdown相关"><a href="#Markdown相关" class="headerlink" title="Markdown相关"></a>Markdown相关</h2><h3 id="Markdown-Editing"><a href="#Markdown-Editing" class="headerlink" title="Markdown Editing"></a><a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="noopener">Markdown Editing</a></h3><p>为编写markdown添加更好的主题、更全面的语法支持、以及一些有用的特性（snippet、快捷键等）</p><h3 id="OmniMarkupPreview"><a href="#OmniMarkupPreview" class="headerlink" title="OmniMarkupPreview"></a><a href="https://github.com/timonwong/OmniMarkupPreviewer" target="_blank" rel="noopener">OmniMarkupPreview</a></h3><p>提供实时markdown文档的实时预览功能，还能生成HTML文档。</p><h3 id="Table-Editor"><a href="#Table-Editor" class="headerlink" title="Table Editor"></a><a href="https://github.com/vkocubinsky/SublimeTableEditor" target="_blank" rel="noopener">Table Editor</a></h3><p>用于快速生成表格，在第一行确定了表格的列数后，可以使用Tab键快速的跳转到表格的单元或生成行。</p><h2 id="GitHub相关"><a href="#GitHub相关" class="headerlink" title="GitHub相关"></a>GitHub相关</h2><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a><a href="https://github.com/condemil/Gist" target="_blank" rel="noopener">Gist</a></h3><p>用于设置和添加gist上的代码片段，需要给gist设置对应的token，并给予权限。这个插件不足之处是只能获得gist上的文件单元内的所有文件，而不能一个一个文件获取。</p><h3 id="GitGutter"><a href="#GitGutter" class="headerlink" title="GitGutter"></a><a href="https://github.com/jisaacks/GitGutter" target="_blank" rel="noopener">GitGutter</a></h3><p>根据保存在git中的文件状态给文件中的每一行添加标志。</p><p><img src="git-gutter.png" alt="git-gutter"></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="Sublime-Better-Completion"><a href="#Sublime-Better-Completion" class="headerlink" title="Sublime Better Completion"></a><a href="https://github.com/Pleasurazy/Sublime-Better-Completion" target="_blank" rel="noopener">Sublime Better Completion</a></h3><p>智能提示插件，支持许多语言包括jQuery、JS、html、css、bootstrap等</p><h3 id="DocBlockr"><a href="#DocBlockr" class="headerlink" title="DocBlockr"></a>DocBlockr</h3><p>不仅能够生成类似Java语言的注释，而且还能自定义定义注释的格式。</p><h3 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a><a href="https://github.com/sergeche/emmet-sublime" target="_blank" rel="noopener">Emmet</a></h3><p>使得sublime支持emmet语法</p><h3 id="Autoprefixer"><a href="#Autoprefixer" class="headerlink" title="Autoprefixer"></a><a href="https://github.com/sindresorhus/sublime-autoprefixer" target="_blank" rel="noopener">Autoprefixer</a></h3><p>根据CSS属性自动生成浏览器前缀</p><h3 id="HTML-CSS-JS-Prettify"><a href="#HTML-CSS-JS-Prettify" class="headerlink" title="HTML/CSS/JS Prettify"></a><a href="https://github.com/HolicEro/HTML-CSS-JS-Prettify-Custom" target="_blank" rel="noopener">HTML/CSS/JS Prettify</a></h3><p>HTML、CSS、JS、JSON等代码格式化插件</p><h3 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a><a href="https://github.com/Grafikart/ST3-LiveReload" target="_blank" rel="noopener">LiveReload</a></h3><p>检测文件变化自动刷新页面</p><p>使用这个插件还需要配合上浏览器的扩展<a href="https://chrome.google.com/webstore/detail/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank" rel="noopener">LiveReload扩展</a></p><p>然后给插件添加如下配置<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"enabled_plugins"</span>: [</span><br><span class="line">        <span class="string">"SimpleReloadPlugin"</span>,</span><br><span class="line">        <span class="string">"SimpleRefresh"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打开要监听的页面，点击浏览器扩展空心圆变成了实心圆，即可正常监听。</p><h3 id="LiveStyle"><a href="#LiveStyle" class="headerlink" title="LiveStyle"></a>LiveStyle</h3><p>使得浏览器与编辑器中样式的修改能够同步，需要安装<a href="https://chrome.google.com/webstore/detail/emmet-livestyle/diebikgmpmeppiilkaijjbdgciafajmg?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Emmet LiveStyle插件</a></p><p>chrome浏览器中的工作空间能实现类似的效果</p><h3 id="SublimeLinter"><a href="#SublimeLinter" class="headerlink" title="SublimeLinter"></a><a href="https://github.com/SublimeLinter/SublimeLinter3" target="_blank" rel="noopener">SublimeLinter</a></h3><p>用于检测文件语法是否规范，这是linter的管理器，如果想对某一种语言实行语法检查，还需要下载对应的linter和nodejs中对应的模块。<br>js:SublimeLinter-jshint、SublimeLinter-contrib-eslint 分别对应：jshint、eslint模块<br>css:SublimeLinter-csslint 对应 csslint 模块<br>html:SublimeLinter-htmlhint   对应 htmlhint 模块</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a><a href="https://github.com/DamnWidget/anaconda" target="_blank" rel="noopener">Anaconda</a></h3><p>提供高效的开发环境，只此一个插件就能将sublime打造为python IDE。该插件提供了自动完成，API说明，重构，McCode代码复杂性检测，lint，自动格式化等功能。</p><h3 id="SublimeLinter-pep8"><a href="#SublimeLinter-pep8" class="headerlink" title="SublimeLinter-pep8"></a><a href="https://github.com/SublimeLinter/SublimeLinter-pep8" target="_blank" rel="noopener">SublimeLinter-pep8</a></h3><p>python语法检测插件配合sublimelinter使用，同时还需要使用pip安装pep8</p><p><code>[sudo] pip-3.x install pep8</code></p><h3 id="Python-Pep8-AutoFormat"><a href="#Python-Pep8-AutoFormat" class="headerlink" title="Python Pep8 AutoFormat"></a><a href="https://github.com/Stibbons/pythonpep8autoformat" target="_blank" rel="noopener">Python Pep8 AutoFormat</a></h3><p>根据pep8编码规范，自动格式化。除了使用快捷键方式格式化外，还可以设置为保存的时候自动格式化。</p><!-- ## 主题皮肤### [Agila](https://github.com/arvi/Agila-Theme)![Agila](Agila.png)### [Material](https://github.com/equinusocio/material-theme)![Material](Material.gif) --><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="react-native-snippets"><a href="#react-native-snippets" class="headerlink" title="react-native-snippets"></a><a href="https://github.com/Shrugs/react-native-snippets" target="_blank" rel="noopener">react-native-snippets</a></h3><p>react native代码片段插件，可生成的代码片段包括生命周期函数、快速定义组件、快速设置状态等。</p><h3 id="react-native-css-snippets"><a href="#react-native-css-snippets" class="headerlink" title="react-native-css-snippets"></a><a href="https://github.com/txji/react-native-css-snippets" target="_blank" rel="noopener">react-native-css-snippets</a></h3><p>react native样式提示插件，能够快速生成样式</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Sublime插件推荐&quot;&gt;&lt;a href=&quot;#Sublime插件推荐&quot; class=&quot;headerlink&quot; title=&quot;Sublime插件推荐&quot;&gt;&lt;/a&gt;Sublime插件推荐&lt;/h1&gt;&lt;p&gt;Sublime Text 是前Google工程师John Skinner编写的一个编辑器。虽然这个编辑器是闭源且收费(可以无限期试用)，但是因为这个编辑器强大的功能和美丽的外观，吸引了许许多多的用户，并为其构建了许多强大的插件。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="http://yeomanye.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="软件" scheme="http://yeomanye.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
</feed>
