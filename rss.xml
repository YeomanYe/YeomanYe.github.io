<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>探险</title>
  
  
  <link href="/rss.xml" rel="self"/>
  
  <link href="http://yeomanye.github.io/"/>
  <updated>2018-03-18T16:14:32.714Z</updated>
  <id>http://yeomanye.github.io/</id>
  
  <author>
    <name>FWHeart</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017年终总结与未来展望</title>
    <link href="http://yeomanye.github.io/2018/02/14/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B/"/>
    <id>http://yeomanye.github.io/2018/02/14/2017年终总结与未来展望/</id>
    <published>2018-02-13T16:00:00.000Z</published>
    <updated>2018-03-18T16:14:32.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2017年终总结与未来展望"><a href="#2017年终总结与未来展望" class="headerlink" title="2017年终总结与未来展望"></a>2017年终总结与未来展望</h1><p>今年我从学校毕业开启了工作的生涯，前半年还在学校、后半年已踏入社会，在这一年的时间经历了不少相聚离别，感慨颇多。</p><a id="more"></a><p>年初我在天津的一家地图开发的公司实习，在这家公司上班工资不高、工作清闲，虽然干的活不是很满意，但也自己骗自己“工作嘛，肯定都会有不顺心的地方”。于是我硬着头皮干活，领导如果不交代任务自己就偷偷懒，看看文章、读读源码。想着以后要跳槽找一个更喜欢的、更有意义的工作。我本打算在这家公司干个半年，之后再做打算的。也许回家，也许去往远方。跟我有同样想法的还有徐同学，他是打算在这学习技术半年后跳槽到北京找工作。也许是因为我们对公司都存着不满，两个人对不满的叠加，最后下定决心辞职去北京找工作。经过了两周的碰壁后，在北京找到了一份8k还包吃的工作，当时我觉得这份工作已经是我这个非本专业二本生最好的归宿了。我觉得我是不可能再找到比这待遇更好的工作了。不久后，我的同事找到了一份月入一万还提供不错的住宿环境和设备的工作。我的同事告诉我他能够内推我。当时我并没有想去他们的公司，因为这个时候我已经在这家公司干了一段时间了，跟同事们也建立了一定的感情。不想因为多一点点的好处而离开，然而我最后还是因为五险一金缴费比例太低而离开了。</p><p>16年给自己定下的目标，阅读30本书籍，github贡献度超过两百天。书籍只完成阅读了一半的数量，大约17本。github贡献度确实达到了目标，但是github上贡献的多是自己写的没有什么意义营养的内容，只是为了完成而完成着实没有意义。</p><p>虽然没有什么较大的成功、突破，但是17年自己也是做了事情的。虽然总下载量还没有破千，但是17年我写了几个网页脚本。改写了几个浏览器插件，使得插件更加适合自己。尝试了lua脚本，android逆向。</p><p>虽然17年的目标完成的并不理想，但仍然不妨碍18年给自己制定小目标。一阅读15本书籍，二编写五个软件（不一定要非得是app、桌面版软件、浏览器插件、甚至复杂的网页脚本都可以算），三掌握好移动端的开发技术不止限于react native、flutter、ionic这些跨平台方便的开发方案，还需要掌握原生的开发方案，并了解主流的技术如kotlin之类的，成为移动端的中高手。四多参加群体活动，多与人接触交流。</p><p>总结下今年相比于去年最大的改变：一是从学校毕业，送别了不少朋友、同学；二是与同事跳槽来到了北京，在北京找到了一份令自己满意的工作。前者是时间的选择，后者是自己的选择。有句话说到好，“走出去，世界就在眼前；不走出去，眼前就是世界”。2018年，我要更多的与世界接触。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2017年终总结与未来展望&quot;&gt;&lt;a href=&quot;#2017年终总结与未来展望&quot; class=&quot;headerlink&quot; title=&quot;2017年终总结与未来展望&quot;&gt;&lt;/a&gt;2017年终总结与未来展望&lt;/h1&gt;&lt;p&gt;今年我从学校毕业开启了工作的生涯，前半年还在学校、后半年已踏入社会，在这一年的时间经历了不少相聚离别，感慨颇多。&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yeomanye.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年终总结" scheme="http://yeomanye.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>underscore源码分析</title>
    <link href="http://yeomanye.github.io/2018/01/28/underscore%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yeomanye.github.io/2018/01/28/underscore源码分析/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-02-14T14:54:10.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="underscore源码分析"><a href="#underscore源码分析" class="headerlink" title="underscore源码分析"></a>underscore源码分析</h1><p>Underscore一个JavaScript实用库，提供了一整套函数式编程的实用功能，前前后后总共100+个方法，但是没有扩展任何JavaScript内置对象。</p><a id="more"></a><p>underscore整体在一个闭包函数中，加载underscore类库时，执行代码自适应不同的JS环境。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//找出当前执行的环境的全局变量</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class="line">        <span class="keyword">typeof</span> global == <span class="string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global ||</span><br><span class="line">        <span class="keyword">this</span> ||</span><br><span class="line">        &#123;&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;())</span><br></pre></td></tr></table></figure><p>仅供内部使用的函数都以驼峰命名法进行命名，供外部使用的函数都挂载在<code>_</code>上。当然能供外部使用的函数内部也有在使用。underscore主要有四个部分使用感到精彩，高内聚低耦合的内部方法、依据环境生成方法、特殊方法的实现、其他。</p><h2 id="高内聚低耦合的内部方法"><a href="#高内聚低耦合的内部方法" class="headerlink" title="高内聚低耦合的内部方法"></a>高内聚低耦合的内部方法</h2><p>optimizeCb返回一个绑定了上下文的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br><span class="line">    <span class="keyword">switch</span> (argCount) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(context, value);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>cb 返回一个回调函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">value, context, argCount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当外部自定义回调生成器时使用回调生成器，生成一个回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (_.iteratee !== builtinIteratee) <span class="keyword">return</span> _.iteratee(value, context);</span><br><span class="line">    <span class="comment">// 返回一个默认的回调函数，该函数返回传入的第一个值</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</span><br><span class="line">    <span class="comment">// 生成一个绑定上下文的函数</span></span><br><span class="line">    <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</span><br><span class="line">    <span class="comment">// 生成一个对象匹配器，随后可以使用数组、对象来判断是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (_.isObject(value) &amp;&amp; !_.isArray(value)) <span class="keyword">return</span> _.matcher(value);</span><br><span class="line">    <span class="comment">// 生成一个获取对象属性的函数</span></span><br><span class="line">    <span class="keyword">return</span> _.property(value);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>restArgs包装一个函数，将函数多余的参数包装为一个数组传递给最后一个参数，减少了每个函数中都是用arguments获取多余参数的麻烦<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> restArgs = <span class="function"><span class="keyword">function</span>(<span class="params">func, startIndex</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// func.length获取定义的形式参数个数</span></span><br><span class="line">  startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="built_in">Math</span>.max(<span class="built_in">arguments</span>.length - startIndex, <span class="number">0</span>),</span><br><span class="line">        rest = <span class="built_in">Array</span>(length),</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从命名的形式参数的最后一个开始到结尾的所有参数包装成一个数组参数</span></span><br><span class="line">    <span class="keyword">for</span> (; index &lt; length; index++) &#123;</span><br><span class="line">      rest[index] = <span class="built_in">arguments</span>[index + startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (startIndex) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class="line">      args[index] = <span class="built_in">arguments</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    args[startIndex] = rest;</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在对外函数中的使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断元素是否全部满足</span></span><br><span class="line">_.every = _.all = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">    predicate = cb(predicate, context);</span><br><span class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">        length = (keys || obj).length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">      <span class="keyword">if</span> (!predicate(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 延迟函数执行</span></span><br><span class="line">_.delay = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">func, wait, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="依据环境生成代码"><a href="#依据环境生成代码" class="headerlink" title="依据环境生成代码"></a>依据环境生成代码</h2><p>生成判断函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> _.each([<span class="string">'Arguments'</span>, <span class="string">'Function'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>, <span class="string">'Date'</span>, <span class="string">'RegExp'</span>, <span class="string">'Error'</span>, <span class="string">'Symbol'</span>, <span class="string">'Map'</span>, <span class="string">'WeakMap'</span>, <span class="string">'Set'</span>, <span class="string">'WeakSet'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    _[<span class="string">'is'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object '</span> + name + <span class="string">']'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//测试判断函数是否有效，无效则用新方法代替</span></span><br><span class="line"><span class="keyword">if</span> (!_.isArguments(<span class="built_in">arguments</span>)) &#123;</span><br><span class="line">        _.isArguments = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _.has(obj, <span class="string">'callee'</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodelist = root.document &amp;&amp; root.document.childNodes;</span><br><span class="line"><span class="comment">//浏览器特性监测，当前浏览器typeof，不将/./、NodeList视为函数,Int8Array视为对象，则可以使用typeof进行函数的判定</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> /./ != <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Int8Array</span> != <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> nodelist != <span class="string">'function'</span>) &#123;</span><br><span class="line">    _.isFunction = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> obj == <span class="string">'function'</span> || <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>生成链式函数调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成_对象,（只是将普通的对象包装为&#123;_wrapped:obj&#125;对象</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</span><br><span class="line">    <span class="keyword">this</span>._wrapped = obj;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 开启链式调用</span></span><br><span class="line">_.chain = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = _(obj);</span><br><span class="line">    instance._chain = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 如果上个对象为链式调用，则继续使用链式调用（将对象包装为_对象，并继续使用链式调用）</span></span><br><span class="line"><span class="keyword">var</span> chainResult = <span class="function"><span class="keyword">function</span>(<span class="params">instance, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance._chain ? _(obj).chain() : obj;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 混成，使用外部的方法覆盖内部方法、原型方法</span></span><br><span class="line"><span class="comment">// 原型方法为，使用_对象作为第一个参数，并将结果进行链式包装</span></span><br><span class="line">_.mixin = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    _.each(_.functions(obj), <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> func = _[name] = obj[name];</span><br><span class="line">      _.prototype[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];</span><br><span class="line">        push.apply(args, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> chainResult(<span class="keyword">this</span>, func.apply(_, args));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 生成原型方法</span></span><br><span class="line">_.mixin(_);</span><br></pre></td></tr></table></figure></p><h2 id="特殊方法实现"><a href="#特殊方法实现" class="headerlink" title="特殊方法实现"></a>特殊方法实现</h2><p><em>.partial 顺序填充一些参数给函数，并返回预处理后的函数使用`</em>`作为占位符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> executeBound = <span class="function"><span class="keyword">function</span>(<span class="params">sourceFunc, boundFunc, context, callingContext, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.apply(context, args);</span><br><span class="line">    <span class="keyword">var</span> self = baseCreate(sourceFunc.prototype);</span><br><span class="line">    <span class="keyword">var</span> result = sourceFunc.apply(self, args);</span><br><span class="line">    <span class="keyword">if</span> (_.isObject(result)) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">//根据预定义参数返回代理函数</span></span><br><span class="line">_.partial = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">func, boundArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> placeholder = _.partial.placeholder;</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> position = <span class="number">0</span>, length = boundArgs.length;</span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">Array</span>(length);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//组装参数，如果预填充的参数为占位符，则使用调用时的参数来补齐。</span></span><br><span class="line">        args[i] = boundArgs[i] === placeholder ? <span class="built_in">arguments</span>[position++] : boundArgs[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//添加剩余的参数</span></span><br><span class="line">      <span class="keyword">while</span> (position &lt; <span class="built_in">arguments</span>.length) args.push(<span class="built_in">arguments</span>[position++]);</span><br><span class="line">      <span class="comment">//执行原方法</span></span><br><span class="line">      <span class="keyword">return</span> executeBound(func, bound, <span class="keyword">this</span>, <span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//占位符</span></span><br><span class="line">_.partial.placeholder = _;</span><br></pre></td></tr></table></figure><p>_.throttle 节流函数返回一个函数，在一段时间之内只调用一次，用于处理像onresize这样会频繁触发的事件的处理函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 最后一次是否执行</span></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> now = _.now();</span><br><span class="line">      <span class="comment">//leading参数表示是否是以调用函数的时间做时间间隔。</span></span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//trailing参数表示是否事件结束仍进行调用。</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//取消节流函数</span></span><br><span class="line">    throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">      previous = <span class="number">0</span>;</span><br><span class="line">      timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>_.debounced 消抖函数，连续触发的情况下只会执行一次，用于作为像onresize这样会频繁触发的事件的处理函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait延迟执行的时间，immediate是否立即执行</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> timeout, result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (args) result = func.apply(context, args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debounced = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//含有timeout，即连续调用，不执行</span></span><br><span class="line">  <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">  <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">    <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">    timeout = setTimeout(later, wait);</span><br><span class="line">    <span class="comment">//有立即执行参数时，第一次调用马上执行。</span></span><br><span class="line">    <span class="keyword">if</span> (callNow) result = func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timeout = _.delay(later, wait, <span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//取消执行函数</span></span><br><span class="line">debounced.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearTimeout(timeout);</span><br><span class="line">  timeout = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> debounced;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_.negate 生成一个返回布尔类型相反的函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.negate = <span class="function"><span class="keyword">function</span>(<span class="params">predicate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !predicate.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>+0 不等于 -0的比较<br>if (a === b) return a !== 0 || 1 / a === 1 / b;</p><p>NaN比较<br>typeof NaN == ‘number’ &amp;&amp; NaN != NaN</p><p>Symbol相等的比较<br>Symbol.prototype.valueOf.call(a) === Symbol.prototype.valueOf.call(b)</p><p>匹配所有文字<br><code>/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;</code></p><p>函数定义时定义的参数的个数<br>func.length</p><p>去if,获得非undefined值的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(keys || obj).length;</span><br><span class="line"></span><br><span class="line">keys = !isArrayLike(obj) &amp;&amp; _.keys(obj);</span><br></pre></td></tr></table></figure></p><p>根据dir的值，进行正反方向的迭代<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;underscore源码分析&quot;&gt;&lt;a href=&quot;#underscore源码分析&quot; class=&quot;headerlink&quot; title=&quot;underscore源码分析&quot;&gt;&lt;/a&gt;underscore源码分析&lt;/h1&gt;&lt;p&gt;Underscore一个JavaScript实用库，提供了一整套函数式编程的实用功能，前前后后总共100+个方法，但是没有扩展任何JavaScript内置对象。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yeomanye.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="http://yeomanye.github.io/tags/JavaScript/"/>
    
      <category term="源码分析" scheme="http://yeomanye.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>zepto源码分析</title>
    <link href="http://yeomanye.github.io/2017/12/17/zepto%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yeomanye.github.io/2017/12/17/zepto源码分析/</id>
    <published>2017-12-16T16:00:00.000Z</published>
    <updated>2018-01-28T12:04:05.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zepto源码分析"><a href="#Zepto源码分析" class="headerlink" title="Zepto源码分析"></a>Zepto源码分析</h1><p>Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 因Zepto的轻量性、与JQ的相似性以及好用的移动事件(tap、swipe、doubleTap等)的封装，使得Zepto移动端开发中有着不少的应用场景。分析的版本是zepto当前的最新版本v1.2.0</p><a id="more"></a><p>zepto将整个库的功能拆分到了许多模块中，便于减小体积。无论开发者选用哪一个模块core模块是必不可少的。因此也必从core开始分析源码。</p><p>从github上下载源码后，打开src文件夹可以看到许多js文件，每个js文件对应一个模块。不用我说也能猜到js核心模块是zepto.js。</p><p>将代码折叠引入眼帘的是如下结构的代码,首先调用匿名函数进行初始化Zepto类库，然后将引用放到全局作用域中，并设置别名($)。非常的清晰易懂<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;)()</span><br><span class="line"><span class="built_in">window</span>.Zepto = Zepto</span><br><span class="line"><span class="built_in">window</span>.$ === <span class="literal">undefined</span> &amp;&amp; (<span class="built_in">window</span>.$ = Zepto)</span><br></pre></td></tr></table></figure></p><p>显然核心模块的重中之重是匿名的初始化函数，打开初始化的折叠，认真观察可以发现匿名函数内部又可以分成四个作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部定义的函数、变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">value</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">likeArray</span>(<span class="params">obj</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compact</span>(<span class="params">array</span>)</span>&#123;...&#125;</span><br><span class="line">$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 内部对象zepto对象上定义的函数、对象</span></span><br><span class="line">zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;...&#125;</span><br><span class="line">zepto.qsa = <span class="function"><span class="keyword">function</span>(<span class="params">element, selector</span>)</span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 内部函数 $ 上定义的函数、对象</span></span><br><span class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;...&#125;</span><br><span class="line">$.isArray = isArray</span><br><span class="line">$.isPlainObject = isPlainObject</span><br><span class="line"><span class="comment">// 内部对象 $.fn 上定义的函数、对象</span></span><br><span class="line">$.fn = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: zepto.Z,</span><br><span class="line">    length: 0,</span><br><span class="line">    concat: function()&#123;...&#125;,</span><br><span class="line">    map: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;...&#125;,</span><br><span class="line">    slice: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;,</span><br><span class="line">    ready: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然知道了其中有四个作用域，但是还并不清楚这几个作用域之间存在的关联性。认真查找会发现，有代码表明其关联性:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    zepto.Z.prototype = Z.prototype = $.fn</span><br><span class="line">    $.zepto = zepto</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p><code>$.fn</code>被作为Z构造器的原型，zepto被置于<code>$.zepto</code>命名空间下。认真分析我们调用的入口函数$，会发现该函数最终返回的结果必定为Z对象。</p><p>入口函数 $<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的是zepto中的init方法</span></span><br><span class="line">$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zepto.init(selector, context)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//init方法，根据传入的不同的值进行不同的操作，能够传入函数在页面加载完成后调后。</span></span><br><span class="line"><span class="comment">//能够传入对象、字符串、元素、元素片段、Z对象来生成一个Z对象</span></span><br><span class="line">zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dom</span><br><span class="line">    <span class="comment">// 没有参数时，则生成一个空的z对象</span></span><br><span class="line">    <span class="keyword">if</span> (!selector) <span class="keyword">return</span> zepto.Z()</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">'string'</span>) &#123;</span><br><span class="line">      selector = selector.trim()</span><br><span class="line">      <span class="comment">//参数为html代码时，生成html代码对应的元素，并设置选择器为空</span></span><br><span class="line">      <span class="keyword">if</span> (selector[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; fragmentRE.test(selector))</span><br><span class="line">        dom = zepto.fragment(selector, <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></span><br><span class="line">        <span class="comment">//参数为选择器时，查找上下文环境对应的元素</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</span><br><span class="line">      <span class="comment">// 查找元素，上下文环境不存在，从头查找</span></span><br><span class="line">      <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数是函数，页面加载完成后调用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(selector)) <span class="keyword">return</span> $(<span class="built_in">document</span>).ready(selector)</span><br><span class="line">    <span class="comment">// 参数是z对象，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (zepto.isZ(selector)) <span class="keyword">return</span> selector</span><br><span class="line">    <span class="comment">// 参数为元素对象、元素数组或片段元素时</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isArray(selector)) dom = compact(selector)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (isObject(selector))</span><br><span class="line">        dom = [selector], selector = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fragmentRE.test(selector))</span><br><span class="line">        dom = zepto.fragment(selector.trim(), <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</span><br><span class="line">      <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zepto.Z(dom, selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Z 对象(类数组，0~n是元素,length是长度，selector选择器)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Z</span>(<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, len = dom ? dom.length : <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">this</span>[i] = dom[i]</span><br><span class="line">    <span class="keyword">this</span>.length = len</span><br><span class="line">    <span class="keyword">this</span>.selector = selector || <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">zepto.Z = <span class="function"><span class="keyword">function</span>(<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Z(dom, selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以<code>$.fn</code>是以Z对象作为上下文环境(<code>即$.fn</code>中的this代表着Z对象)调用的函数。<code>$</code>下的函数则是以<code>$</code>函数为上下文的函数。</p><p>因此除了<code>$ $.fn zepto</code>下定义的函数、对象，其余的函数、对象都是为了实现接口的功能而定义的更基本的函数。</p><h2 id="个人收获"><a href="#个人收获" class="headerlink" title="个人收获"></a>个人收获</h2><p>zepto核心代码不过900多行，不过确实让我获益良多。</p><p>首先结构上，zepto将工具方法置于其命名空间<code>$</code>下，用户使用入口函数<code>$</code>获取需要操作的元素后，将其包装为Z对象。将可以操作Z对象的方法置于<code>$.fn</code>下，并将其作为Z对象的原型，使函数唯一。结构清晰、而又不失优雅</p><p>在语言机制上。使我学习到了，可以使用\n(n代表任意整数)来在正则匹配中获得括号中的内容，匹配后可以使用RegExp.$n来获得括号中的内容，也可以在replace等API中使用<code>$n</code>来获得匹配的内容(如 <code>.replace(/([A-Z]+)([A-Z][a-z])/g, &#39;$1_$2&#39;)</code>)，可以使用(?:)表示非捕获匹配。</p><p>学习到了array的各种好用的API：slice、map、reduce、concat、some、every。节点的各种属性：previousElementSibling、nextElementSibling、parentNode、offsetParent、scrollTop（兼容处理时pageYOffset）。节点的各种API：getBoundingClientRect（获取相对于父节点的位置信息，宽高等)</p><p>~0 //按位非，0变-1，-1变0。适合从indexOf等函数获得的值（即-1代表假）判断是否存在该值时的函数。<br>slice.call(arguments) 将类数组变为数组<br>multiple 多选属性，只存在于<code>&lt;select&gt;&lt;option&gt;</code>中<br>定义undefined变量，防止undefined被覆盖成非空值</p><p>其他的还有如hide，在调用时，用闭包的方式先保存元素对应的显示状态，在show时将显示状态还原等细节操作。</p><p>许多API的概念：</p><p>likeArray 检测是否为类数组(length为正数，并且length不为0时，length-1的值存在)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">likeArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = !!obj &amp;&amp; <span class="string">'length'</span> <span class="keyword">in</span> obj &amp;&amp; obj.length,</span><br><span class="line">      type = $.type(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'function'</span> != type &amp;&amp; !isWindow(obj) &amp;&amp; (</span><br><span class="line">      <span class="string">'array'</span> == type || length === <span class="number">0</span> ||</span><br><span class="line">        (<span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt; <span class="number">0</span> &amp;&amp; (length - <span class="number">1</span>) <span class="keyword">in</span> obj)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>classRE 生成匹配类名的正则表达式的函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classRE</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> classCache ?</span><br><span class="line">      classCache[name] : (classCache[name] = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(^|\\s)'</span> + name + <span class="string">'(\\s|$)'</span>))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>isEmpty 检测空对象(使用for…in循环，判断是否具有非空属性)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.isEmptyObject = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name</span><br><span class="line">    <span class="keyword">for</span> (name <span class="keyword">in</span> obj) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>removeProp 移除元素中的属性(使用delete关键字)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">removeProp: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      name = propMap[name] || name</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>[name] &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>extend 对象的拷贝(采用一一赋值的方式，深拷贝时判断为数组还是为对象，进行相应的循环操作)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> source)</span><br><span class="line">      <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</span><br><span class="line">          target[key] = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</span><br><span class="line">          target[key] = []</span><br><span class="line">        extend(target[key], source[key], deep)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>compact 去除数组中的空元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compact</span>(<span class="params">array</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> filter.call(array, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="keyword">return</span> item != <span class="literal">null</span> &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>flatten 将二维数组变成一维<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">array</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> array.length &gt; <span class="number">0</span> ? $.fn.concat.apply([], array) : array </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pluck 获取元素中的某属性，并组成为对应数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pluck: <span class="function"><span class="keyword">function</span>(<span class="params">property</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> $.map(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123; <span class="keyword">return</span> el[property] &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>traverseNode 使用递归遍历节点和其子节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseNode</span>(<span class="params">node, fun</span>) </span>&#123;</span><br><span class="line">    fun(node)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = node.childNodes.length; i &lt; len; i++)</span><br><span class="line">      traverseNode(node.childNodes[i], fun)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>funcArg 将传递的值或函数的情况抽象为一个处理函数，以便复用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context通常为z对象,idx通常为z对象中的节点，payload为自定义的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcArg</span>(<span class="params">context, arg, idx, payload</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isFunction(arg) ? arg.call(context, idx, payload) : arg</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zepto源码分析&quot;&gt;&lt;a href=&quot;#Zepto源码分析&quot; class=&quot;headerlink&quot; title=&quot;Zepto源码分析&quot;&gt;&lt;/a&gt;Zepto源码分析&lt;/h1&gt;&lt;p&gt;Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 因Zepto的轻量性、与JQ的相似性以及好用的移动事件(tap、swipe、doubleTap等)的封装，使得Zepto移动端开发中有着不少的应用场景。分析的版本是zepto当前的最新版本v1.2.0&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yeomanye.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="http://yeomanye.github.io/tags/JavaScript/"/>
    
      <category term="源码分析" scheme="http://yeomanye.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发概述</title>
    <link href="http://yeomanye.github.io/2017/10/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/"/>
    <id>http://yeomanye.github.io/2017/10/28/微信小程序开发概述/</id>
    <published>2017-10-27T16:00:00.000Z</published>
    <updated>2017-12-09T15:40:31.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序开发概述"><a href="#微信小程序开发概述" class="headerlink" title="微信小程序开发概述"></a>微信小程序开发概述</h1><p>由于微信的使用人数众多，因此微信小程序也受到许多企业公司的推崇。除此之外小程序还有开发简单容易，用户流量较大的优点，因此学习小程序还是很有意义的。</p><a id="more"></a><h2 id="开发入门"><a href="#开发入门" class="headerlink" title="开发入门"></a>开发入门</h2><p>浏览器环境的前端html、css、js分别对应于微信中的wxml、wxss、js文件。与浏览器环境不同的是每个页面(Page)和整个应用(App)都有对应名称的json文件用于配置，project.config.json文件用于开发环境的配置。</p><p><img src="wx架构.png" alt="wx架构"></p><h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><p>wxml(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>wxml页面数据绑定使用双括号的形式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">data-ml</span>=<span class="string">"&#123;&#123;a&#125;&#125;"</span>&gt;</span> &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>数据是单向绑定的，只有通过setData方法改变Page的data对象中的属性才能改变页面中对应表达式中的值</p><h3 id="条件渲染与列表渲染"><a href="#条件渲染与列表渲染" class="headerlink" title="条件渲染与列表渲染"></a>条件渲染与列表渲染</h3><p>条件渲染与列表渲染相当于，vue中的组件</p><p>条件渲染<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">"&#123;&#123;length &gt; 5&#125;&#125;"</span>&gt;</span> 1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">"&#123;&#123;length &gt; 2&#125;&#125;"</span>&gt;</span> 2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 3 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>wx:if是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。<br>相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。</p><p>列表渲染<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;array&#125;&#125;"</span> <span class="attr">wx:for-index</span>=<span class="string">"idx"</span> <span class="attr">wx:for-item</span>=<span class="string">"itemName"</span> <span class="attr">wx:key</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">  &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code>的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。<br>wx:key的两种值：字符串代表item中的某个熟悉;*this代表循环中的item本身</p><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>template定义的模板可以在任意地方引用<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- template.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"odd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> odd <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">"even"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span> even <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">src</span>=<span class="string">"header.wxml"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- header.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span> header <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>import可以在该文件中使用目标文件定义的template<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"item.wxml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"item"</span> <span class="attr">data</span>=<span class="string">"&#123;&#123;text: 'forbar'&#125;&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>相比于include使用import可以设置数据</p><p>import具有作用域的概念，C导入B，B导入A。C中只能获取B中的模板，而不能获取B中导入的A中的。</p><h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>wxss是小程序用于描述页面的样式语言，该语言与css基本相同。</p><p>新增加了rpx(responsive pixel)响应式单位，该单位可以根据屏幕宽度进行自适应。<br>样式导入@import “common.wxss”;</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>导出模块可以使用CommonJS机制和ES6的模块机制</p><p>CommonJS<br>每个js模块都在自己的作用域中，导出模块需要使用exports或module.exports<br>导入使用require,但是不支持绝对路径。</p><p>ES6<br>使用ES6的模块机制导出模块，导入使用import…from等关键字，导出使用export default关键字</p><h2 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h2><p>路由是指导航到页面的方式，路由的种类有：navigateTo、redirectTo、switchTab、reLaunch、navigateBack</p><p>除了navigateTo、switchTab的方式是隐藏当前页面其他的方式都会卸载当前页面。</p><p>navigateTo, redirectTo 只能打开非 tabBar 页面。<br>switchTab 只能打开 tabBar 页面。<br>reLaunch 可以打开任意页面。</p><p>具体见表<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/route.html" target="_blank" rel="noopener">路由</a></p><h2 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h2><p>小程序中事件分为冒泡和非冒泡两种类型。</p><p>事件的生命周期阶段与浏览器中相同都是先捕获后冒泡。</p><p>绑定事件的方式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">bindtap</span>=<span class="string">"handleTap1"</span>&gt;</span></span><br><span class="line">  outer view</span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"middle"</span> <span class="attr">catchtap</span>=<span class="string">"handleTap2"</span>&gt;</span></span><br><span class="line">    middle view</span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"inner"</span> <span class="attr">bindtap</span>=<span class="string">"handleTap3"</span>&gt;</span></span><br><span class="line">      inner view</span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">"inner"</span> <span class="attr">bind:touchstart</span>=<span class="string">"handleTap3"</span> <span class="attr">capture-bind:touchstart</span>=<span class="string">"handleTap4"</span>&gt;</span></span><br><span class="line">    inner view</span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>bind事件发生在冒泡阶段，且不阻止事件向上冒泡</li><li>capture-bind事件发生在捕获阶段，且不阻止事件捕获</li><li>catch事件发生在冒泡阶段，阻止事件向上冒泡</li><li>capture-catch事件发生在捕获阶段，阻止事件捕获</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>小程序提供了许多组件，常见的有：</p><ul><li>view相当于div</li><li>text相当于span</li><li>navigator相当于a</li><li>image相当于img</li><li>canvas相当于canvas</li><li>contact-button客户会话，从此处发送的消息，会在微信小程序后台接收到</li></ul><p>小程序中表单form组件不同于浏览器的地方是，无法像浏览器一样通过给表单配置action让页面直接跳转。需要对表单设置submit事件，在submit中获取数据处理跳转逻辑，要获取数据表单项必须要有name属性，这点与浏览器中一致。</p><p>小程序中的button除了像浏览器中一样可以通过form-type属性设置为submit、reset与表单相关的按钮之外。<br>还可以通过设置open-type属性设置为特别的按钮:</p><ul><li>contact(打开客服会话)</li><li>share(触发用户转发)</li><li>getUserInfo(获取用户信息，可以在bindgetuserinfo回调中取到用户信息)</li><li>getPhoneNumber(获取用户手机号，可以从bindgetphonenumber中取得)</li></ul><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><p>小程序中阻止事件冒泡，使用的是catchXX方法(事件还分为冒泡和非冒泡两种)</p><p>没有阻止默认行为的方法</p><p>使用wx.canvasToTempFilePath方法生成图片，如果canvas使用图片进行了绘制，那图片必须是本地图片。而且在微信基础库版本1.5.4下，使用本地图片需要导出两次才能在开发者工具上的canvas看到图片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">wx.downloadFile(&#123;</span><br><span class="line">       url: url,</span><br><span class="line">       success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">         <span class="comment">// console.log('下载图片文件')</span></span><br><span class="line">         <span class="comment">// console.log(res)</span></span><br><span class="line">         ctx.drawImage(res.tempFilePath, left, top, width, height);</span><br><span class="line">         ctx.draw();</span><br><span class="line">         wx.canvasToTempFilePath(&#123;</span><br><span class="line">           canvasId: <span class="string">'photoid'</span>,</span><br><span class="line">           success(res) &#123;</span><br><span class="line">             wx.canvasToTempFilePath(&#123;</span><br><span class="line">               canvasId: <span class="string">'photoid'</span>,</span><br><span class="line">               success(res) &#123;</span><br><span class="line">                 <span class="comment">//...</span></span><br><span class="line">               &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/debug/wxadoc/dev/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微信小程序开发概述&quot;&gt;&lt;a href=&quot;#微信小程序开发概述&quot; class=&quot;headerlink&quot; title=&quot;微信小程序开发概述&quot;&gt;&lt;/a&gt;微信小程序开发概述&lt;/h1&gt;&lt;p&gt;由于微信的使用人数众多，因此微信小程序也受到许多企业公司的推崇。除此之外小程序还有开发简单容易，用户流量较大的优点，因此学习小程序还是很有意义的。&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="http://yeomanye.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="软件" scheme="http://yeomanye.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>客户端存储技术</title>
    <link href="http://yeomanye.github.io/2017/10/15/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/"/>
    <id>http://yeomanye.github.io/2017/10/15/客户端存储技术/</id>
    <published>2017-10-14T16:00:00.000Z</published>
    <updated>2017-12-09T15:40:31.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端存储技术"><a href="#客户端存储技术" class="headerlink" title="客户端存储技术"></a>客户端存储技术</h1><p>介绍浏览器的客户端存储技术，包括：Cookie、Storage、IndexedDB、Application Cache和已经过时但还是很常见的Web SQL，以及一些其他的还未普及的存储技术:Cache Storage、FileSystem API。</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>特点：</p><ul><li>具有大小限制,4~8k</li><li>绑定到域名，对同一个域名的请求会自动带上cookie请求头</li><li>能够给cookie设置有效时间</li></ul><p>cookie使用key=value的形式记录用户信息，多个键值对之间使用;分隔</p><p>前端通过操纵document下的cookie属性直接操纵cookie<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie</span><br><span class="line"><span class="comment">//"irstime=1492081681236; uuid_tt_dd=242117069142"</span></span><br></pre></td></tr></table></figure></p><p>与cookie相关的请求头有两个，一个是Set-Cookie(用在响应中,用于设置cookie和附加信息。一个Set-Cookie可以设置一对或多对键值对),一个是Cookie(用在请求时，表示发送的cookie)</p><p>Set-Cookie格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;name&gt;=&lt;value&gt;[; &lt;name&gt;=&lt;value&gt;]...</span><br><span class="line">       [; expires=&lt;date&gt;][; domain=&lt;domain_name&gt;]</span><br><span class="line">       [; path=&lt;some_path&gt;][; secure][; httponly]</span><br></pre></td></tr></table></figure></p><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><p>Storage分为本地存储（Local Storage）和会话存储（Session Storage）。两者使 用完全相同的API，但本地存储会持久存在（或者直到用户清除），而会话存储只要浏览器 关闭就会消失。存储的键值只能为字符串，storage存储的键值也是和域名相挂钩的。</p><p>API<br>localStorge.setItem:设置特定键值；<br>localStorge.getItem:检索特定的键值；<br>localStorge.removeItem:删除键值及其相关联的值；<br>localStorge.clear:删除所有的键值（只限定于发出请求的特定域名）</p><h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>IndexedDB 数据库使用key-value键值对储存数据，IndexedDB 是事务模式的数据库(任何操作都发生在事务中)，API 基本上是异步的(使用事件模型)。</p><p>IndexedDB是一个基于JavaScript的面向对象的数据库。<br>允许存储和检索用键索引的对象; 可以存储结构化克隆算法支持的任何对象;IndexedDB也遵循同源策略。</p><p>结构化克隆支持的对象：RegExp、Blob、File、Filelist、ImageData、CanvasPixelArray(克隆力度将会跟原始对象相同)、可以正确复制有循环引用的对象。</p><p>不支持的对象:</p><ul><li>Error、Function、DOM节点</li><li>对象的某些特定参数也不会被保留<ul><li>RegExp 对象的 lastIndex 字段不会被保留</li><li>属性描述符，setters 以及 getters（以及其他类似元数据的功能）同样不会被复制。例如，如果一个对象用属性描述符标记为 read-only，它将会被复制为 read-write，因为这是默认的情况下。</li><li>原形链上的属性也不会被追踪以及复制。</li></ul></li></ul><p>初始化数据库<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> localDatabase = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">localDatabase.indexedDB = <span class="built_in">window</span>.indexedDB || <span class="built_in">window</span>.webkitIndexedDB || <span class="built_in">window</span>.mozIndexedDB || <span class="built_in">window</span>.msIndexedDB;</span><br><span class="line">localDatabase.IDBKeyRange = <span class="built_in">window</span>.IDBKeyRange || <span class="built_in">window</span>.webkitIDBKeyRange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DB = <span class="string">"db_user"</span>,VERSION = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打开数据库*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openDB</span>(<span class="params">dbName, version, objStore, columnArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> db = localDatabase.db;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (db) db.close();</span><br><span class="line">        version = version || <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 打开数据库</span></span><br><span class="line">        <span class="keyword">var</span> openRequest = localDatabase.indexedDB.open(dbName, version);</span><br><span class="line">        <span class="comment">// 成功打开数据库</span></span><br><span class="line">        openRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            localDatabase.db = openRequest.result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建或删除存储对象只能在此进行</span></span><br><span class="line">        openRequest.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> db = e.currentTarget.result;</span><br><span class="line">            <span class="keyword">if</span> (!db.objectStoreNames.contains(objStore)) &#123;</span><br><span class="line">                <span class="comment">//创建存储对象并设置主键</span></span><br><span class="line">                <span class="keyword">var</span> store = db.createObjectStore(objStore, &#123;</span><br><span class="line">                    keyPath: <span class="string">"id"</span></span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 创建索引，方便根据字段进行搜索</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = columnArr.length; i &lt; len; i++) &#123;</span><br><span class="line">                    store.createIndex(columnArr[i], columnArr[i], &#123;</span><br><span class="line">                        unique: <span class="literal">false</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"创建存储对象成功"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        openRequest.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.error(e.message);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入和删除数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*添加数据*/</span></span><br><span class="line"><span class="keyword">var</span> request = localDatabase.db.transaction(objStore, <span class="string">"readwrite"</span>).objectStore(objStore).add(obj);</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加成功！</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除数据*/</span></span><br><span class="line"><span class="keyword">var</span> request = db.transaction([<span class="string">"customers"</span>], <span class="string">"readwrite"</span>).objectStore(<span class="string">"customers"</span>).delete(<span class="string">"444-44-4444"</span>);</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 删除数据成功！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用索引获取单个值，使用游标获取多个值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用索引获取单个值*/</span></span><br><span class="line"><span class="keyword">var</span> transaction = db.transaction(objStore),</span><br><span class="line">    store = transaction.objectStore(objStore),</span><br><span class="line">    request = store.get(key);</span><br><span class="line"></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(evt.target.result));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用游标获取多个值 */</span></span><br><span class="line"><span class="keyword">var</span> recordArr = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryAllRecords</span>(<span class="params">objStore</span>) </span>&#123;</span><br><span class="line">    recordArr = [];</span><br><span class="line">    <span class="keyword">var</span> db = localDatabase.db;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> transaction = db.transaction(objStore),</span><br><span class="line">            store = transaction.objectStore(objStore),</span><br><span class="line">            request = store.openCursor();</span><br><span class="line"></span><br><span class="line">        request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cursor = evt.target.result,</span><br><span class="line">                jsonStr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">                <span class="keyword">var</span> records = cursor.value;</span><br><span class="line">                jsonStr = jsonStr + <span class="built_in">JSON</span>.stringify(records);</span><br><span class="line">                <span class="built_in">console</span>.log(jsonStr);</span><br><span class="line">                recordArr.push(records);</span><br><span class="line">                cursor.continue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多IDB代码见:<a href="https://gist.githubusercontent.com/YeomanYe/f526062c431ddb241a5d670aa461cd0b/raw/60836747c6eb25a4a230ef7347dacf2565902f8b/IDB_Util.js" target="_blank" rel="noopener">IDB_Util</a></p><h2 id="Application-Cache"><a href="#Application-Cache" class="headerlink" title="Application Cache"></a>Application Cache</h2><p>Application Cache使用的是一套缓存列表。所谓列表，只是一个非常简单的文本文档，其中列举了所有应该或不应该通过缓存机制处理的资源条目，从而指导浏览器下载特定文件、加以保存并在必要时予以使用——而不必再向服务器发出重复请求。</p><p>要使用Application Cache，我们需要首先在包含有缓存对象文件的网站中保存一个扩展名为.appcache的文本文件。根据所使用Web服务器的具体类型，我们可能需要为.appcache文件创建一个自定义MIME类型以确保它们能够正确作用于浏览器并可被作为应用程序缓存文件读取。</p><p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 以上折行必需要写</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line"># 这部分写需要缓存的资源文件列表</span><br><span class="line"># 可以是相对路径也可以是绝对路径</span><br><span class="line">index.html</span><br><span class="line">index.css</span><br><span class="line">images/logo.png</span><br><span class="line">js/main.js</span><br><span class="line">http://img.baidu.com/js/tangram-base-1.5.2.1.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line"># 可选</span><br><span class="line"># 这一部分是要绕过缓存直接读取的文件</span><br><span class="line">login.php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line"># 可选</span><br><span class="line"># 这部分写当访问缓存失败后，备用访问的资源</span><br><span class="line"># 每行两个文件，第一个是访问源，第二个是替换文件*.html /offline.html</span><br></pre></td></tr></table></figure></p><p>html文件中的设置<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"demo.cache"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>apache服务器中，定义<br><code>tAddType text/cache-manifest .cache</code></p><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>更新manifest文件<br>　　浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。<br>　　当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。</p><p>使用js的方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> appCache = <span class="built_in">window</span>.applicationCache;</span><br><span class="line"></span><br><span class="line">appCache.update(); <span class="comment">//尝试更新缓存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (appCache.status == <span class="built_in">window</span>.applicationCache.UPDATEREADY) &#123;</span><br><span class="line">  appCache.swapCache();  <span class="comment">//更新成功后，切换到新的缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Web-SQL"><a href="#Web-SQL" class="headerlink" title="Web SQL"></a>Web SQL</h3><p>web sql的规范工作已经被W3C停止，按照官方的说法是web sql后台使用的都是SQLite，但为了实现规范前台会有许多不同的实现。因此规范被停止。但是仍然有许多老系统、插件使用web sql，因此学习web sql对我们还是有着不小的好处。</p><p>Web SQL Database 规范中定义了三个核心方法：</p><ul><li>openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象</li><li>transaction：这个方法允许我们根据情况控制事务提交或回滚</li><li>executeSql：这个方法用于执行SQL 查询</li></ul><p>openDatabase<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(dbName, dbVersion, showName, size,callback);</span><br><span class="line"></span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    context.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS testTable (id unique, name)'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable (id, name) VALUES (0, "Byron")'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable (id, name) VALUES (1, "Casper")'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable (id, name) VALUES (2, "Frank")'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'SELECT * FROM testTable where id=? and name=?'</span>, [<span class="number">2</span>, <span class="string">'Frank'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">context, results</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> len = results.rows.length, i;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Got '</span> + len + <span class="string">' rows.'</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'id: '</span> + results.rows.item(i).id);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'name: '</span> + results.rows.item(i).name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, errorCallback);</span><br><span class="line">&#125;, successCallback, errorCallback);</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Cache-Storage"><a href="#Cache-Storage" class="headerlink" title="Cache Storage"></a>Cache Storage</h3><p>Cache Storage用来存储 Response 对象的。也就是说用来对 HTTP ，响应做缓存的。CacheStorage 在浏览器上的引用名叫 caches ，它定义在 ServiceWorker 的规范中。CacheStorage 是多个 Cache 的集合，而每个 Cache 可以存储多个 Response 对象。CacheStorage的设计风格也和ServiceWork一样都基于Promise。</p><ul><li>match() 返回promise,resolve为response对象，如果在任意一个cache中找到与key对应的响应对象</li><li>has() 返回promise对象,resolve为boolean，根据是否含有记录，得到不同的值</li><li>open() 返回promise，resolve为cache，如果不存在对应的cache，则新建一个</li><li>delete() 返回promise,resolve为boolean,如果删除cache成功则为true</li><li>keys() 返回promise,resolve为cache数组</li></ul><h4 id="使用cache-storage与service-worker建立离线应用"><a href="#使用cache-storage与service-worker建立离线应用" class="headerlink" title="使用cache storage与service worker建立离线应用"></a>使用cache storage与service worker建立离线应用</h4><p>在页面脚本中添加如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个serviceWorker</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./sw-demo-cache.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在sw-demo-cache.js中添加如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw-demo-cache.js</span></span><br><span class="line"><span class="keyword">var</span> VERSION = <span class="string">'v1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(VERSION).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//需要做缓存的文件</span></span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'./start.html'</span>,</span><br><span class="line">        <span class="string">'./static/jquery.min.js'</span>,</span><br><span class="line">        <span class="string">'./static/mm1.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存更新</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 如果当前版本和缓存版本不一致</span></span><br><span class="line">          <span class="keyword">if</span> (cacheName !== VERSION) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获请求并返回缓存数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    caches.open(VERSION).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      cache.put(event.request, response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> response.clone();</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//没法从缓存和请求中得到资源时的处理办法</span></span><br><span class="line">    <span class="keyword">return</span> caches.match(<span class="string">'./static/mm1.jpg'</span>);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="FileSystem-API"><a href="#FileSystem-API" class="headerlink" title="FileSystem API"></a>FileSystem API</h3><p>使用 FileSystem API，网络应用就可以创建、读取、导航用户本地文件系统中的沙盒部分以及向其中写入数据。但是目前FileSystem API并不普及，支持的只有chrome浏览器。FileSystem API提供了文件系统的管理、文件/目录的管理、文件的管理等API。刚兴趣的朋友可以阅读<a href="http://blog.csdn.net/u011069813/article/details/20306403#toc-file-writing" target="_blank" rel="noopener">探索FileSystem API</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB#使用索引" target="_blank" rel="noopener">使用IndexedDB</a><br><a href="http://www.cnblogs.com/blackbird/archive/2012/06/12/2546751.html" target="_blank" rel="noopener">application cache api</a><br><a href="http://www.cnblogs.com/dolphinX/p/3405335.html" target="_blank" rel="noopener">Web SQL Database</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener">CacheStorage 缓存存储</a><br><a href="http://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/" target="_blank" rel="noopener">借助Service Worker和cacheStorage缓存及离线开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;客户端存储技术&quot;&gt;&lt;a href=&quot;#客户端存储技术&quot; class=&quot;headerlink&quot; title=&quot;客户端存储技术&quot;&gt;&lt;/a&gt;客户端存储技术&lt;/h1&gt;&lt;p&gt;介绍浏览器的客户端存储技术，包括：Cookie、Storage、IndexedDB、Application Cache和已经过时但还是很常见的Web SQL，以及一些其他的还未普及的存储技术:Cache Storage、FileSystem API。&lt;/p&gt;
    
    </summary>
    
      <category term="存储" scheme="http://yeomanye.github.io/categories/%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="JavaScript" scheme="http://yeomanye.github.io/tags/JavaScript/"/>
    
      <category term="存储" scheme="http://yeomanye.github.io/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
