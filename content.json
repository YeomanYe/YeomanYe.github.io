[{"title":"计算机程序的思维逻辑-类","date":"2017-03-21T08:24:35.790Z","path":"2017/03/21/计算机程序的思维逻辑-类/","text":"计算机思维逻辑-类计算机程序的思维逻辑是“老马”的系列文章,文章通过Java语言来介绍计算机技术的本质。第二章节类,介绍了关键字的注意点，继承与多态的概念，类与实例加载细节，继承的破坏性，接口与抽象类，内部类，代码的组织机制，枚举的本质，异常等内容。原文目录(13-25章) 关键字final关键字的作用: 使得变量值无法被修改 使得实例变量、实例方法、类不能被继承 protected:可被继承,在包路径下可进行访问 super和this是不同的，this引用一个对象，是实实在在存在的，可以作为函数参数，可以作为返回值，但super只是一个关键字，不能作为参数和返回值，它只是用于告诉编译器访问父类的相关变量和方法。 定义了带参的构造方法，默认不带参数的构造方法就没有了。 创建对象,默认调用父类的默认的构造方法。 继承与多态多态，即一种类型的变量，可引用多种实际类型对象。变量(父类)就是静态类型,引用(子类)就是动态类型。静态类型调用动态类型的方法(子类的方法)称为动态绑定。 如果父类没有默认无参构造方法,子类构造函数必须调用父类的一个带参数构造方法,否则会出现错误。 除了调用实例的public方法会造成动态绑定(即静态类型调用动态类型的方法)。使用实例变量、静态变量、静态方法、private方法都是静态绑定的 当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的，换句话说，寻找在所有重载版本中最匹配的，然后才看变量的动态类型，进行动态绑定。 类与实例加载细节类加载过程包括(执行初始化代码先父类后子类): 分配内存保存类的信息 给类变量赋默认值 加载父类 设置父子关系 执行初始化代码(定义静态变量时的赋值语句、静态初始化代码块) 实例创建过程包括(执行实例初始化也是先执行父类后执行子类的): 分配内存 对所有实例变量赋默认值 执行实例初始化代码(定义实例常量时的赋值语句、实例初始化代码块、构造方法) 栈中存放函数的局部变量、入口地址和对象、数组的地址等,堆存放动态分配的对象,方法区存放类信息。 虚方法表优化调用效率所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。 接口与抽象类接口中的函数都为public类型,接口中的变量都为public static final类型,可用instanceof判断对象是否实现了相应接口。 抽象类和接口是配合而非替代关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法。便于子类对方法的复写。 内部类每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件 内部类的种类:静态内部类、成员内部类、方法内部类、匿名内部类 静态内部类拥有:静态变量、静态方法、成员方法、成员变量、构造方法等访问权限:能访问静态变量和方法,不能访问实例变量和方法Tips:内部类若访问外部私有变量,JVM通过给外部类生成一个方法返回私有变量 成员内部类拥有:实例变量和实例方法,不能有静态变量和方法(final变量例外)访问权限:能访问静态变量和方法，实例变量和方法(当内部类与外部类变量、方法重名时,使用”外部类.this.xxx”的方式引用外部类的实例变量或方法) 方法内部类拥有:实例变量和实例方法,不能有静态变量和方法(final变量例外)访问权限:定义在静态方法中,能访问静态变量和静态函数;定义在实例方法中,都可以访问(能够访问方法变量,方法参数需要声明为final) 匿名内部类拥有:实例变量和实例方法,不能有静态变量和方法(final变量例外)访问权限:匿名内部类可以访问外部类的所有变量和方法，可以访问方法中的final参数和局部变量 代码的组织机制生成jar包命令jar -cvf packageName.jar dir (dir:为包的最上级目录) 编译时使用classpath参数确定用到的类路径 jar包:路径名+包名 class文件:class文件的根目录 import是编译时概念，用于确定完全限定名，在运行时，只根据完全限定名寻找并加载类。 包的组织:供外部使用的类可以放在包的上层，而内部的实现细节则可以放在比较底层的子包内。 枚举的本质枚举的使用语法: 1234567891011121314151617181920212223242526//定义public enum Size&#123; SMALL,MEDIUM,LARGE&#125;Size size = size.MEDIUM;size.name();//MEDIUM,等价于size.toString();//比较size == Size.MEDIUM;//truesize.equals(Size.MEDIUM);//truesize.compareTo(Size.MEDIUM);//0,实际比较的是ordinal的大小//顺序size.ordinal();//可以使用switch语句switch(size)&#123; /*不能使用Size.SMALL*/ case SMALL: System.out.println(\"chosen small\"); break; case MEDIUM: System.out.println(\"chosen medium\"); break; case LARGE: System.out.println(\"chosen large\"); break; &#125; 枚举的实现原理:123456789101112131415161718192021222324public final class Size extends Enum&lt;Size&gt; &#123; //枚举常量被转换为相应的静态成员。 public static final Size SMALL = new Size(\"SMALL\",0); public static final Size MEDIUM = new Size(\"MEDIUM\",1); public static final Size LARGE = new Size(\"LARGE\",2); private static Size[] VALUES = new Size[]&#123;SMALL,MEDIUM,LARGE&#125;; private Size(String name, int ordinal)&#123; super(name, ordinal); &#125; public static Size[] values()&#123; Size[] values = new Size[VALUES.length]; System.arraycopy(VALUES, 0, values, 0, VALUES.length); return values; &#125; public static Size valueOf(String name)&#123; return Enum.valueOf(Size.class, name); &#125;&#125; 一般枚举变量会被转换为对应的类变量，在switch语句中，枚举值会被转换为其对应的ordinal值(该值会随位置改变而改变)。 枚举类型本质上也是类，但由于编译器自动做了很多事情，它的使用也就更为简洁、安全和方便。 异常Throwable是所有异常的基类,它有两个子类Error和Exception Error:表示系统错误或资源耗尽,由Java系统自己使用,应用程序不应抛出和处理 Exception:表示应用程序错误,有三个直接子类:IOException(输入输出I/O异常),SQLException(数据库SQL异常),RuntimeException(运行时异常,含义unchecked exception异常;Error及其子类也是unchecked exception) 对于checked异常(表示不可预知的错误产生的异常)，Java会强制要求程序员进行处理，否则会有编译错误，而对于unchecked异常(编程的逻辑错误)则没有这个要求。 异常是相对于return的一种退出机制，可以由系统触发(NullPointerException)，也可以由程序通过throw语句触发，异常可以通过try/catch语句进行捕获并处理，如果没有捕获，则会导致程序退出并输出异常栈信息。异常有不同的类型。 finally: 123456789//finally内改变了返回值,但返回值仍然是0public static int test()&#123; int ret = 0; try&#123; return ret; &#125;finally&#123; ret = 2; &#125;&#125; 在执行到try内的return ret;语句前，会先将返回值ret保存在一个临时变量中，然后才执行finally语句，最后try再返回那个临时变量，finally中对ret的修改不会被返回 12345678//返回5，不抛出异常public static void test()&#123; try&#123; int a = 5/0; &#125;finally&#123; return 5; &#125;&#125; 如果finally中有return/throw,不仅会覆盖try-catch中的return还会覆盖其中产生的异常 异常的来源与处理 用户:用户输入产生的问题,对策:使用输入检查与提示的方法。 程序员:编程上的错误,对策:尽量报告完整的细节,包括异常链、异常栈等 第三方:I/O,网络,数据库,第三方服务等,对策同上","tags":[{"name":"文章总结","slug":"文章总结","permalink":"http://yoursite.com/tags/文章总结/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"计算机程序的思维逻辑-基础知识","date":"2017-03-21T07:20:16.386Z","path":"2017/03/21/计算机程序的思维逻辑-基础知识/","text":"计算机思维逻辑-基础知识计算机程序的思维逻辑是“老马”的系列文章,文章通过Java语言来介绍计算机技术的本质。第一章节基础知识,介绍了运算符的注意点,浮点数为什么无法精确表示，编码的发展过程和特性，机器码如何表示语句块，函数、对象在内存中的表示。原文目录(1-12章) 类型与运算符浮点类型只能精确表示,2^-n的和,因为计算机是用二进制数表示十进制数 | &amp; 在逻辑运算中,无论前一个式子运算结果如何后一个都会进行运算 算术运算根据参与的数据的最大范围进行运算(并不是根据结果),如:123456int i=5;float j;//先进行整数运算,再换算成浮点数。j = i/2;//结果为2.0System.out.println(j); 编码西文编码ASCII码 (表示128个字符,一个字节一个字符,最高位0)ISO 8859-1 与 Windows-1252(前128位ASCII码相同,128-159各有不同);Windows1252的更常用(表示的是可以打印的字符)，因而取代了ISO 8859-1 中文编码GB2312:大约7000简体字 (两个字节表示一个汉字,汉字字节最高位都为1;最高位为0表示ASCII码)GBK:建立在GB2312上,大约(2100个汉字，含繁体字;汉字仍用两个字节表示,第二个字节最高位可为0)GB18030:在GBK基础上建立 (汉字可为2个或4个编码;通过解析第二个字节,若在0x30到0x39之间就为4字节编码)Big5:繁体中文编码 (两个字节表示汉字) UnicodeUnicode只规定了所有字符的编号;UTF-8,UTF-16,UTF-32实现了其二进制表示。UTF-32:以四个字节表示一个字符(根据编号的最高位在第一个字节(BE,Big Endian)大端,在最后一个字节(LE,Little Endian)小端)UTF-16:编号在两个字节内的用两个字节表示，无法两个字节表示的用四个字节表示。也分大小端UTF-8:编号大的字节就多,编号小的字节就少 语句块使用if/else if应该小心后面条件不应包括前面条件 if语句转换为条件跳转、无条件跳转(大量if else也会被优化为跳转表),switch转换为更高效的跳转表 函数中的参数和函数内定义的变量，都分配在栈中，这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。递归函数的执行过程，函数代码虽然只有一份，但在执行的过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址。 对于数组和对象类型，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆（也是内存的一部分，后续文章介绍）中，但存放地址的空间是分配在栈上的。","tags":[{"name":"文章总结","slug":"文章总结","permalink":"http://yoursite.com/tags/文章总结/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"基础知识","slug":"基础知识","permalink":"http://yoursite.com/tags/基础知识/"}]},{"title":"Oracle特殊点总结","date":"2017-03-21T03:13:45.491Z","path":"2017/03/21/Oracle特殊点/","text":"Oracle特殊点记录了Oracle与其他数据库的一些不同之处，包括分页查询、信息查看、创建自增序列、添加索引等。 分页查询使用rownum进行分页查询1234567891011# 查询某个数量以下时select s.uuid,rownum from table_name s where rownum &lt; 22;# 分页查询select * from ( select t.*, rownum RN from TABLE_NAME t ) where RN &gt; 0 and RN &lt;= 15;select * from ( select t.*, rownum RN from TABLE_NAME t ) where RN between 1 and 15;# 如果需要配需，应该在嵌套一层排序爹子查询select * from (select a.*,rownum row_num from (select * from mytable t order by t.id desc) a ) b where b.row_num between 1 and 10 查询信息123456# 查询所有表select table_name from user_tables;# 显示表的字段desc table_name;# 查看当前用户默认表空间select username,default_tablespace from user_users; 创建自增序列创建一个测试表: 1234567create table userlogin( id number(6) not null primary key, name varchar2(30) not null,); 创建一个sequence12# 创建一个sequencecreate sequence userlogin_seq increment by 1 start with 1 minvalue 1 maxvalue 9999999999999 nocache order; 创建一个触发器，用于在插入时自动追加序号12345678create or replace trigger userlogin_trigger before insert on userloginfor each row begin select userlogin_seq.nextval into:new.id from sys.dual ; end;/ 这样在插入时就能自动生成自增的主键 添加索引12# 添加索引，多个字段用,隔开CREATE INDEX index_name ON table_name(col1,col2);","tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"随机抽查管理系统分析","date":"2017-03-17T07:03:19.170Z","path":"2017/03/17/随机抽查管理系统分析/","text":"随机抽查系统分析项目功能: 备查项目管理、执法人员管理(对数据的增、删、改、查、Excel的导入) 根据抽取条件(人员数、项目数等),随机分配人员对项目进行抽查 权限管理，使用的是用户关联角色的模式。 框架使用: 前端:easyui,jquery, 后端:spring,spring mvc,mybatis 值得注意的地方使用了插件进行分页使用了第三方的Mybatis的插件(PageHelper)进行分页的操作mybatis根标签下: 123456789101112131415161718192021222324252627282930&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt; &lt;!-- 4.0.0以后版本可以不设置该参数 --&gt; &lt;property name=\"dialect\" value=\"oracle\"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt; &lt;!-- 和startPage中的pageNum效果一样--&gt; &lt;property name=\"offsetAsPageNum\" value=\"true\"/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt; &lt;property name=\"rowBoundsWithCount\" value=\"true\"/&gt; &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt; &lt;property name=\"pageSizeZero\" value=\"true\"/&gt; &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt; &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt; &lt;property name=\"reasonable\" value=\"true\"/&gt; &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt; &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,orderBy,不配置映射的用默认值 --&gt; &lt;!-- 不理解该含义的前提下，不要随便复制该配置 --&gt; &lt;property name=\"params\" value=\"pageNum=start;pageSize=limit;\"/&gt; &lt;!-- 支持通过Mapper接口参数来传递分页参数 --&gt; &lt;property name=\"supportMethodsArguments\" value=\"true\"/&gt; &lt;!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page --&gt; &lt;property name=\"returnPageInfo\" value=\"check\"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 后端调用:12345678910111213//设置当前页面以及分页大小,这个方法后的第一个查询方法会被分页PageHelper.startPage(currentPage, pageSize);//执行dao方法获取结果集List&lt;Student&gt; student = dao.selectStudent();/** * 如果只需要分页查询，那么上面的两行代码就够了 *///将执行结果注入到PageInfo中,可以从该对象获取分页相关的信息和当前页面的内容PageInfo&lt;Student&gt; studentListPage = new PageInfo&lt;Student&gt;(student);//本次查询总条数studentListPage.getTotal();//本次查询的结果studentListPage.getList(); 除了项目中使用的方式外的其他几种重要的使用方式:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//第一种，RowBounds方式的调用List&lt;Country&gt; list = sqlSession.selectList(\"x.y.selectIf\", null, new RowBounds(0, 10));//第二种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第三种，Mapper接口方式的调用，推荐这种使用方式。PageHelper.offsetPage(1, 10);List&lt;Country&gt; list = countryMapper.selectIf(1);//第四种，参数方法调用//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize( @Param(\"user\") User user, @Param(\"pageNum\") int pageNum, @Param(\"pageSize\") int pageSize);&#125;//配置supportMethodsArguments=true//在代码中直接调用：List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, 1, 10);//第五种，参数对象//如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页//有如下 User 对象public class User &#123; //其他fields //下面两个参数名和 params 配置的名字一致 private Integer pageNum; private Integer pageSize;&#125;//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数public interface CountryMapper &#123; List&lt;Country&gt; selectByPageNumSize(User user);&#125;//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user);//第六种，ISelect 接口方式//jdk6,7用法，创建接口Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//jdk8 lambda用法Page&lt;Country&gt; page = PageHelper.startPage(1, 10).doSelectPage(()-&gt; countryMapper.selectGroupBy());//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPagepageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectGroupBy(); &#125;&#125;);//对应的lambda用法pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());//count查询，返回一个查询语句的count数long total = PageHelper.count(new ISelect() &#123; @Override public void doSelect() &#123; countryMapper.selectLike(country); &#125;&#125;);//lambdatotal = PageHelper.count(()-&gt;countryMapper.selectLike(country)); Mybatis插件的编写:12345678910111213141516171819@Intercepts(&#123;@Signature( type= Executor.class,//拦截的时机 method = \"update\",//拦截的方法 //方法的参数 args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; //拦截后具体执行什么 public Object intercept(Invocation invocation) throws Throwable &#123; //最后一个语句一定的是这个，否则拦截器链就断了 return invocation.proceed(); &#125; //将目标对象包装到拦截器中，生成一个代理对象 public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; //设置属性 public void setProperties(Properties properties) &#123; &#125;&#125; 参考文档：官方说明插件原理 使用了MyBatis GeneratorMBG(MyBatis Generator)一个通过读取配置文件并根据数据库中对应的表生成实体类、以及映射文件、对应DAO层的工具。(该系统中只是简单测试了下这个生成器的功能)配置文件: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location=\"ojdbc6.jar\"/&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是： false:否 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\" connectionURL=\"jdbc:oracle:thin:@localhost:1521:orcl\" userId=\"ots\" password=\"ots\"&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=\"po\" targetProject=\".\\src\"&gt; &lt;!--enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=\"trimStrings\" value=\"true\"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=\"map\" targetProject=\".\\src\"&gt; &lt;!--enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"dao\" targetProject=\".\\src\"&gt; &lt;!--enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName=\"Subject\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 使用java生成:12345678List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();boolean overwrite = true;File configFile = new File(\"generatorConfig.xml\");ConfigurationParser cp = new ConfigurationParser(warnings);Configuration config = cp.parseConfiguration(configFile);DefaultShellCallback callback = new DefaultShellCallback(overwrite);MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);myBatisGenerator.generate(null); 使用命令行生成java -jar mybatis-generator-core-1.3.2.jar -configfile generatorConfig.xml -overwrite,需要将对应的jar包、驱动jar包、配置文件放在当前目录下并且保证targetProject存在。 生成的文件包括:Subject.java,SubjectExample.java(用于设置条件),SubjectMapper.xml(映射文件),SubjectMapper.java(接口，即Dao层) 12345678910111213141516171819202122232425262728public interface SubjectMapper &#123; int countByExample(SubjectExample example); int deleteByExample(SubjectExample example); int deleteByPrimaryKey(String uuid); int insert(Subject record); /** * 可选插入,record中不为空的字段将插入 * xml中使用if标签配置 */ int insertSelective(Subject record); /** * 根据条件进行查询 */ List&lt;Subject&gt; selectByExample(SubjectExample example); Subject selectByPrimaryKey(String uuid); int updateByExampleSelective(@Param(\"record\") Subject record, @Param(\"example\") SubjectExample example); int updateByExample(@Param(\"record\") Subject record, @Param(\"example\") SubjectExample example); int updateByPrimaryKeySelective(Subject record); int updateByPrimaryKey(Subject record);&#125; 条件配置示例:123456789101112131415161718192021TestTableExample example = new TestTableExample(); example.or() .andField1EqualTo(5) .andField2IsNull(); example.or() .andField3NotEqualTo(9) .andField4IsNotNull(); List&lt;Integer&gt; field5Values = new ArrayList&lt;Integer&gt;(); field5Values.add(8); field5Values.add(11); field5Values.add(14); field5Values.add(22); example.or() .andField5In(field5Values); example.or() .andField6Between(3, 7); 对应的sql条件为:1234where (field1 = 5 and field2 is null) or (field3 &lt;&gt; 9 and field4 is not null) or (field5 in (8, 11, 14, 22)) or (field6 between 3 and 7) 实现机制:Example内部具有三个类(GeneratedCriteria(抽像类，表示条件的集合，条件间使用or相隔开)、Criteria(抽线类的实现类)、Criterion(表示条件,包括条件的关键字等等)),xml获取example的oredCriteria(Criteria的集合),迭代条件每个条件用or相连接。 参考文档：快速起步MBG运行Example类的使用 觉得不好的地方控制层含有业务操作控制层应该只进行逻辑判定、参数传递的操作，不应该有业务层的代码。 对功能不理解比如对mybatis分页插件pagehelper使用不理解，造成许多冗余的代码。 1234567891011121314151617PageHelper.startPage(currentPage, pageSize);marshalsList = marshalsDao.selectMarshalsLike(marshals);PageInfo&lt;Marshals&gt; marshalsListPage = new PageInfo&lt;Marshals&gt;(marshalsList);Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();Iterator&lt;Marshals&gt; datas = marshalsListPage.getList().iterator();List&lt;Marshals&gt; marshalsDatas = new ArrayList&lt;&gt;();while (datas.hasNext()) &#123; marshalsDatas.add(datas.next());&#125;data.put(\"rows\", marshalsDatas);data.put(\"total\", marshalsListPage.getTotal());//因为前端使用的是easyui的数据表格，后端只需要返回一个json,//rows为数组对象,total为页面大小,所以只需要分页查询就够了PageHelper.startPage(currentPage, pageSize);marshalsList = marshalsDao.selectMarshalsLike(marshals);data.put(\"rows\", marshalsList);data.put(\"total\", marshalsList.size());","tags":[{"name":"系统分析","slug":"系统分析","permalink":"http://yoursite.com/tags/系统分析/"}]},{"title":"WebService","date":"2017-03-10T03:10:06.556Z","path":"2017/03/10/WebService学习/","text":"WebService学习WebService(jax-ws)三要素 SOAP: 基于HTTP协议，采用XML格式，用来传递信息的格式。 WSDL: 用来描述如何访问具体的服务。 UDDI: 用户自己可以按UDDI标准搭建UDDI服务器，用来管理，分发，查询WebService 。其他用户可以自己注册发布WebService调用。 SOAP(通讯协议)Simple Object Accrss Protocol，简单对象访问协议是在分散或分布式的环境中交换信息的简单的协议，是一个基于XML的协议，它包括四个部分:1 SOAP封装(envelop)，封装定义了一个描述消息中的内容是什么，是谁发送的，谁应当接受并处理它，以及如何处理它们的框架;2 SOAP编码规则，用于表示应用程序需要使用的数据类型的实例。3 SOAP RPC 表示远程过程调用和应答的协定。4 SOAP绑定(binding)，使用底层协议交换信息。 请求的协议体12345678910111213141516POST /weather HTTP/1.1Accept: text/xml, multipart/relatedContent-Type: text/xml; charset=utf-8SOAPAction: \"http://weather.itheima.com/WeatherInterface/getWeatherByCityNameRequest\"User-Agent: JAX-WS RI 2.2.4-b01Host: 127.0.0.1:54321Connection: keep-aliveContent-Length: 235&lt;?xml version=\"1.0\" ?&gt;&lt;S:Envelope xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;S:Body&gt; &lt;ns2:getWeatherByCityName xmlns:ns2=\"http://weather.itheima.com\"&gt; &lt;cityName&gt;北京&lt;/cityName&gt; &lt;/ns2:getWeatherByCityName&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt; 响应的协议体123456789101112HTTP/1.1 200 OKTransfer-encoding: chunkedContent-type: text/xml; charset=utf-8Date: Fri, 09 Oct 2015 07:23:29 GMT&lt;?xml version=\"1.0\" ?&gt;&lt;S:Envelope xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;S:Body&gt; &lt;ns2:getWeatherByCityNameResponse xmlns:ns2=\"http://weather.itheima.com\"&gt; &lt;WeatherInfo&gt;今天风很大&lt;/WeatherInfo&gt; &lt;/ns2:getWeatherByCityNameResponse&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt; WSDLWSDL(Web Service Description Language)，是一个用来描述Web服务（Web Service）和说明如何与Web服务通信的XML语言。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。 WSDL阅读方法是从下往上读。每个wsdl有且只有一个Service节点。1、先找Service节点2、Service节点中找port节点。每个port对应一个PortType。3、Port节点对应一binding节点。每个binding节点对应一个PortType4、PortType中有operation 节点就是服务的方法。5、operation 中有Input（参数）和output（返回值）6、Input（参数）和output（返回值）对应message节点7、Message对应element节点(定义在XSD中)。Element节点对应complexType节点描述了参数及返回值的数据类型。 使用注解规范@WebService: 定义服务，在public class上边。 targetNamespace:指定命名空间。 name:portType的名称。 portName:port的名称。serviceName:服务名称。@WebResult:定义返回值。 name:返回结果值的名称。@WebParam:定义参数。 name:指定参数的名称。@WebMethod exclude:排除指定的方法。 XSDXML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，还是64位？这些细节对实现互操作性都是很重要的。W3C制定的XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。Web service平台就是用XSD来作为其数据类型系统的。 UUDIUDDI 是一种目录服务，通过它，企业可注册并搜索 Web services。企业将自己提供的Web Service注册在UDDI，也可以使用别的企业在UDDI注册的web service服务，从而达到资源共享。 UDDI旨在将全球的webservcie资源进行共享，促进全球经济合作。 但是使用webservice并不是必须使用UDDI，因为用户通过WSDL知道了web service的地址，可以直接通过WSDL调用webservice。 使用实例服务端:12345678910111213141516171819public interface WeatherInterface &#123; public String getWeatherByCity(String city);&#125;@WebServicepublic class WeatherInterfaceImpl implements WeatherInterface &#123; @Override public String getWeatherByCity(String city) &#123; String result = \",天气寒冷\"; return city + result; &#125;&#125;public class WeatherServer &#123; public static void main(String[] args)&#123; Endpoint.publish(\"http://localhost:12345/weather\", new WeatherInterfaceImpl()); &#125;&#125; 服务端启动后进入客户端工程相应的目录下使用wsimport -s . http://localhost:12345/weather?wsdl生成代码12345678public class WeatherClient &#123; public static void main(String[] args)&#123; WeatherInterfaceImplService service = new WeatherInterfaceImplService(); WeatherInterfaceImpl portType = service.getWeatherInterfaceImplPort(); String result = portType.getWeatherByCity(\"北京\"); System.out.println(result); &#125;&#125; Apache CXFApache CXF是一个开源的Web Services框架: 支持多种协议:SOAP1.1,1,2 XML/HTTP、RESTful 或者CORBA 部署灵活:可以运行在Tomcat,Jboss,Jetty(内置),weblogic上面。 可嵌入的Web服务组件：例如可以嵌入到Spring Framework和Geronimo中。 高性能,最小的计算开销。 服务器端实体类:1234567public class Weather &#123; private int minTemp; private int maxTemp; private String info; private Date date; &#125; 服务接口与实现:12345678910111213141516171819202122232425262728@WebServicepublic interface WeatherInterface &#123; public List&lt;Weather&gt; getWeatherByCity(String city);&#125;public class WeatherInterfaceImpl implements WeatherInterface&#123; public List&lt;Weather&gt; getWeatherByCity(String city) &#123; return getWeatherInfo(city); &#125; private List&lt;Weather&gt; getWeatherInfo(String city)&#123; List&lt;Weather&gt; weathers = new ArrayList&lt;&gt;(); Calendar c = Calendar.getInstance(); Date d1 = c.getTime(); c.set(Calendar.DATE, c.get(Calendar.DATE) + 1); Date d2 = c.getTime(); c.set(Calendar.DATE, c.get(Calendar.DATE) + 2); Date d3 = c.getTime(); c.set(Calendar.DATE, c.get(Calendar.DATE) + 3); weathers.add(new Weather(30,20,city+\":今天很热\",d1)); weathers.add(new Weather(31,21,city+\":今天很热\",d2)); weathers.add(new Weather(32,22,city+\":今天很热\",d3)); return weathers; &#125; &#125; 服务启动:1234567891011121314public class WeatherService &#123; public static void main(String[] args)&#123; //创建JaxWsClientFactoryBean JaxWsServerFactoryBean factoryBean = new JaxWsServerFactoryBean(); //设置SEI接口 factoryBean.setServiceClass(WeatherInterface.class); //设置SEI实现类对象 factoryBean.setServiceBean(new WeatherInterfaceImpl()); //设置服务发布地址 factoryBean.setAddress(\"http://localhost:12345/weather\"); //发布服务 factoryBean.create(); &#125;&#125; 客户端先使用Apache CXF的wsdl2java -d . http://localhost:12345/weather?wsdl生成客户端代码:1234567891011121314151617public class CXFClient &#123; public static void main(String[] args)&#123; //创建一个JaxWsProxyFactoryBean JaxWsProxyFactoryBean factoryBean = new JaxWsProxyFactoryBean(); //设置portType的class factoryBean.setServiceClass(WeatherInterface.class); //设置地址 factoryBean.setAddress(\"http://localhost:12345/weather?wsdl\"); //调用create方法生成portType对象 WeatherInterface portType = (WeatherInterface) factoryBean.create(); //调用服务端方法 List&lt;Weather&gt; weathers = portType.getWeatherByCity(\"北京\"); for(Weather w:weathers)&#123; System.out.println(w); &#125; &#125;&#125; 参考链接WebService基础学习","tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/后端/"}]},{"title":"dojo","date":"2017-03-07T03:52:03.920Z","path":"2017/03/07/dojo起步/","text":"dojo起步简介dojo是前端js的一个框架,支持js异步加载机制,对js的语句进行了优化，还提供打包工具可以优化JS代码，还提供了所有的UI组件，支持IE6以上的浏览器。dojo解决了企业级开发中大量加载JS导致的浏览器崩溃问题。 Getting StartedHello Dojo模块的使用1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Tutorial: Hello Dojo!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"greeting\"&gt;Hello&lt;/h1&gt; &lt;!-- load Dojo --&gt; &lt;!-- 此处只是加载dojo的异步加载模块,包括require,define两个全局函数 --&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\" data-dojo-config=\"async: true\"&gt;&lt;/script&gt; &lt;script&gt; require([ &lt;!-- dom操作相关的模块 --&gt; 'dojo/dom', 'dojo/dom-construct' &lt;!-- 异步加载模块，使用回调函数的机制 --&gt; ], function (dom, domConstruct) &#123; var greetingNode = dom.byId('greeting'); domConstruct.place('&lt;em&gt; Dojo!&lt;/em&gt;', greetingNode); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模块的定义(参考路径是dojo的根目录)1234567891011121314151617181920define([ 'dojo/dom'], function(dom)&#123; var oldText = &#123;&#125;; return &#123; setText: function (id, text) &#123; var node = dom.byId(id); oldText[id] = node.innerHTML; node.innerHTML = text; &#125;, restoreText: function (id) &#123; var node = dom.byId(id); node.innerHTML = oldText[id]; delete oldText[id]; &#125; &#125;;&#125;); 组合使用CDN模块与自定义模块1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Tutorial: Hello Dojo!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"greeting\"&gt;Hello&lt;/h1&gt; &lt;!-- configure Dojo --&gt; &lt;script&gt; var dojoConfig = &#123; async: true, //配置自定义的路径 packages: [&#123; name: \"demo\", location: location.pathname.replace(/\\/[^/]*$/, '') + '/demo' &#125;] &#125;; &lt;/script&gt; &lt;!-- load Dojo --&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\"&gt;&lt;/script&gt; &lt;script&gt; require([ 'demo/myModule' ], function (myModule) &#123; myModule.setText('greeting', 'Hello Dojo!'); setTimeout(function () &#123; myModule.restoreText('greeting'); &#125;, 3000); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 等待DOM加载123456789require([ 'dojo/dom', //domReady为插件,通过模块标识符后带\"!\"来激活， //dom加载完毕才执行回调。 'dojo/domReady!'], function (dom) &#123; var greeting = dom.byId('greeting'); greeting.innerHTML += ' from Dojo!';&#125;); 使用dojoConfig配置dojodojoConfig相当于将配置发送到服务器上，服务器接收参数后定制模块。配置参数是在dojo/_base/config下。dojoConfig必须写在require前。dojoConfig两种配置方式: 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 一:使用全局变量dojoConfig --&gt;&lt;!-- set Dojo configuration, load Dojo --&gt;&lt;script&gt; dojoConfig= &#123; has: &#123; \"dojo-firebug\": true &#125;, parseOnLoad: false, foo: \"bar\", async: true &#125;;&lt;/script&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\"&gt;&lt;/script&gt;&lt;script&gt;// Require the registry, parser, Dialog, and wait for domReadyrequire([\"dijit/registry\", \"dojo/parser\", \"dojo/json\", \"dojo/_base/config\", \"dijit/Dialog\", \"dojo/domReady!\"], function(registry, parser, JSON, config) &#123; // Explicitly parse the page parser.parse(); // Find the dialog var dialog = registry.byId(\"dialog\"); // Set the content equal to what dojo.config is dialog.set(\"content\", \"&lt;pre&gt;\" + JSON.stringify(config, null, \"\\t\") + \"```\"); // Show the dialog dialog.show();&#125;);&lt;/script&gt;&lt;!-- and later in the page --&gt;&lt;div id=\"dialog\" data-dojo-type=\"dijit/Dialog\" data-dojo-props=\"title: 'dojoConfig / dojo/_base/config'\"&gt;&lt;/div&gt;&lt;!-- 二:写在script标签中 --&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\" data-dojo-config=\"has:&#123;'dojo-firebug': true&#125;, parseOnLoad: false, foo: 'bar', async: 1\"&gt;&lt;/script&gt; 使用has()配置特性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 has: &#123; //启用firebug lite,chrome中的firebug调试插件 \"dojo-firebug\": true, \"dojo-debug-messages\": true, \"dojo-amd-factory-scan\": false &#125;``` #### 加载配置```json//配置异步加载的基本urlbaseUrl: \"/js\",//配置包名和位置packages: [&#123; name: \"myapp\", location: \"/js/myapp\" &#125;],//使用dojo代表dojo16map: &#123; dijit16: &#123; dojo: \"dojo16\" &#125; &#125;,//定制模块到不同的路径packages: [ \"package1\", \"package2\" ], paths: &#123; package1: \"../lib/package1\", package2: \"/js/package2\" &#125;//等价于 packages: [ &#123; name: \"package1\", location: \"../lib/package1\" &#125;, &#123; name: \"package2\", location: \"/js/package2\" &#125; ],//是否异步加载async: true,//dojo加载完毕就开始加载deps: [\"dojo/parser\"],//当文档和deps加载完毕后，使用dojo/parser模块进行解析parseOnLoad: true,//deps中的加载完毕后执行callback: function(parser) &#123; // Use the resources provided here &#125;,//发出模块请求后的等待时间waitSeconds: 5,//不使用缓存策略cacheBust: true 其他的配置对象其他模块中使用的配置对象,主要是dojox,dijit。 Dijit EditorallowXdRichTextSave dojox GFXdojoxGfxSvgProxyFrameUrl, forceGfxRenderer, gfxRenderer dojox.html metricsfontSizeWatch dojox.io transports and pluginsxipClientUrl, dojoCallbackUrl dojox.imagepreloadImages dojox.analytics pluginssendInterval, inTransitRetry, analyticsUrl, sendMethod, maxRequestSize, idleTime, watchMouseOver, sampleDelay, targetProps, windowConnects, urchin dojox.cometdcometdRoot dojox.form.FileUploaderuploaderPath dojox.mobilemblApplyPageStyles, mblHideAddressBar, mblAlwaysHideAddressBar, mobileAnim, mblLoadCompatCssFiles 参考链接:Hello Dojo!Configuring Dojo","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"汽渡船舶防碰撞预警系统平台","date":"2017-02-25T14:24:53.588Z","path":"2017/02/25/汽渡船舶防碰撞预警系统平台/","text":"汽渡船舶防碰撞预警系统平台汽渡船舶防碰撞预警系统平台功能: 页面动态显示船舶（包括在地图上显示船舶的位置，船舶的航行速度,点击定位能定位到船舶） 提示碰撞警告（查表当将会出现的碰撞时间大于当前时间则生成提示信息，有的船能生成碰撞信息保存到数据库） 推送警告信息(只是将警告信息插入到指定的数据表中) 显示船舶历史轨迹动画 可以在地图上管理标注（标注类型有:点、多段线、多边形等标注）， 基本数据的增删改查、以图表方式展示数据 具有用户操作日志，记录用户的每一个操作。 具有权限管理，给不同的用户设置不同的权限。(也是通过用户关联爹角色形式。) 能够扩展基本数据，便于系统的灵活扩展。 对于地图的操作有:放大、缩小、测量、显示不同的底图（包括矢量图、影像图、黑暗图）使用到的框架和库:后台框架:Spring、Spring MVC、MyBatis前台框架:jQuery、Easy UI、arcgis for js 3.20、jWebAudio（音频库）、Cocurrent.Thread.jsjQuery插件:ZeroModal(jQuery弹出层插件)、uploadPreview、ajaxFileUpload、jQuery.cookie数据库:Oracle 值得注意的地方ArcGIS API for JSArcGIS中，地图由图层组成。GraphicLayer用于创建几何图形层，自定义的图形、绘制的图形都放置其上。ArcGISDynamicMapServiceLayer用于创建ArcGIS服务中得到的图层(背景图)。放置在GraphicLayer上的图形(Graphic)有两种元素构成，记号(Symbol),几何(Geometry)组成。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 用到的ArcGIS API for JS * ?:代表可选参数 *//*map及其相关API*///\"esri/map\"var myMap = new Map(divId, options?);//新建一个Map,divId为使用的html标签myMap.addLayer(layer,index?)//添加图层myMap.setExtent(extent, fit?)//设置地图的范围,定位也是通过这个API实现的//\"esri/SpatialReference\"new SpatialReference(wkid)//定义一个空间参考,wkid是数字//\"esri/geometry/Extent\"new Extent(xmin, ymin, xmax, ymax, spatialReference)//右上角与左下角的坐标,/*layer及其相关API*///\"esri/layers/GraphicsLayer\"var gLayer = new GraphicsLayer(options?)//新建图层,建立的是可在上面添加东西的图层gLayer.add(graphic)//添加图形gLayer.remove(graphic)//移除图形//\"esri/layers/ArcGISDynamicMapServiceLayer\"new ArcGISDynamicMapServiceLayer(url, options?)//使用发布arcgis服务作为图层//\"esri/InfoTemplate\"new InfoTemplate(title, content)//创建信息模板//\"esri/graphic\"var graphic = new Graphic(geometry?, symbol?, attributes?, infoTemplate?)//创建一个图形graphic.setInfoTemplate(infoTemplate);//设置图形的信息模板//\"esri/symbols/SimpleLineSymbol\" //创建一个记号 //style，例esri.symbol.SimpleLineSymbol.STYLE_SOLID //color,例esri.Color(\"#00f2fa\")var sys = new SimpleLineSymbol(style, color, width)//创建一个多边形var polylineJson = &#123; \"paths\" : [ [ [ obj.LON, obj.LAT ], [ nextObj.LON, nextObj.LAT ] ] ], \"spatialReference\" : &#123; \"wkid\" : 4326 &#125;&#125;;//\"esri/geometry/Polyline\",\"esri/graphic\"var gLine = new esri.Graphic(new esri.geometry.Polyline( polylineJson), sls);//\"esri/symbols/PictureMarkerSymbol\"new PictureMarkerSymbol(url, width, height)//创建一个图片记号//\"esri/symbols/SimpleMarkerSymbol\"new SimpleMarkerSymbol(style, size, outline, color)//简单标志记号/*操作Map相关工具的API*///\"esri/toolbars/draw\"var drawpoint = new Draw(map, options?)//生成一个用于画点的对象drawpoint.deactivate();//使工具栏无效，并且重新激活导航栏。drawpoint.on(\"draw-end\", addToMapC);//画图结束触发事件//\"esri/toolbars/navigation\"navigationToolbar = new Navigation(myMap);//创建地图工具对象navigationToolbar.activate(Navigation.ZOOM_IN);//放大navigationToolbar.activate(Navigation.ZOOM_OUT);//缩小 保存用户名和密码使用前台jQuery.cookie读取cookie，后台添加cookiejQuery.cookie相关API 123456//读取cookie,不存在返回null$.cookie('the_cookie'); //删除cookie$.cookie('the_cookie', null); //创建一个cookie并设置 cookie的有效路径(在默认情况下，只有设置 cookie的网页才能读取该 cookie。如果想让一个页面读取另一个页面设 )： $.cookie('the_cookie', 'the_value', &#123; expires: 7, path: '/' &#125;); 后台添加cookie 123456789101112131415161718//添加cookieresponse.addCookie(setCookies(\"pwd\", user.getUserpwd()));//清除Cookiepublic void cleanCookie(HttpServletRequest req,HttpServletResponse res)&#123; Cookie[] cookies = req.getCookies(); EmptyUtil eu = new EmptyUtil(); for(Cookie c : cookies)&#123; if((!eu.isFieldEmpty(c.getName())))&#123; if(c.getName().equals(\"user\")||c.getName().equals(\"pwd\")||c.getName().equals(\"rememberUser\")||c.getName().equals(\"username\"))&#123; c.setValue(null); c.setMaxAge(0);// 立即销毁cookie c.setPath(\"/\"); res.addCookie(c); &#125; &#125; &#125;&#125; 防止用户重新登陆实现思路:设置一个sessionMap管理所有的session,当用户登陆时，检测sessionMap中是否存在该session，如果不存在则添加session到sessionMap中。如果存在，则比较两次登陆的IP是否相同，如果相同则只刷新session，如果不同则删去老的session添加新的session。因为用户操作需要权限，权限又跟cookie挂钩，所以去掉了session的用户在下一次操作时就会发现被挤出。 123456789101112131415161718192021222324252627282930313233343536373839404142public synchronized void addSession(HttpSession session,String username)&#123; if(session!=null)&#123; //防止重复登录，旧登录用户踢出 //addSessionMap是保存了所有session的map Set&lt;Map.Entry&lt;String, Object&gt;&gt; submap = appSessionMap.entrySet(); for(Map.Entry&lt;String, Object&gt; emap: submap)&#123; HttpSession subsession = (HttpSession) emap.getValue(); try &#123; String names = subsession.getAttribute(\"username\").toString(); if(names!=null&amp;&amp;names.equals(username))&#123; ApplicationContext applicationContext = SpringContextLoaderListener.getApplicationContext(); IUserLogServices UserLogServices = (IUserLogServices) applicationContext.getBean(\"UserLogServices\"); sys_userinfo user = (sys_userinfo) session.getAttribute(\"user\"); List&lt;sys_userlog&gt; sys_userlog = UserLogServices.getlastuserlog(user.getGuid()); //从日志中获取用户IP if(sys_userlog!=null&amp;&amp;sys_userlog.size()&gt;0)&#123; String newIp = (String) session.getAttribute(\"ip\"); String ip = sys_userlog.get(0).getIpaddress(); if(!ip.equals(newIp))&#123; UserLogServices.setuserlog(ip, user,\" 该账户在其他ip登录，当前操作用户已登出\"); &#125; &#125; appSessionMap.remove(emap.getKey()); break; &#125; &#125; catch (Exception e) &#123; appSessionMap.remove(emap.getKey()); break; &#125; &#125; //首次登录 if(appSessionMap.get(session.getId())==null)&#123; appSessionMap.put(session.getId(), session); &#125;else&#123; //再次登录更新session appSessionMap.remove(session.getId()); appSessionMap.put(session.getId(), session); &#125; &#125; &#125; 在select中使用select子句1234select (select st1.shipname from basic_ferryboatsmsg st1 where st1.qdmmsi=t.mmsi) as SHIPNAME,t.mmsi,t.lon,t.lat,t.cog,t.sog,t.timestr, (select st1.adistance from ELEC_SHIPPOSITION st1 where t.mmsi=st1.mmsi) as ADISTANCE, (select st2.bdistance from ELEC_SHIPPOSITION st2 where t.mmsi=st2.mmsi) as BDISTANCE from basic_fusionrealtime t where t.mmsiorarpaid=mmsiorarpaid order by t.mmsi case when…then…else1234select t.guid,t.shipname,t.mmsi,t.sog,t.cog,t.lon,t.lat, case when t.datatype='F' then '是' else '否' end as datatype,t.mmsi as loca from basic_fusionrealtime t where t.mmsi not in(select t2.qdmmsi from basic_ferryboatsmsg t2) and t.inrange=0 order by t.shipname MyBatis中List","tags":[{"name":"系统分析","slug":"系统分析","permalink":"http://yoursite.com/tags/系统分析/"}]},{"title":"X市数据管理系统分析","date":"2017-02-14T08:41:22.289Z","path":"2017/02/14/X市数据管理系统/","text":"X市数据管理系统分析X市数据管理系统功能: 对数据基本的操作，包括增、删、改、查 以图表的方式展示数据 附件的上传、下载 Excel导入导出 具有地图模块显示二维地图，点击定位，根据导入的坐标定位到地图相应位置并显示与坐标相应的轮廓。 基础数据管理，可以增加基础数据(比如:工程级别、类型、施工状态等)，便于系统扩展。 用户权限管理，通过用户关联角色的方式管理用户的权限。后台:使用了Spring,Spring MVC框架,前台:jQuery,EasyUI,ArcGIS数据库:使用的数据库为Oracle,与数据库的交互使用的是Spring JPA的实现和Spring JDBCTemplate, 值得注意的地方Session保存常用对象 session对象不仅保存了用户对象还直接保存了用户名,用户名很常用,因此这种做法可以节省大量的时间 12session.setAttribute(\"user\", user);session.setAttribute(\"username\", username); 自定义标签用于权限控制最终目标 将每个用户划分到不同的角色，每个角色设置不同的权限，用以管理控制每个用户的权限 角色管理图 用户管理图 不同用户登陆的效果图 实现思路建立一个Resource表,表每一项都是用户可以操作的动作每一项都包含一个自定义的权限标签ID。建立一张Role表,Role与Resource是多对多的关系,建立一张User表,User与Role也是多对多关系。执行自定义标签，查询用户是否具有该标签的ID,使用JPA能够自动进行关联查询。因为EasyUI在节点关闭且该节点下没有子节点时，在展开时会向后台传递该节点ID以请求节点JSON数据,所以可以通过Resource表自关联实现数据的树形菜单。 使用自定义标签来进行权限控制,有权限则显示相应标签否则不显示标签 privilege.xltd 123456789101112131415161718192021222324&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;privilege&lt;/description&gt; &lt;display-name&gt;tecoa&lt;/display-name&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tecv&lt;/short-name&gt; &lt;uri&gt;dms&lt;/uri&gt; &lt;tag&gt; &lt;description&gt;如果有权限，则显示相应的标签&lt;/description&gt; &lt;name&gt;privilege&lt;/name&gt; &lt;tag-class&gt;TagUtil&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;description&gt;所需资源表的id属性值&lt;/description&gt; &lt;name&gt;id&lt;/name&gt; &lt;!-- 属性是否必须，默认为false --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- 是否可以在属性中使用表达式 --&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 标签类 12345678910111213141516171819202122232425262728293031//置于Spring管理下@Componentpublic class TagUtil extends TagSupport &#123; private static final long serialVersionUID = -3739263210672265762L; private String id; private int flag = SKIP_BODY; @Override public int doStartTag() throws JspException &#123; User user = (User) pageContext.getSession().getAttribute(\"user\"); //对于没有登陆的用户或者没有权限的用户 if (EmptyUtil.isObjEmpty(user) || EmptyUtil.isObjEmpty(user.getResourceCodes()) || user.getResourceCodes().isEmpty()) &#123; flag = SKIP_BODY;//跳过标签体 &#125;else if (\"admin\".equals(user.getUsername())) &#123; flag = EVAL_BODY_INCLUDE;//输出标签体的内容 &#125;else&#123; //for(String code : user.getResourceCodes())&#123; if(user.getResourceCodes().contains(id))&#123; flag = EVAL_BODY_INCLUDE; &#125;else&#123; flag = SKIP_BODY; &#125; //&#125; &#125; return flag; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 基础数据类型扩展一些基本的数据类型(比如图片格式、项目完成状态、项目等级)可能会随着用户的使用而修改，为了增加系统的扩展性，加入了基础数据类型管理这个功能。 实现思路建立一张基础数据表,用一个字段(flag)标志不同的基础数据类型(海岛等级(island_grade)、图像数据类型(img_dataype)、所属海区(sea_area)),使用一个字段(value)表示显示的名称。对于可扩展的数据类型，从后台根据标志位(flag)查询出值后，放入前台的下拉框(combobox)中。 多级下拉框(combobox)省下拉框选择后,市下拉框才有值,市下拉框选择后，县下拉框才有值。 实现思路一级下拉框在页面初始化后，将类型传入后台获取该下拉框全部的值。由一级下拉框的选择事件触发ajax与后台交互,将一级下拉框选中的值的ID做为Pid(父类ID)、类型作为参数传入后台获取二级下拉框的所有项,多级下拉框与此同理。 一些不错的工具类 CreateUserByAndDate根据session中保存的用户名来自动的添加数据库中的创建人、创建时间、更新人、更新时间 EmptyUtil判断对象是否为空 感觉不好的地方 混用中英文命名 一些代码的组织不太好,比如Excel导入 12345678//将所有的导入逻辑都写在一个方法中造成了这个方法代码量巨大(达到了8000多行),造成了维护上的困难。我认为至少应该要将导入的逻辑分成散为其他的函数(即将if,else if 逻辑里面的代码块重构为一个方法)，以便于以后Excel导入的更新public List&lt;Object&gt; excelImport(Class&lt;?&gt; clazz, InputStream in, String createBy) throws Exception &#123; if (\"dms.vo.sea.FunctionDivisions\".equals(clazz.getName()))&#123; //... &#125;else if(\"dms.vo.sea.OwnerProject\".equals(clazz.getName()))&#123; //... &#125;&#125; 修改官方的jar包。为了使用jotm管理分布式事务，但是spring-tx，4.2版本中已经废弃了jotm库。公司采取了将在jar包中加入jotm的java文件,使得jotm可以使用,这种方法为以后的开发、维护埋下了巨大的隐患。 用户体验较差,比如:查询、登陆无法回车执行,查看一条记录不能双击执行","tags":[{"name":"系统分析","slug":"系统分析","permalink":"http://yoursite.com/tags/系统分析/"}]},{"title":"2016年终总结与未来展望","date":"2016-12-31T15:13:31.605Z","path":"2016/12/31/2016年终总结与未来展望/","text":"2016年终总结与未来展望​ 我是一名二本学校电子科学与技术的在校生，目前正在一家公司实习，岗位是Java开发。 ​ 今年开学时，我知道大学所剩的时间不多了。我不想考研，因此找一份自己喜欢的工作就成了合理的选择，思来想去觉得自己只有编程还谈得上喜欢。本专业的嵌入式编程还要涉及硬件，对于硬件我实在是不拿手，不仅仅不擅长焊元器件，硬件故障也不知道该怎么判断，再加上国内嵌入式行业发展前景不够好，种种原因让我选择了软件的开发。开始时，我通过慕课网的视频以及一些网站的教程开始学习编程，不得不说通过视频这种被动的学习方式确实让人不会感到枯燥，一天学习七八个小时完全不疲劳。但是这种学习方式也使得我动手能力极度匮乏，而且这样的学习方式也让我养成了依赖和惰性。为了摆脱这种惰性，也为了牢固自己的基础，我开始了看起了书籍，十分感谢《JavaScript DOM编程艺术》、《Head First Servlet &amp; JSP》是这两本书让我知道了专业书籍可以很有趣味、厚的书籍不一定就晦涩难懂。看了一段时间的书籍之后，我觉的我不能在这样下去了，理论是学不完的而编程是一个需要实战的东西，我不能只是写Demo这样的程序，应该要进行些实战。于是我就开始尝试着写一个自己感兴趣的项目。不上手不知道一上手吓一跳，很多东西到实际操作的时候，根本就想不起来，只能再去查、再去看，碰到很多奇奇怪怪的问题，感到自己很无能、怀疑起自己的能力来。但幸运的是最后还是在自己的努力下完成了项目。感觉对这个软件就像自己的孩子一样，一方面对觉得它百般的不好，一方面又不允许别人否认它。 ​ 通过一年磕磕绊绊的学习，我发现了我不少的毛病。第一，有严重的拖延症，总是将重要的事情放在最后做。第二，不能很好的控制自己，早睡早起的目标现在都还没实现。第三，死脑筋，代码一出问题就不断的实验尝试，或者不断的去网上找答案，直到耗光自己的精力(我认为应该先分析，尝试自己解决。没成功后再去网上找答案，如果没找到答案，应该先放着去完成其他事，过一段时间后再回来尝试解决)。第四，缺少沟通，就连有名的github也是到最近才会使用。第五，没有正确对待bug，当我发现bug可以被绕过，就采取绕过的办法，没有认真的分析bug产生的原因。 ​ 当然一年也有不少成功的事：1.成功的考下了驾照（虽然科二考了三次）。2.通过自己努力的自学成功的被公司录取软件开发实习生（虽然不是什么大公司，而且也是我面试失败八次后才被录取）。3.认识了一些圈内的大牛（虽然是我认识他们，他们不认识我）。4.对软件设计有了更细致的了解（虽然也不知道对不对）。5.了解了不少提高效率的软件，开发工具（工具太多反而用不过来）。6.变的爱看书了（虽然读的还是很慢）。总之，一年的时间我也有了不小的成长，无论是在技能上还是学习能力上。今年流行一句话，不忘初心、方的始终。现在，我的编程之路也算是开始了，我思考了下我的初心是对编程、软件的热爱，我希望我将来一个人能够写出完整的有创意的不那么大的小程序、小软件，对于大的工程上到架构下到细枝末节能够知道、理解。不希望自己成为一个见识短浅、害怕学习、只知道搬砖的程序猿。 ​ 对于未来的展望，首先就是能够改变自己的态度、习惯。然后希望能够跟其他的人有更多的交流。对于技能方面，希望自己使用的技术栈能够对底层了解的更加深刻，同时希望自己能够有更广阔的视野。具体一点，阅读30本以上好书。github贡献总计超过200天。","tags":[{"name":"年终总结","slug":"年终总结","permalink":"http://yoursite.com/tags/年终总结/"}]},{"title":"未来世界的幸存者-文章总结","date":"2016-12-31T08:38:27.573Z","path":"2016/12/31/未来世界的幸存者/","text":"未来世界的幸存者这本书是由阮一峰在2016年写的一本开源书籍，不少的篇章都是以前的博文，经过整理、编排后而发布的书。书中有着大量作者对社会、职业和发展方向的思考，以下是对于我来说比较印象深刻、比较有启发的篇章所归纳而成。 旧世界的崩塌作者由AlaphaGo打败李世石事情、无人车的发明,引发思考，人工智能已经达到了很高的水准，随着社会进一步的发展，人工智能很可能代替现在的各种岗位，什么样的岗位是安全的、什么样的人是对社会有用的人？并且还看到随着技术的发展，人们能够在虚拟世界获得的满足越来越高，那么奋斗的意义何在？ 作者认为世界上没有安全的职业，作者以两个例子，苹果公司表示不支持flash动画而导致flash工程师这个职位消失。诺基亚的塞班系统败给智能手机导致,塞班系统工程师失业。由此得出世界没有安全的职业。 作者认为即使终生学习，也不见得可以保证自己的竞争力，因为技术行业技术层出不穷，随着年龄的增长，很难向年轻人一样保持高度的热情与学习能力。等到技术跟不上时代时，就是被行业淘汰的时候了。因此呼吁我们提升:个性服务能力、人格魅力能力、创意能力、决策领导能力，注重底层知识(因为底层知识不容易变更,懂了底层知识更容易学习和使用新技术)。 作者还提到上班和下班已经过时,根据研究表明不用到公司上班的工作效率，明显高于要到公司上班的工作效率，并且有一些公司开始实行了这种方案，也有一些长期接外包项目的人和公司达成了雇佣关系。之所以无法得到推行，是因为人具有惰性，没有合理的监督手段，员工可能无法按时无法完成工作。 人生的B计划人生的B计划中提到人生应该要有应急的B计划。它与现在的工作不同，最好不是同一个行业，它比现在的工作要冒险，但是可以给你带来很高的热情，它应该是你现在就能着手准备的，等到出现突发变故的时候，它能够让你更快的适应这个变故（行业不景气等），重新融入这个社会。 Stay hungry, Stay foolish 的原义文中提到乔布斯在斯坦福演将的一句话stay hungry,stay foolish并放上了乔布斯引用这句话的原照片，虽然文中作者没有提到这句话具体的意思，但是看到这张晨光洒在乡间小路上的照片我想我跟乔布斯的心情是一样的，充满着对未知冒险的激动澎湃的心情。 新方向个性也是一种竞争力在这一节中以papi酱获得1200万风投为例子说明了在技术不断发展的当下，技术不断的消除差异，正因此人们也开始越来越重视个性。一个人若能够拥有的粉丝(支持者)数量，表现了他对社会、对市场的影响力，这也同样表现了他的个性受到的认可程度。当一个东西被大量承认价值，并且稀少时，那么自然就珍贵。","tags":[{"name":"文章总结","slug":"文章总结","permalink":"http://yoursite.com/tags/文章总结/"}]}]