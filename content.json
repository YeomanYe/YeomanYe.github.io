[{"title":"curses模块学习","date":"2017-02-17T14:26:05.822Z","path":"2017/02/17/curses模块学习/","text":"curses学习基本curses模块提供了以文本显示为基础的像linux的控制台的API,包括绘制以及键盘处理等 打开和关闭一个curses应用程序打开curses 12345678# 初始化curses,该函数根据不同设备返回一个windows对象代表整个屏幕,这个对象通常叫做stdscrstdscr = curses.initscr()# 使用curses通常要关闭回显,目的是读取字符尽在适当的环境下输出。curses.noecho()# 设置为立即响应模式curses.cbreak()# 使得程序能够处理特殊的按键如PgUp,Home等curses.keypad(1) 关闭curses 12345678# 关闭字符终端功能curses.nocbreak()# 关闭特殊按键的接收stdscr.keypad(0)# 打开输入回显功能curses.echo()# 调用endwin()恢复默认设置curses.endwin() 可以导入curses.wrapper模块。这个函数做了一些初始化的工作，包括上面提到的和颜色的初始化。然后再执行你提供的函数，最后重置。而且被调用的函数写在try-catch中。也就是应用了curses.wrapper模块只需要考虑代码逻辑即可。 打开新窗口通常调用initscr()获取一个window对象代表全部屏幕。但是很多程序希望划分屏幕为几个小的窗口，为了重绘，擦出这些工作在小窗口中独立进行。newwin()函数就是用来新建一个新的窗口，需要给定窗口尺寸，并返回新的window对象的。curses需要你使用refresh()函数明确指出重绘窗口。 123begin_x = 20; begin_y = 7height = 5; width = 40win = curses.newwin(height, width, begin_y, begin_x) padpad是window的特例。pad可以比显示的屏幕大，一次只显示pad的一部分。创建一个pad很简单，只需要提供宽高即可。但是刷新pad需要提供屏幕上显示的部分pad的坐标。 123456789101112pad = curses.newpad(100, 100)# These loops fill the pad with letters; this is# explained in the next sectionfor y in range(0, 100): for x in range(0, 100): try: pad.addch(y,x, ord('a') + (x*x+y*y) % 26) except curses.error: pass# Displays a section of the pad in the middle of the screenpad.refresh(0,0, 5,5, 20,75) 同时由多个window或者多个pad，有一问题：刷新某个window或pad时屏幕会闪烁。 避免闪烁的方法：在每个window调用noutrefresh()方法。 然后使用refresh()方法的最后再调用doupdate()方法。 API显示字符或字符串,如果没有坐标，字符显示在上一次操作完的位置。 start_color()初始化了8中基本颜色：0:black, 1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan, and 7:white。 init_pair(n,f,b)修改颜色对n，让f为前景色，b为背景色。颜色对0天生的黑白色，不允许改。 1234# 修改color1为红色文本，白色背景：curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)# 使用：stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1)) getch()方法，这个方法暂停等待用户输入，getch()返回一个整数 ，在0到255之间，表示输入字符的ASCII值。打印255的是些特殊字符，比如Page Up,Home。 小例子显示为一个小房子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#! python3# -*- coding:utf-8 -*-import cursesfrom random import randrange# 代表窗口的全局变量stdscr = Nonex = Noney = Nonecont = 0def smoke(): global cont set_color(randrange(0, 3)) if cont == 0: stdscr.addch(y - 19, x - 6, ord('.')) elif cont == 1: stdscr.addch(y - 19, x - 6, ord('o')) elif cont == 2: stdscr.addch(y - 19, x - 6, ord('O')) elif cont == 3: stdscr.addch(y - 19 - 1, x - 7, ord('-')) stdscr.addstr(y - 19, x - 7 - 1, \"|.|\") stdscr.addch(y - 19 + 1, x - 7, ord('-')) elif cont == 4: stdscr.addch(y - 19 - 2, x - 7, ord('-')) stdscr.addstr(y - 19 - 1, x - 7 - 1, \"/ \\\\\") stdscr.addstr(y - 19, x - 7 - 2, \"| O |\") stdscr.addstr(y - 19 + 1, x - 7 - 1, \"\\\\ /\") stdscr.addch(y - 19 + 2, x - 7, ord('-')) elif cont == 5: stdscr.addch(y - 19 - 2, x - 7, ord(' ')) stdscr.addstr(y - 19 - 1, x - 7 - 1, \" \") stdscr.addstr(y - 19, x - 7 - 2, \" \") stdscr.addstr(y - 19 + 1, x - 7 - 1, \" \") stdscr.addch(y - 19 + 2, x - 7, ord(' ')) cont += 1 cont %= 6# 设置颜色def set_color(z): color = curses.color_pair(z) stdscr.attrset(color)# 显示房子def house(): global x global y x = curses.COLS // 2 y = curses.LINES - 2 set_color(0) # 显示房体 for i in range(20): stdscr.addch(y - 8, x - 10 + i, ord('_')) stdscr.addch(y, x - 10 + i, ord('_')) for i in range(8): stdscr.addch(y - i, x - 10, ord('|')) stdscr.addch(y - i, x + 9, ord('|')) # 显示门 for i in range(6): stdscr.addch(y - 3, x - 3 + i, ord('_')) stdscr.addch(y, x - 3 + i, ord('_')) for i in range(3): stdscr.addch(y - i, x - 3, ord('|')) stdscr.addch(y - i, x + 2, ord('|')) # 显示房顶 for i in range(10): stdscr.addch(y - 8 - i, x - 10 + i, ord('/')) stdscr.addch(y - 8 - i, x + 9 - i, ord('\\\\')) # 显示窗户 for i in range(8): stdscr.addch(y - 9, x - 4 + i, '_') stdscr.addch(y - 11, x - 4 + i, '_') for i in range(2): stdscr.addch(y - 9 - i, x - 5, '|') stdscr.addch(y - 9 - i, x + 4, '|') # 显示烟囱 for i in range(4): stdscr.addch(y - 15 + i, x - 7, '|') for i in range(2): stdscr.addch(y - 15 + i, x - 5, '|') for i in range(4): stdscr.addch(y - 15, x - 8 + i, '_') stdscr.addch(y - 17, x - 8 + i, '_') for i in range(2): stdscr.addch(y - 16 + i, x - 9, '|') stdscr.addch(y - 16 + i, x - 4, '|')def main(win): global stdscr stdscr = win # 判断终端是否可以显示颜色 if curses.has_colors(): bg = curses.COLOR_BLACK curses.init_pair(1, curses.COLOR_BLUE, bg) curses.init_pair(2, curses.COLOR_CYAN, bg) # 开启新行模式 curses.nl() # 关闭输入回显 curses.noecho() # 设置为非阻塞模式读取 stdscr.timeout(0) while True: # 显示房子 house() smoke() ch = stdscr.getch() if ch == ord('q') or ch == ord('Q'): return elif ch == ord('s'): # 部进显示 stdscr.nodelay(0) elif ch == ord(' '): # 非延迟显示 stdscr.nodelay(1) # 睡眠50ms curses.napms(50)if __name__ == '__main__': curses.wrapper(main) 结果展示 参考链接cursesAPI参考文档python curses使用curses programming with pythoncurses DEMO","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"X市数据管理系统分析","date":"2017-02-14T08:41:22.289Z","path":"2017/02/14/X市数据管理系统/","text":"X市数据管理系统分析X市数据管理系统是我实习期间第一个接触到的项目，该项目是用于海域规划管理的系统，除了基本的增删改查外。还实现了附件的上传、下载，Excel导入导出,图表展示,还有一个地图模块显示二三维地图。后台:使用了Spring,Spring MVC框架,使用的数据库为Oracle,与数据库的交互使用的是JPA和JDBCTemplate,前台:jQuery,EasyUI,ArcGIS 值得注意的地方Session保存常用对象 session对象不仅保存了用户对象还直接保存了用户名,用户名很常用,因此这种做法可以节省大量的时间 12session.setAttribute(\"user\", user);session.setAttribute(\"username\", username); 自定义标签用于权限控制最终目标 将每个用户划分到不同的角色，每个角色设置不同的权限，用以管理控制每个用户的权限 角色管理图 用户管理图 不同用户登陆的效果图 实现思路建立一个Resource表,表每一项都是用户可以操作的动作每一项都包含一个自定义的权限标签ID。建立一张Role表,Role与Resource是多对多的关系,建立一张User表,User与Role也是多对多关系。执行自定义标签，查询用户是否具有该标签的ID,使用JPA能够自动进行关联查询。因为EasyUI在节点关闭且该节点下没有子节点时，在展开时会向后台传递该节点ID以请求节点JSON数据,所以可以通过Resource表自关联实现数据的树形菜单。 使用自定义标签来进行权限控制,有权限则显示相应标签否则不显示标签 privilege.xltd 123456789101112131415161718192021222324&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;privilege&lt;/description&gt; &lt;display-name&gt;tecoa&lt;/display-name&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tecv&lt;/short-name&gt; &lt;uri&gt;dms&lt;/uri&gt; &lt;tag&gt; &lt;description&gt;如果有权限，则显示相应的标签&lt;/description&gt; &lt;name&gt;privilege&lt;/name&gt; &lt;tag-class&gt;TagUtil&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;description&gt;所需资源表的id属性值&lt;/description&gt; &lt;name&gt;id&lt;/name&gt; &lt;!-- 属性是否必须，默认为false --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- 是否可以在属性中使用表达式 --&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 标签类 12345678910111213141516171819202122232425262728293031//置于Spring管理下@Componentpublic class TagUtil extends TagSupport &#123; private static final long serialVersionUID = -3739263210672265762L; private String id; private int flag = SKIP_BODY; @Override public int doStartTag() throws JspException &#123; User user = (User) pageContext.getSession().getAttribute(\"user\"); //对于没有登陆的用户或者没有权限的用户 if (EmptyUtil.isObjEmpty(user) || EmptyUtil.isObjEmpty(user.getResourceCodes()) || user.getResourceCodes().isEmpty()) &#123; flag = SKIP_BODY;//跳过标签体 &#125;else if (\"admin\".equals(user.getUsername())) &#123; flag = EVAL_BODY_INCLUDE;//输出标签体的内容 &#125;else&#123; //for(String code : user.getResourceCodes())&#123; if(user.getResourceCodes().contains(id))&#123; flag = EVAL_BODY_INCLUDE; &#125;else&#123; flag = SKIP_BODY; &#125; //&#125; &#125; return flag; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 基础数据类型扩展一些基本的数据类型(比如图片格式、项目完成状态、项目等级)可能会随着用户的使用而修改，为了增加系统的扩展性，加入了基础数据类型管理这个功能。 实现思路建立一张基础数据表,用一个字段(flag)标志不同的基础数据类型(海岛等级(island_grade)、图像数据类型(img_dataype)、所属海区(sea_area)),使用一个字段(value)表示显示的名称。对于可扩展的数据类型，从后台根据标志位(flag)查询出值后，放入前台的下拉框(combobox)中。 多级下拉框(combobox)省下拉框选择后,市下拉框才有值,市下拉框选择后，县下拉框才有值。 实现思路一级下拉框在页面初始化后，将类型传入后台获取该下拉框全部的值。由一级下拉框的选择事件触发ajax与后台交互,将一级下拉框选中的值的ID做为Pid(父类ID)、类型作为参数传入后台获取二级下拉框的所有项,多级下拉框与此同理。 一些不错的工具类 CreateUserByAndDate根据session中保存的用户名来自动的添加数据库中的创建人、创建时间、更新人、更新时间 EmptyUtil判断对象是否为空 感觉不好的地方 混用中英文命名 一些代码的组织不太好,比如Excel导入 12345678//将所有的导入逻辑都写在一个方法中造成了这个方法代码量巨大(达到了8000多行),造成了维护上的困难。我认为至少应该要将导入的逻辑分成散为其他的函数(即将if,else if 逻辑里面的代码块重构为一个方法)，以便于以后Excel导入的更新public List&lt;Object&gt; excelImport(Class&lt;?&gt; clazz, InputStream in, String createBy) throws Exception &#123; if (\"dms.vo.sea.FunctionDivisions\".equals(clazz.getName()))&#123; //... &#125;else if(\"dms.vo.sea.OwnerProject\".equals(clazz.getName()))&#123; //... &#125;&#125; 修改官方的jar包。为了使用jotm管理分布式事务，但是spring-tx，4.2版本中已经废弃了jotm库。公司采取了将在jar包中加入jotm的java文件,使得jotm可以使用,这种方法为以后的开发、维护埋下了巨大的隐患。 用户体验较差,比如:查询、登陆无法回车执行,查看一条记录不能双击执行","tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"2016年终总结与未来展望","date":"2016-12-31T15:13:31.605Z","path":"2016/12/31/2016年终总结与未来展望/","text":"2016年终总结与未来展望​ 我是一名二本学校电子科学与技术的在校生，目前正在一家公司实习，岗位是Java开发。 ​ 今年开学时，我知道大学所剩的时间不多了。我不想考研，因此找一份自己喜欢的工作就成了合理的选择，思来想去觉得自己只有编程还谈得上喜欢。本专业的嵌入式编程还要涉及硬件，对于硬件我实在是不拿手，不仅仅不擅长焊元器件，硬件故障也不知道该怎么判断，再加上国内嵌入式行业发展前景不够好，种种原因让我选择了软件的开发。开始时，我通过慕课网的视频以及一些网站的教程开始学习编程，不得不说通过视频这种被动的学习方式确实让人不会感到枯燥，一天学习七八个小时完全不疲劳。但是这种学习方式也使得我动手能力极度匮乏，而且这样的学习方式也让我养成了依赖和惰性。为了摆脱这种惰性，也为了牢固自己的基础，我开始了看起了书籍，十分感谢《JavaScript DOM编程艺术》、《Head First Servlet &amp; JSP》是这两本书让我知道了专业书籍可以很有趣味、厚的书籍不一定就晦涩难懂。看了一段时间的书籍之后，我觉的我不能在这样下去了，理论是学不完的而编程是一个需要实战的东西，我不能只是写Demo这样的程序，应该要进行些实战。于是我就开始尝试着写一个自己感兴趣的项目。不上手不知道一上手吓一跳，很多东西到实际操作的时候，根本就想不起来，只能再去查、再去看，碰到很多奇奇怪怪的问题，感到自己很无能、怀疑起自己的能力来。但幸运的是最后还是在自己的努力下完成了项目。感觉对这个软件就像自己的孩子一样，一方面对觉得它百般的不好，一方面又不允许别人否认它。 ​ 通过一年磕磕绊绊的学习，我发现了我不少的毛病。第一，有严重的拖延症，总是将重要的事情放在最后做。第二，不能很好的控制自己，早睡早起的目标现在都还没实现。第三，死脑筋，代码一出问题就不断的实验尝试，或者不断的去网上找答案，直到耗光自己的精力(我认为应该先分析，尝试自己解决。没成功后再去网上找答案，如果没找到答案，应该先放着去完成其他事，过一段时间后再回来尝试解决)。第四，缺少沟通，就连有名的github也是到最近才会使用。第五，没有正确对待bug，当我发现bug可以被绕过，就采取绕过的办法，没有认真的分析bug产生的原因。 ​ 当然一年也有不少成功的事：1.成功的考下了驾照（虽然科二考了三次）。2.通过自己努力的自学成功的被公司录取软件开发实习生（虽然不是什么大公司，而且也是我面试失败八次后才被录取）。3.认识了一些圈内的大牛（虽然是我认识他们，他们不认识我）。4.对软件设计有了更细致的了解（虽然也不知道对不对）。5.了解了不少提高效率的软件，开发工具（工具太多反而用不过来）。6.变的爱看书了（虽然读的还是很慢）。总之，一年的时间我也有了不小的成长，无论是在技能上还是学习能力上。今年流行一句话，不忘初心、方的始终。现在，我的编程之路也算是开始了，我思考了下我的初心是对编程、软件的热爱，我希望我将来一个人能够写出完整的有创意的不那么大的小程序、小软件，对于大的工程上到架构下到细枝末节能够知道、理解。不希望自己成为一个见识短浅、害怕学习、只知道搬砖的程序猿。 ​ 对于未来的展望，首先就是能够改变自己的态度、习惯。然后希望能够跟其他的人有更多的交流。对于技能方面，希望自己使用的技术栈能够对底层了解的更加深刻，同时希望自己能够有更广阔的视野。具体一点，阅读30本以上好书。github贡献总计超过200天。","tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"未来世界的幸存者","date":"2016-12-31T08:38:27.573Z","path":"2016/12/31/未来世界的幸存者/","text":"未来世界的幸存者这本书是由阮一峰在2016年写的一本开源书籍，不少的篇章都是以前的博文，经过整理、编排后而发布的书。书中有着大量作者对社会、职业和发展方向的思考，以下是对于我来说比较印象深刻、比较有启发的篇章所归纳而成。 旧世界的崩塌作者由AlaphaGo打败李世石事情、无人车的发明,引发思考，人工智能已经达到了很高的水准，随着社会进一步的发展，人工智能很可能代替现在的各种岗位，什么样的岗位是安全的、什么样的人是对社会有用的人？并且还看到随着技术的发展，人们能够在虚拟世界获得的满足越来越高，那么奋斗的意义何在？ 作者认为世界上没有安全的职业，作者以两个例子，苹果公司表示不支持flash动画而导致flash工程师这个职位消失。诺基亚的塞班系统败给智能手机导致,塞班系统工程师失业。由此得出世界没有安全的职业。 作者认为即使终生学习，也不见得可以保证自己的竞争力，因为技术行业技术层出不穷，随着年龄的增长，很难向年轻人一样保持高度的热情与学习能力。等到技术跟不上时代时，就是被行业淘汰的时候了。因此呼吁我们提升:个性服务能力、人格魅力能力、创意能力、决策领导能力，注重底层知识(因为底层知识不容易变更,懂了底层知识更容易学习和使用新技术)。 作者还提到上班和下班已经过时,根据研究表明不用到公司上班的工作效率，明显高于要到公司上班的工作效率，并且有一些公司开始实行了这种方案，也有一些长期接外包项目的人和公司达成了雇佣关系。之所以无法得到推行，是因为人具有惰性，没有合理的监督手段，员工可能无法按时无法完成工作。 人生的B计划人生的B计划中提到人生应该要有应急的B计划。它与现在的工作不同，最好不是同一个行业，它比现在的工作要冒险，但是可以给你带来很高的热情，它应该是你现在就能着手准备的，等到出现突发变故的时候，它能够让你更快的适应这个变故（行业不景气等），重新融入这个社会。 Stay hungry, Stay foolish 的原义文中提到乔布斯在斯坦福演将的一句话stay hungry,stay foolish并放上了乔布斯引用这句话的原照片，虽然文中作者没有提到这句话具体的意思，但是看到这张晨光洒在乡间小路上的照片我想我跟乔布斯的心情是一样的，充满着对未知冒险的激动澎湃的心情。 新方向个性也是一种竞争力在这一节中以papi酱获得1200万风投为例子说明了在技术不断发展的当下，技术不断的消除差异，正因此人们也开始越来越重视个性。一个人若能够拥有的粉丝(支持者)数量，表现了他对社会、对市场的影响力，这也同样表现了他的个性受到的认可程度。当一个东西被大量承认价值，并且稀少时，那么自然就珍贵。","tags":[{"name":"书评","slug":"书评","permalink":"http://yoursite.com/tags/书评/"}]}]