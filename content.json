[{"title":"你不知道的JavaScript（上卷）","date":"2016-12-29T14:21:03.419Z","path":"2016/12/29/你不知道的JavaScript（上卷）/","text":"你不知道的JavaScript(上卷)第一部分 作用域和闭包第1章 作用域是什么编译原理 JS是一门编译语言 编译的三个步骤 分词/词法分析(Tokenizing/Lexing)–将程序段分解为词法单元 解析/语法解析(Parsing)–将词法单元转换成一个由元素嵌套所组成的代表程序语法的”抽象语法树”(Abstract Syntax Tree,AST) 代码生成–将AST转换为可执行代码的过程，与语言、目标平台等息息相关。 JS代码片段执行前都需要进行编译，但不一定是整个文件一起编译。 理解作用域 引擎的LHS(写入)引用和RHS(读取)引用 在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层作用域为止。 RHS查询一个未声明的变量时会抛出ReferenceError,在非严格模式下进行一个未声明变量的LHS查询时会在全局作用域创建该变量。 第2章 词法作用域 名词解释:词法作用域，产生于词法分析阶段，只由函数被声明时所处的位置决定。 词法作用域查找只会查找一级标识符,如果代码中引用了foo.bar.baz,词法作用域只会视图查找foo标识符 运行时修改词法作用域 1234567891011121314151617181920212223242526272829303132//使用eval,动态的修改了b,遮蔽了外部的b//严格模式下eval会生成自己的作用域，并不会遮蔽变量function foo(str,a)&#123; eval(str); console.log(a,b);&#125;var b=2;//1,3foor(\"var b = 3;\",1);//使用withfunction foo(obj)&#123; with(obj)&#123; a = 2; &#125;&#125;var o1 = &#123; a:3&#125;;var o2 = &#123; b:3&#125;;foo(o1);console.log(o1.a);//2//相当于在o2中对a进行了LHS查询foo(o2);console.log(o2.a);//undefinedconsole.log(a);//2 Tips:如果在with中使用var声明变量，变量会被提升到上一层的作用域中。 使用了eval和with无法在编译期进行性能优化 第3章 函数作用域和块作用域 函数可以产生一个作用域，可以使用该作用域进行对象的隐藏，作为局部作用域。 任何库都应该在全局作用域产生一个独特的对象，将暴露的API作为该对象的属性，防止多个库的冲突。 (function (){..})();函数表达式不会污染外部的命名空间(不产生函数名,覆盖变量名) 匿名函数的缺点 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 没有函数名，无法解除事件绑定。 使得代码可读性、可理解性降低。 块级作用域 try{}catch(e){} //catch内部为块级作用域 (function(){..})() let声明块级作用域在{..}中 let声明的变量没有作用域提升,重构时需要付出额外的精力 12345678//undefined//a提升(a被视为存在于其所出现的作用域的整个范围内)(function()&#123;console.log(a);var a = 1;&#125;());//Uncaught ReferenceError: a is not defined//不存在提升(function()&#123;console.log(a);let a = 1;&#125;)();(function()&#123;console.log(a);&#125;()); 块级作用域的变量执行完毕后将会被垃圾回收装置回收 第4章 提升 编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来,词法作用域的核心内容。因此，包括变量和函数在内的所有生命都会在任何代码被执行前首先被处理。 var a = 2;会被分解为两步第一步为var a;(编译时,就好像将声明提升到了作用域的开头) 第二步a = 2;(执行时) 1234567891011121314foo();//TypeErrorbar();//ReferenceErrorvar foo = function bar()&#123; //...&#125;;//相当于var foo;foo();//TypeErrorbar();//ReferenceErrorfoo = function()&#123; var bar = ...self... //...&#125; 函数优先 12345678910111213141516171819202122232425262728293031foo();//1var foo;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125;;function foo()&#123; console.log(3);&#125;//会被引擎理解为//var foo;是重复的声明(因此被忽略了),但是后出现的函数还是可以覆盖前面的function foo()&#123; console.log(1);&#125;function foo()&#123; console.log(3);&#125;foo();//1foo = function()&#123; console.log(2);&#125;; 注意块级作用域情况，并不影响提升 1234567foo();//\"b\"var a = true;if(a)&#123; function foo()&#123;console.log(\"a\");&#125;&#125;else&#123; function foo()&#123;console.log(\"b\");&#125;&#125; 第5章 作用域闭包 无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 12345678910function foo()&#123; var b = 1,a = 2; function bar(str)&#123; eval(str); &#125; window.bar = bar;&#125;foo();bar(\"console.log(a);\");//2bar(\"console.log(b);\");//1 只要内部作用域存在，外部作用域中的变量就不会被垃圾回收器回收 函数在定义时作用域范围已经固定，因而产生闭包 123456789101112131415function foo()&#123; var a = 2; function bar()&#123;console.log(a);console.log(c);console.log(d);&#125; baz(bar);&#125;var c = 3;function baz(fn)&#123; var c = 4,d = 7; fn();&#125;foo();//结果为//2//3//ReferenceError 区分是否是闭包的方法 函数是否引用外部作用域的变量。 是否是在定义的作用域被执行。 模块模式的两个必要条件 必须有外部的封闭函数，该函数必须至少被调用一次。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 模块实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var MyModules = (function Manager()&#123; var modules = &#123;&#125;; function define(name,deps,impl)&#123; for(var i=0,len=deps.length;i&lt;len;i++)&#123; deps[i] = modules[deps[i]]; &#125; //配置函数/对象到模块中 取得依赖的模块并产生新模块 modules[name] = impl.apply(impl,deps); &#125; function get(name)&#123; return modules[name]; &#125; return &#123; define:define, get:get &#125;&#125;)();//封装模块MyModules.define(\"bar\",[],function()&#123; function hello(who)&#123; return \"Let me introduce: \"+who; &#125; return &#123; hello:hello &#125;&#125;);MyModules.define(\"foo\",[\"bar\"],function(bar)&#123; var hungry = \"hippo\"; function awesome()&#123; console.log(bar.hello(hungry).toUpperCase()); &#125; return &#123; awesome:awesome &#125;;&#125;);//调用模块var bar = MyModules.get(\"bar\"), foo = MyModules.get(\"foo\");//Let me introduce: hippoconsole.log(bar.hello(\"hippo\"));//LET ME INTRODUCE: HIPPOfoo.awesome(); 附录A 动态作用域 JS中只存在词法作用域不存在动态作用域 this机制某种程度上很像动态作用域 123456789101112function foo()&#123; //2:词法作用域(3:动态作用域) console.log(a);//2&#125;function bar()&#123; var a = 3; foo();&#125;var a = 2;bar(); 附录B 块作用域的替代方案 Traceur将ES6的新特性，变成ES5的代码 1234let(a = 2)&#123; console.log(a);//2&#125;console.log(a);//ReferenceError ES6并不支持这种语法，可以使用作者的工具let-er将这种语法转换成标准的语法。 附录C this词法 箭头函数放弃了所有普通this的绑定规则,取而代之的是用当前词法作用域覆盖了this本来的值 12345678910111213141516171819202122232425var obj = &#123; count:0, cool:function coolFn()&#123; var self = this; if(self.count&lt;1)&#123; setTimeout(function timer()&#123; self.count++; console.log(\"awesome?\"); &#125;,100); &#125; &#125;&#125;;//等价于var obj = &#123; count:0, cool:function coolFn()&#123; if(this.count &lt; 1)&#123; setTimeout(() =&gt; &#123; //this.count; console.log(\"awesome\"); &#125;,100); &#125; &#125;&#125;; 第二部分 this和对象原型第1章 关于this this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 this不指向函数自身也不指向函数的词法作用域 第2章 this全面解析调用栈和调用位置 调用栈(使用在函数中打断点的方式通过控制台查看)和调用位置 1234567891011121314151617181920function baz() &#123;// 当前调用栈是： baz// 因此， 当前调用位置是全局作用域console.log( \"baz\" ); bar(); // &lt;-- bar 的调用位置&#125;function bar() &#123; // 当前调用栈是 baz -&gt; bar// 因此， 当前调用位置在 baz 中console.log( \"bar\" ); foo(); // &lt;-- foo 的调用位置&#125;function foo() &#123;// 当前调用栈是 baz -&gt; bar -&gt; foo// 因此， 当前调用位置在 bar 中 console.log( \"foo\" ); console.log(this);&#125; baz(); // &lt;-- baz 的调用位置 绑定规则默认绑定(绑定到window对象)123456789function foo()&#123; console.log(this.a);&#125;var a = 2;(function()&#123; foo();//2 &#125;)(); 注意： 对于默认绑定来说， 决定this绑定对象的并不是调用位置是否处于严格模式， 而是函数体是否处于严格模式。 如果函数体处于严格模式,this 会被绑定到undefined， 否则this 会被绑定到全局对象。 隐式绑定 调用位置是否有上下文对象， 或者说是否被某个对象拥有或者包含 123456789101112131415function foo()&#123; console.log(this.a);&#125;var obj2 = &#123; a:42, foo:foo&#125;;var obj1 = &#123; a:2, obj2:obj2&#125;;//只跟最后一个对象有关obj1.obj2.foo();//42 隐式丢失(将对象的函数赋值在调用，常见为将函数作为参数传入的情况) 123456789101112function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;var a = \"oops,global\";//a是全局对象的属性setTimeout(obj.foo,100); 调用回调函数的函数可能会修改this,在库中尤为常见(一些流行的JS库中事件处理器会把回调函数的this强制绑定到触发事件的DOM元素上) 显示绑定 使用函数call(),apply()和bind(…)进行对象绑定(将对象绑定到this) 注意:JS的宿主环境中有时会提供一些非常特殊的函数，它们并没有这两个方法。 如果传入一个原始值(字符串类型、布尔类型或者数字类型)来当作this的绑定对象，这个原始值会被转换成它的对象形式(也就是new String(…)、new Boolean(…)或者new Number(…))。这通常被称为”装箱”。 硬绑定(使用bind(…)方法进行绑定) 12345678910111213function foo(something)&#123; console.log(this.a,something); return this.a + something;&#125;var obj = &#123; a:2&#125;;var bar = foo.bind(obj);var b = bar(3);console.log(b); API调用”上下文” 第三方库的许多函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为”上下文”(context),其作用和bind(…)一样 123456789function foo(el)&#123; console.log(el,this.id);&#125;var obj = &#123; id:\"awesome\"&#125;;//调用foo(...)时把this绑定到obj[1,2,3].forEach(foo,obj); new 绑定 并不存在”构造函数”，只有对于函数的”构造调用”。 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 优先级 new 绑定 | 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 在new中是哦越高硬绑定函数，主要目的是预设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数。( 这种技术称为“ 部分应用”， 是“ 柯里化” 的一种) bind(…)的功能之一就是可以把除了第一个参数(第一个参数用于绑定this)之外的其他参数都传给下层的函数。 12345678910function foo(p1,p2)&#123; this.val = p1 + p2;&#125;//使用null是因为并不关心硬绑定的this是什么//反正使用new时this会被修改var bar = foo.bind(null,\"p1\");var baz = new bar(\"p2\");baz.val;//p1p2 绑定例外 如果把null或者undefined作为this的绑定对象传入call、apply或者bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。 Object.create(null)不会创建Object.prototype这个委托，它比{}更空 传入空对象比传入null更加安全,防止污染全局变量 12345678910111213function foo(a,b)&#123; console.log(\"a:\"+a+\",b:\"+b);&#125;// 我们的 DMZ 空对象var ø = Object.create(null);// 把数组展开成参数foo.apply(ø,[2,3]);// 使用 bind(..) 进行柯里化var bar = foo.bind(ø,2);bar(3); 间接引用 123456789101112function foo()&#123; console.log(this.a);&#125;var a = 2;var o = &#123;a:3,foo:foo&#125;;var p = &#123;a:4&#125;;o.foo();//3//这里应用的是默认绑定//复制表达式返回值是目标函数的引用而不是p.foo()或者o.foo()(p.foo = o.foo)();//2 软绑定(修改默认绑定，同时可以使用隐式绑定、显示绑定修改默认绑定) 123456789101112131415if(!Function.prototype.softBind)&#123; Function.prototype.softBind = function(obj)&#123; var fn = this; //捕获所有curried参数 var curried = [].slice.call(arguments,1); var bound = function()&#123; return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply(curried,arguments) ); &#125;; bound.prototype = Object.create(fn.prototype); return bound; &#125;&#125; 软绑定的使用 123456789101112131415161718192021function foo()&#123; console.log(\"name:\"+this.name);&#125;var obj = &#123;name:\"obj\"&#125;, obj2 = &#123;name:\"obj2\"&#125;, obj3 = &#123;name:\"obj3\"&#125;;var fooOBJ = foo.softBind(obj);//name:objfooObj();//name:obj2obj.foo = foo.softBind(obj);obj2.foo();//name:obj3fooOBJ.call(obj3);//name:obj setTimeout(obj2.foo,10); 箭头函数(this继承自外部函数) 123456789101112function foo()&#123; setTimeout(() =&gt; &#123; //这里的this在此法上继承自foo() console.log(this.a); &#125;,100);&#125;var obj = &#123; a:2&#125;;foo.call(obj); //2 第3章 对象对象类型 JS六种主要类型string,boolean,number,null,undefined(5种基本类型),object 内置对象String、Array…是一些可以当作构造函数的内置函数。 JS中也有自动装箱和拆箱的概念将字面量转换为相应的对象。(string,boolean和number) 数组和对象都根据自身的数据结构进行了优化，最好不要混用 数组字符串数字会被视为索引 123456789var myArray = [\"foo\",42,\"bar\"];//添加了一个数组下标myArray[\"3\"] = \"baz\";//4myArray.length;//\"baz\"myArray[3]; 对象复制 对象复制 浅复制(复制值，复制引用的地址) 深复制(复制值，复制实际引用的空间) 深复制的实现 12//只使用于JSON 安全（ 也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象） 的对象var newObj = JSON.parse(JSON.stringify(someObj)); 浅复制的实现 1234567891011var anotherObject = &#123;&#125;;var myObject = &#123; a:2, b:anotherObject,&#125;;//ES6中定义了Object.assign(..)方法来实现浅复制。//Object.assign(..)遍历一个或多个源对象的所有可枚举（ enumerable， 参见下面的代码）的自有键（ owned key， 很快会介绍） 并把它们复制（ 使用 = 操作符赋值到目标对象， 最后返回目标对象var newObj = Object.assign(&#123;&#125;,myObject);newObj.a;//2newObj.b === anotherObject;//true Tips:由于Object.assign(..)就是使用=操作符来赋值，所以源对象属性的一些特性(比如writable)不会被复制到目标对象。 对象属性描述符 获取和设置属性描述符 123456789101112131415161718192021var myObject = &#123; a:2&#125;;//获取对应属性的属性描述符Object.getOwnPropertyDescriptor(myObject,\"a\");//&#123;// value:2,// writable:true,// enumerable:true,// configurable:true//&#125;//设置属性描述符Obejct.defineProperty(myObject,\"b\",&#123; value:3, writable:true, configurable:true, enumerable:true &#125;);myObject.b;//3 属性描述符 value:属性的值 writable:决定属性的值是否可以被更改，严格模式下更改会报错 configurable:决定属性描述符是否可以配置。属性值可以被更改，不可以使用Object.defineProperty(..)配置属性描述符,也不可以删除属性;配置为false后进行修改会报错 enumerable:这个描述符控制的是属性是否会出现在对象的属性枚举中,比如for…in循环。 禁止扩展(禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..)) 1234567var myObject = &#123; a:2&#125;;Object.preventExtensions(myObject);myObject.b = 3;//严格模式下将会抛出错误myObject.b;//undefined 密封(Object.seal(..)会创建一个”密封”对象，相当于对这个对象调用Object.preventExtensions(..)并把所有属性标记为configurable:false) 冻结(Object.freeze(..)会创建一个冻结对象，这个方法实际会在一个现有对象上调用Object.seal(..)并把所有”数据访问”属性标记为writable:false) 深度冻结，遍历对象下的所有属性对每一个对象属性都调用Object.freeze(..)方法 Getter和Setter 对象默认的[[Put]]和[[Get]]操作分别可以控制属性值的设置和获取 [[Put]]调用过程 属性是否是访问描述符？ 如果是并且存在 setter 就调用 setter。 属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败， 在严格模式下抛出 TypeError 异常。 如果都不是， 将该值设置为属性的值。 [[Get]]调用过程，通过原型链查找是否具有该属性，如果没有该属性则返回undefined Getter和Setter将属性定义为”访问描述符”(和”数据描述符”相对),对于访问描述符来说，JS会忽略它们的value和writable特性，而关心set和get 123456789101112131415161718192021222324252627282930313233//定义getvar myObject = &#123; //给a定义一个getter get a()&#123; return 2; &#125;&#125;;Object.defineProperty(myObject,\"b\", &#123; get:function()&#123; return this.a * 2 &#125;, enumerable:true &#125;);myObject.a; //2myObject.b; //4//使用set和get定义对象var myObject = &#123; //给a定义一个getter get a()&#123; return this._a_ ; &#125;, //给a定义一个setter set a(val)&#123; this._a_ = val*2; &#125;&#125;;myObject.a = 2;myObject.a;//4 判断属性是否存在 123456789var myObject = &#123; a:2&#125;;//in操作符会检查属性是否在对象及其[[Prototype]]原型链中(\"a\" in myObject);//true//只会检查属性是否在myObject对象中myObject.hasOwnProperty(\"a\");//true//等价于Object.prototype.hasOwnProperty.call(myObject,\"a\"); Tips:数组使用for..in循环用来遍历对象的可枚举属性列表(包括[[Prototype]]链),数组最好使用for循环来遍历数组索引。 判断属性是否可枚举 12345678//判断属性是否可枚举myObject.propertyIsEnumerable(\"a\");//truemyObject.propertyIsEnumerable(\"b\");//false//返回myObject中所有可枚举的属性Object.keys(myObject);//[\"a\"]//返回myObject所有的属性Object.getOwnPropertyNames(myObject);//[\"a\",\"b\"] 遍历 并没有内置的方法可以获取 in 操作符使用的属性列表;若要获取所有属性列表，可以使用递归遍历来获取 数组循环array.forEach(callback),array.every(callback)(直到回调函数返回false),array.some(callback)(直到回调函数返回true) ES6的for..of语法来遍历数组结构(数组、对象等等)中的值,for..of会寻找内置或者自定义的@@iterator对象并调用它的next()方法来遍历数组值。 12345678910111213141516171819202122232425262728293031//自定义迭代器使用for..of遍历var myObject = &#123; a:2, b:3&#125;;Object.defineProperty(myObject,Symbol.iterator,&#123; enumerable:false, writable:false, configurable:true, value:function()&#123; var o = this; var idx = 0; var ks = Object.keys(o); return &#123; next:function()&#123; return &#123; value:o[ks[id++]], done:(idx&gt;ks.length); &#125; &#125; &#125; &#125; &#125;);//使用for..of遍历for(var v of myObject)&#123; console.log(v);&#125;//2//3 第4章 混合对象”类” 名词解释:类/继承描述了一种代码的组织结构形式–一种软件中对真实世界中问题领域的建模方法。 名词解释:多态指的是父类通用行为可以被子类用更特殊的行为重写 使用混入(mixin)来模拟类的复制行为 显示混入 缺点:使用显式伪多态会在所有需要使（伪）多态引用的地方创建一个函数关联， 这会极大地增加维护成本;对象引用被修改时(如:给数组添加新元素)，函数 1234567891011121314151617181920212223242526272829303132//也可以全复制，在掩盖。function mixin(sourceObj,targetObj)&#123; for(var key in sourceObj)&#123; //只会在不存在的情况下复制 if(!(key in targetObj))&#123; targetObj[key] = sourceObj[key]; &#125; &#125; return targetObj;&#125;var Vehicle = &#123; engines:1, ignition:function()&#123; console.log(\"Turning on my engine.\"); &#125; drive:function()&#123; this.ignition(); console.log(\"Steering and moving forward!\"); &#125;&#125;;var Car = mixin(Vehicle,&#123; wheels:4, drive:function()&#123; //这里实现了多态 Vehicle.drive.call(this); console.log( \"Rolling on all\"+this.wheels+\" wheels!\" ); &#125; &#125;) 寄生继承 1234567891011121314151617181920212223242526272829//\"传统的JavaScript类\"Vehiclefunction Vehicle()&#123; this.engines = 1;&#125;Vehicle.prototype.ignition = function()&#123; console.log(\"Turning on my engine.\");&#125;;Vehicle.prototype.drive = function()&#123; this.ignition(); console.log(\"Steering and moving forward!\");&#125;;//\"寄生类\"Carfunction Car()&#123; //首先,car是一个Vehicle var car = new Vehicle(); //接着我们对car进行定制 car.wheels = 4; var vehDrive = car.drive; //重写Vehicle::drive() car.drive = function()&#123; vehDrive.call(this); console.log(\"Rolling on all \"+this.wheels+\" wheels!\"); &#125;&#125;var myCar = new Car();myCar.drive(); 隐式混入 1234567891011121314151617181920212223//解决了显示混入对象共享的问题var Something = &#123; cool:function()&#123; this.array = [1,2,3]; this.count = this.count ? this.count + 1 : 1; &#125;&#125;;Something.cool();Something.array.push(4);Something.array;//[1,2,3,4]Something.count;//1var Another = &#123; cool:function()&#123; //隐式把Something混入Another Something.cool.call(this); &#125;&#125;;Another.cool();Another.array;//[1,2,3]Another.count;//1 (count不是共享状态) 混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法 第5章 原型 所有普通(内置，不是特定的主机的扩展)的[[Prototype]]链最终都会指向内置的Object.prototype 属性只存在于对象原型链上层时: 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性并且没有被标记为只读（writable:true），那就会直接在myObject中添加一个名为foo的新属性， 它是屏蔽属性。 如果在 [[Prototype]]链上层存在foo，但是它被标记为只读（writable:false）， 那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。 否则,这条赋值语句会被忽略。 总之,不会发生屏蔽。 如果在 [[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个 setter。 foo 不会被添加到（ 或者说屏蔽于）myObject，也不会重新定义foo 这个 setter。 如果你希望在第二种和第三种情况下也屏蔽foo,那就不能使用 = 操作符来赋值，而是使用Object.defineProperty(..)来向myObject添加foo 原型是在调用new Foo()时创建的，最后被关联到这个”Foo.prototype”,以及返回的对象的prototype上。 对象上的constructor是来自原型链的 Foo.prototype的.constructor属性只是Foo函数在声明时的默认属性。 12345678function Foo()&#123;/*..*/&#125;Foo.prototype = &#123;&#125;;var a1 = new Foo();a1.constructor === Foo;//false//constuctor是Object.prototype的属性a1.constructor === Object;//true .constructor属性是一个可变(configurable)的、可修改(writable)的、不可枚举(enumerable)的属性 继承的方式 123456//ES6之前需要抛弃默认的Bar.prototype//需要重新绑定constructorBar.prototype = Object.create(Foo.prototype);//ES6开始可以直接修改现有的Bar.prototypeObject.setPrototypeOf(Bar.prototype,Foo.prototype); obj1.isPrototypeOf(obj2) 判断obj2整条原型链中是否存在obj1 Object.create(..)避免使用new的构造函数调用会生成.prototype和.constructor引用 模拟Object.create(..) 1234567if(!Object.create)&#123; Object.create = function(o)&#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125;&#125; 使用清晰的API命名委托(即调用的API为原型的方法) 1234567891011121314var anotherObject = &#123; cool:function()&#123; console.log(\"cool!\"); &#125;&#125;;var myObject = Object.create(anotherObject);myObject.doCool = function()&#123; //内部委托! this.cool();&#125;;//\"cool!\"myObject.doCool(); 第6章 行为委托 禁止互相委托,如果你把B关联到A然后试着把A关联到B,就会出错。 Chrome跟踪函数名的方法 123456789101112var Foo = &#123;&#125;;var a1 = Object.create(Foo);a1;//Object &#123;&#125;Object.defineProperty(Foo,\"constructor\",&#123; enumerable:false, value:function Gotcha()&#123;&#125; &#125;);a1;//Gotcha &#123;&#125; 面向对象和对象关联模型比较 面向对象模型 123456789101112131415161718//面向对象模型function Foo(who)&#123; this.me = who;&#125;Foo.prototype.identify = function()&#123; return \"I am \"+this.me;&#125;;function Bar(who)&#123; Foo.call(this,who);&#125;Bar.prototype = Object.create(Foo.prototype);Bar.prototype.speak = function()&#123; alert(\"Hello, \"+this.identify()+\".\");&#125;;var b1 = new Bar(\"b1\");var b2 = new Bar(\"b2\"); 使用对象模型图 使用关联模型图 对象关联模型 123456789101112131415161718192021//对象关联模型Foo = &#123; init:function(who)&#123; this.me = who; &#125; identify:function()&#123; return \"I am \"+this.me; &#125;&#125;;Bar = Object.create(Foo);Bar.speak = function()&#123; alert(\"Hello, \"+this.identify()+\".\");&#125;;var b1 = Object.create(Bar);b1.init(\"b1\");var b2 = Object.create(Bar);b2.init(\"b2\");b1.speak();b2.speak(); 关联风格思维模型 关联模型比对象模型更简洁(没有了类的模仿行为) 实例,创建UI控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/*=====使用类模式=====*///父类function Widget(width,height)&#123; this.width = width || 50; this.height = height || 50; this.$elem = null;&#125;Widget.prototype.render = function($where)&#123; if(this.$elem)&#123; this.$elem.css(&#123; width:this.width + \"px\", height:this.height + \"px\" &#125;).appendTo($where); &#125;&#125;;//子类function Button(width,height,label)&#123; //调用\"super\"构造函数 Widget.call(this,width,height); this.label = label || \"Default\"; this.$elem = $(\"&lt;button&gt;\").text(this.label);&#125;//让Button\"继承\"WidgetButton.prototype = Object.create(Widget.prototype);//重写render(..)Button.prototype.render = function($where)&#123; //\"super\"调用 Widget.prototype.render.call(this,$where); this.$elem.click(this.onClick.bind(this));&#125;;Button.prototype.onClick = function(evt)&#123; console.log(\"Button '\"+this.label+\"' clicked!\");&#125;$(document).ready(function()&#123; var $body = $(document.body); var btn1 = new Button(125,30,\"Hello\"), btn2 = new Button(150,40,\"World\"); btn1.render($body); btn2.render($body); &#125;)/*=====ES6 class=====*/class Widget&#123; constructor(width,height)&#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125; render($where)&#123; if(this.$elem)&#123; this.$elem.css(&#123; width:this.width + \"px\", height:this.height + \"px\" &#125;).appendTo($where); &#125; &#125;&#125;class Button extends Widget&#123; constructor(width,height,label)&#123; super(width,height); this.label = label || \"Default\"; this.$elem = $(\"&lt;button&gt;\").text(this.label); &#125; render($where)&#123; super($where); this.$elem.click(this.onClick.bind(this)); &#125; onClick(evt)&#123; console.log(\"Button '\"+this.label+\"' clicked!\"); &#125;&#125;$(document).ready(function()&#123; var $body = $(document.body); var btn1 = new Button(125,30,\"Hello\"), btn2 = new Button(150,40,\"World\"); btn1.render($body); btn2.render($body); &#125;)/*=====使用关联模式=====*/var Widget = &#123; init:function(width,height)&#123; this.width = width || 50; this.height = height || 50; this.$elem = null; &#125;, insert:function($where)&#123; if(this.$elem)&#123; this.$elem.css(&#123; width:this.width + \"px\", height:this.height + \"px\" &#125;).appendTo($where); &#125; &#125;&#125;;var Button = Object.create(Widget);Button.setup = function(width,height,label)&#123; //委托调用 this.init(width,height); this.label = label || \"Default\"; this.$elem = $(\"&lt;button&gt;\").text(this.label);&#125;;Button.build = function($where)&#123; //委托调用 this.insert($where); this.$elem.click(this.onClick.bind(this));&#125;;Button.onClick = function(evt)&#123; console.log(\"Button '\" + this.label + \"' clicked!\");&#125;;$(document).ready(function()&#123; var $body = $(document.body); var btn1 = Object.create(Button); btn1.setup(150,40,\"Hello\"); var btn2 = Object.create(Button); btn2.setup(150,40,\"World\"); btn1.build($body); btn2.build($body); &#125;) 关联模型将对象创建以及初始化分为两个步骤更加灵活(可以使用对象池放置对象，取出时再进行初始化。) 实例,控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/*=====使用类模型=====*///父类function Controller()&#123; this.errors = [];&#125;Controller.prototype.showDialog(title,msg)&#123; //给用户显示标题和消息&#125;;Controller.prototype.success = function(msg)&#123; this.showDialog(\"Success\",msg);&#125;;Controller.prototype.failure = function(err)&#123; this.errors.push(err); this.showDialog(\"Error\",err);&#125;;//子类function LoginController()&#123; Controller.call(this);&#125;//把子类关联到父类LoginController.prototype = Object.create(Controller.prototype);LoginController.prototype.getUser = function()&#123; return document.getElementById(\"login_username\").value;&#125;;LoginController.prototype.getPassword = function()&#123; return document.getElementById(\"login_password\").value;&#125;;LoginController.prototype.validateEntry = function(user,pw)&#123; user = user || this.getUser(); pw = pw || this.getPassword(); if(!(user &amp;&amp; pw))&#123; return this.failure(\"Please enter a username &amp; password!\"); &#125;else if(user.length &lt; 5)&#123; return this.failure(\"Password must be 5+ characters!\"); &#125; //如果执行到这里说明通过验证 return true;&#125;;//重写基础的failure()LoginController.prototype.failure = function(err)&#123; //\"super\"调用 Controller.prototype.failure.call( this, \"Login invalid: \" + err);&#125;//子类function AuthController(login)&#123; Controller.call(this); //合成 this.login = login;&#125;//把子类关联到父类AuthController.prototype = Object.create(Controller.prototype);AuthController.prototype.server = function(url,data)&#123; return $.ajax(&#123; url:url, data:data &#125;);&#125;;AuthController.prototype.checkAuth = function()&#123; var user = this.login.getUser(); var pw = this.login.getPassword(); if(this.login.validateEntry(user,pw))&#123; this.server(\"/check-auth\",&#123; user:user, pw:pw &#125;) .then(this.success.bind(this)) .fail(this.failure.bind(this)); &#125;&#125;;//重写基础的success()AuthController.prototype.success = function()&#123; //\"super\"调用 Controller.prototype.success.call(this,\"Authenticated!\");&#125;//重写基础的failure()AuthController.prototype.failure = function(err)&#123; //\"super\"调用 Controller.prototype.failure.call(err)&#123; this, \"Auth Failed: \" + err &#125;;&#125;;var auth = new AuthController();auth.checkAuth( //除了继承、我们还需要合成 new LoginController());/*=====使用关联模型=====*/var LoginController = &#123; errors:[], getUser:function()&#123; return document.getElementById(\"login_username\").value; &#125;, getPassword:function()&#123; return document.getElementById(\"login_password\").value; &#125;, validateEntry:function(user,pw)&#123; user = user || this.getUser(); pw = pw || this.getPassword(); if(!(user &amp;&amp; pw))&#123; return this.failure(\"Please enter a username &amp; password!\"); &#125;else if(user.length &lt; 5)&#123; return this.failure(\"Password must be 5+ characters!\"); &#125; //如果执行到这里说明通过验证 return true; &#125;, showDialog:function(title,msg)&#123; //给用户显示标题和消息 &#125;, failure:function(err)&#123; this.errors.push(err); this.showDialog(\"Error\",\"Login invalid: \" + err); &#125;&#125;;//让AuthController委托LoginControllervar AuthController = Object.create(LoginController);AuthController.errors = [];AuthController.checkAuth = function()&#123; var user = this.getUser(); var pw = this.getPassword(); if(this.validateEntry(user,pw))&#123; this.server(\"/check-auth\",&#123; user:user, pw:pw &#125;) .then(this.accepted.bind(this)) .fail(this.rejected.bind(this)); &#125;&#125;;AuthController.server = function(url,data)&#123; return $.ajax(&#123; url:url, data:data &#125;);&#125;;AuthController.accepted = function()&#123; this.showDialog(\"Success\",\"Authenticated!\");&#125;;AuthController.rejected = function(err)&#123; this.failure(\"Auth Failed: \" + err);&#125;; 具名函数能够自我引用 12345678910111213141516var Foo = &#123; //匿名函数不能自我引用 bar:function(x)&#123; if(x &lt; 10)&#123; return Foo.bar(x * 2); &#125; return x; &#125;, //具名函数能够自我引用 baz:function baz()&#123; if(x &lt; 10)&#123; return baz(x * 2); &#125; return x; &#125;&#125; 附录A ES6中的Class class使用的是原型的机制(而不是函数复制)，即修改父类的方法子类会受到影响 12345678class C&#123; constructor()&#123; this.num = Math.random(); &#125; rand()&#123; console.log(\"Random: \" + this.num); &#125;&#125; 修改共有状态暴露了原型 123456789101112131415161718class C&#123; constructor()&#123; //确保修改的是共享状态而不是实例上创建的一个屏蔽属性! C.prototype.count++; &#125; //this.count 可以通过委托实现我们想要的功能 console.log(\"Hello: \" + this.count);&#125;//直接向prototype对象添加一个共享状态C.prototype.count = 0;var c1 = new C();//Hello:1var c2 = new C();//Hello:2c1.count === 2;//truec1.count === c2.count;//true super并不是动态绑定，它会在声明时静态绑定。 123456789101112131415161718192021222324252627282930class P&#123; foo()&#123;console.log(\"P.foo\");&#125;&#125;class C extends P&#123; foo()&#123; super(); &#125;&#125;var c1 = new C();c1.foo();//\"P.foo\"var D = &#123; foo:function()&#123;console.log(\"D.foo\");&#125;&#125;;var E = &#123; foo:C.prototype.foo&#125;;//把E委托到DObject.setPrototypeOf(E,D);E.foo();//\"P.foo\"不是\"D.foo\"//手动绑定superE.foo = C.prototype.foo.toMethod(E,\"foo\");E.foo();//\"D.foo\"","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"CSS揭秘","date":"2016-12-28T01:27:16.107Z","path":"2016/12/28/css揭秘/","text":"css揭秘第1章 引言Web标准:是敌还是友 W3C 并不“生产”标准。 实际上， 它扮演的是一个论坛的角色： W3C以工作组的方式， 把某项技术的相关各方聚集起来， 最终由他们来产出标准 CSS规范通常是由CSS工作组的成员来编写的 88%来自W3C会员公司的成员(比如浏览器厂商、主流网站、研究机构、常规技术公司等) 7%特邀专家 5%W3C工作人员 CSS工作组坚持透明原则，它内部所有的交流都是公开的，并邀请公众的关注和参与。 绝大多数的讨论都发生在工作组的邮件列表中:www-style(http://lists.w3.org/Archives/Public/www-style)。这个邮件列表是公开存档的，欢迎任何人的参与。 每周都会召开一次电话会议，会议记录会在几天内整理出来，并发布到邮件列表中。 每季度一次的面对面会议，也会记录下来。 规范从最初启动到最终成熟 编辑草案(ED) 收个公开工作草案(FPWD) 工作草案(WD):浏览器从此处开始实行规范 候选推荐规范(CR):提出稳定版本 提名推荐规范(PR):最后提出反对意见的机会 正式推荐规范(REC) CSS2后将规范分到独立的各个模块中,如:CSS语法、CSS层叠与继承、CSS颜色… 如果某个模块是前所未有的概念，那么版本号从1开始，即使是CSS3中的定义 CSS编码技巧 难以修改的CSS代码 字体与行高相互依赖，改变字体必定要改变行高 如果改变父级字体大小也得改变字体大小 只能用于一种颜色的色调上 1234567891011.test&#123;padding:6px 16px;border:1px solid red;background:#50a linear-gradient (#77a0bb,#58a);border-radius:4px;box-shadow:0 1px 5px gray;color:white;text-shadow: 0 -1px 1px #335166;font-size: 20px;line-height: 30px;&#125; 易随环境变化而变化的CSS代码 12345678910111213.test&#123;padding: .3em .8em;/*使用em单位，可以随着字号进行缩放*/border: 1px solid #446d88;/*对于不同颜色的按钮都能启到效果*/background: #58a linear-gradient(hsla(0,0%,100%,.2),transparent);border-radius: .2em;box-shadow: 0 .05em .25em rgba(0,0,0,.5);color: white;/*将半透明的黑色或白色叠加在主色调上，即可产生主色调的亮色和暗色变体*/text-shadow: 0 -.05em .05em rgba(0,0,0,.5);font-size: 125%;/*随父级改变而改变，假设父级字号是16px*/line-height: 1.5;/*随字号改变而改变*/&#125; currentColor很多颜色的初始值 12345/*使&lt;hr&gt;元素自动与文本的颜色保持一致*/hr&#123; height:.5em; background:currentColor;&#125; inherit总是绑定到父元素的计算值(对伪元素来说，则会取生成该伪元素的宿主元素) 1234567891011121314/*提示框的设计*/.callout&#123;position:relative;&#125;.callout::before &#123; content: \"\"; position: absolute; top: -.4em; left: 1em; padding: .35em; background: inherit;/*提示框的小箭头的颜色和框相同*/ border: inherit; border-right: 0; border-bottom: 0; transform: rotate(45deg);&#125; 相信眼睛，而不是数字 媒体查询应作为最终修复手段，因为媒体查询能做的只是修补某个特定分辨率下的问题，而不是连续的方式来修复问题。 媒体查询的断点不应该由具体的设备来决定,而应该根据设计自身来决定。 减小媒体查询的建议 合理使用简写 123456.test&#123; /*保证得到纯色背景*/ background:rebeccapurple; /*背景可能为background-image的设置*/ background-color:rebeccapurple;&#125; 名词解释:DRY,避免重复代码 123456789101112131415.test&#123; background:url(tr.png) no-repeat top right / 2em 2em, /*使用/避免与background-position产生歧义 */ url(br.png) no-repeat bottom right / 2em 2em, url(bl.png) no-repeat bottom left / 2em 2em,&#125;/*减少重复代码，使代码更加DRY*/.test&#123; background: url(tr.png) top right, url(br.png) bottom right, url(bl.png) bottom left; background-size: 2em 2em; background-repeat: no-repeat;&#125; 背景图之间的层叠关系 原生CSS变量使用 1234/*无序列表背景为purple,有序列表为rebeccapurple*/ul&#123;--accent-color:purple;&#125;ol&#123;--accent-color:rebeccapurple;&#125;li&#123;background:val(--accent-color);&#125; 第2章 背景与边框半透明边框1234567.test&#123; /*设置半透明边框*/ border: 10px solid hsla(0,0%,100%,.5); background: white; /*背景从内边距开始裁切,从而不遮挡半透明边框*/ background-clip: padding-box;&#125; 多重边框 使用box-shadow制作多重边框 投影不影响布局，也不会受到box-sizing属性的影响。 假边框不会触发元素click事件,可以通过给box-shadow属性加inset关键字，使棋绘制在元素内圈。 123456.test&#123; background:yellowgreen; box-shadow:0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 15px 15px rgba(0,0,0,.6);&#125; 使用outline制作两重边框 123456.test&#123; background: yellowgreen; border: 10px solid #655; /*可以设置为负值,在元素内部产生一个边框*/ outline:-5px solid deeppink;&#125; 灵活的背景定位 使用background-position 1234567.test&#123; /*回退方案,确保在不支持background-position属性的浏览器不会将图片定位到左上角*/ background: url(code-pirate.svg) no-repeat bottom right #58a; /*定位图片距离右方20px,下方10px*/ background-position: right 20px bottom 10px;&#125; background-origin设定背景对应的矩形的基准(padding-box默认、content-box、border-box) 12345.test&#123; padding:10px; background:url(\"code-pirate.svg\") no-repeat #58a bottom right; background-origin:content-box;&#125; 使用calc() 12345.test&#123; background: url(\"code-pirate.svg\") no-repeat; /*设定图片距离右边20px,距离底部10px*/ background-position: calc(100% - 20px) calc(100% - 10px);&#125; 边框内圆角 在元素外在嵌套一个div 使用描边outline 123456789.test&#123; background:tan; border-radius:.8em; padding:1em; /*填补描边的空隙,跟着圆角走*/ box-shadow:0 0 0 .5em #655; /*描边效果不跟边框形状走，可能被W3C修复*/ outline:.6em solid #655;&#125; box-shadow大小计算图解 条纹背景 水平条纹背景 12345.test&#123; /*第2个色标位置值设置为0，则位置被浏览器调整为前一个色标的位置值*/ background:linear-gradient(#fb3 33.3%,#58a 0, #58a 66.6%, yellowgreen 0); background-size:100% 30px;&#125; 垂直条纹 12345.test&#123; background: linear-gradient(to right, /* 或 90deg */ #fb3 50%, #58a 0); background-size: 30px 100%;&#125; 45度斜向条纹 1234.test&#123;background: linear-gradient(45deg,#fb3 25%, #58a 0, #58a 50%,#fb3 0, #fb3 75%,#58a 0);background-size: 42.426406871px 42.426406871px;&#125; 任意角度的斜向条纹 12345.test&#123; /*repeating-linear-gradient重复条纹直到铺满整个屏幕*/ background: repeating-linear-gradient(60deg, #fb3, #fb3 15px, #58a 0, #58a 30px)&#125; 灵活的同色系条纹 1234567.test&#123; background: #58a;background-image: repeating-linear-gradient(30deg,hsla(0,0%,100%,.1),hsla(0,0%,100%,.1) 15px,transparent 0, transparent 30px);&#125; 复杂的背景图案 网格 123456789101112.test&#123; background: #58a; background-image: linear-gradient(white 2px, transparent 0), linear-gradient(90deg, white 2px, transparent 0), linear-gradient(hsla(0,0%,100%,.3) 1px, transparent 0), linear-gradient(90deg, hsla(0,0%,100%,.3) 1px, transparent 0); background-size: 75px 75px, 75px 75px, 15px 15px, 15px 15px;&#125; 波点 1234567.test&#123; background: #655;background-image: radial-gradient(tan 30%, transparent 0),radial-gradient(tan 30%, transparent 0);background-size: 30px 30px;background-position: 0 0, 15px 15px&#125; Tips:如果处于可读性考虑，需要把一句CSS代码打断为多行，只需要用反斜杠\\来转义每行末尾的换行就可以了。 伪随机背景123456789.test&#123; background: hsl(20, 40%, 90%); background-image: linear-gradient(90deg, #fb3 11px, transparent 0), linear-gradient(90deg, #ab4 23px, transparent 0), linear-gradient(90deg, #655 41px, transparent 0); /*41,61,83都为质数,则渐变背景的重复点为41*61*83*/ background-size: 41px 100%, 61px 100%, 83px 100%;&#125; 连续的图像边框 使用两个元素一个设置背景，一个设置纯白背景覆盖。(背景可以适应伸缩性) 使用background 1234567891011.test&#123; padding: 1em;border: 1em solid transparent;background: linear-gradient(white, white) padding-box,repeating-linear-gradient(-45deg,red 0, red 12.5%,transparent 0, transparent 25%,#58a 0, #58a 37.5%,transparent 0, transparent 50%)0 / 5em 5em;&#125; 使用border-image: 每当border-image-slice改变时,都需要同时修改border-width 不能再border-image-slice属性使用em单位,只能把边框厚度指定为像素单位 条纹的宽度需要在色标的位置信息中写好,因此我们在改变条纹宽度时，需要修改四处。 第3章 形状自适应的椭圆 当任意两个相邻圆角的半径之和超过border box的尺寸时,用户代理必须按比例减小各个边框半径所用的值，直到他们不会互相重叠为止。 获得自适应的椭圆或圆(设置圆角半径的值为百分比) 123.test&#123; border-radius:50%;&#125; border-radius是对元素border box的切圆角处理,元素没有边框的时候看不出来区别 border-radius是四个角的简写top-left,top-right,bottom-right,bottom-left(即顺时针的形式) 10px / 5px 20px 相当于:10px 10px 10px 10px / 5px 20px 5px 20px border-radius简写 四分之一椭圆 123.test&#123; border-radius:100% 0 0 0;&#125; 平行四边形 平行四边形其实是矩形的超集，它的各条边是两辆平行的,但各个角则不一定都是直角 平行四边形往往可以传达出一种动感。 使用嵌套元素方案产生平行四边形 12345678&lt;a href=\"#yolo\" class=\"button\"&gt; &lt;div&gt;Click me&lt;/div&gt;&lt;/a&gt;&lt;style&gt; .button&#123;transform: :skewX(-45deg);&#125; .button &gt; div&#123;transform:skewX(45deg);&#125;&lt;/style&gt; 使用伪元素 123456789101112.button &#123;position: relative;/* 其他的文字颜色、内边距等样式…… */&#125;.button::before &#123;content: ''; /* 用伪元素来生成一个矩形 */position: absolute;top: 0; right: 0; bottom: 0; left: 0;z-index: -1;background: #58a;transform: skew(45deg);&#125; 还可以用该技巧实现 边框内圆角 给某一层”背景”单独设置opacity这样的属性 多重虚线边框等样式 菱形图片 基于变形的方案 12345678910111213141516&lt;div class=\"picture\"&gt; &lt;img src=\"adam-catlace.jpg\" alt=\"...\"&gt;&lt;/div&gt;&lt;style&gt;.picture &#123; width: 400px; transform: rotate(45deg); overflow: hidden;&#125;.picture &gt; img &#123; /*图片旋转后最大的宽度要等于对角线的长度,因此应该放大1.42倍*/ max-width: 100%; transform: rotate(-45deg) scale(1.42);&#125;&lt;/style&gt; 裁切路径方案(使用属性clip-path和函数polygon) 123456789img &#123;clip-path: polygon(50% 0, 100% 50%,50% 100%, 0 50%);transition: 1s clip-path;&#125;img:hover &#123;clip-path: polygon(0 0, 100% 0,100% 100%, 0 100%);&#125; 切角效果 使用渐变 123456789101112131415/*产生4个角的切角效果*/.test&#123;background: #58a;background:linear-gradient(135deg, transparent 15px, #58a 0)top left,linear-gradient(-135deg, transparent 15px, #58a 0)top right,linear-gradient(-45deg, transparent 15px, #58a 0)bottom right,linear-gradient(45deg, transparent 15px, #58a 0)bottom left;background-size: 50% 50%;background-repeat: no-repeat;&#125; 使用SCSS建立可维护的代码 123456789101112131415161718@mixin beveled-corners($bg,$tl:0, $tr:$tl, $br:$tl, $bl:$tr) &#123;background: $bg;background:linear-gradient(135deg, transparent $tl, $bg 0)top left,linear-gradient(225deg, transparent $tr, $bg 0)top right,linear-gradient(-45deg, transparent $br, $bg 0)bottom right,linear-gradient(45deg, transparent $bl, $bg 0)bottom left;background-size: 50% 50%;background-repeat: no-repeat;&#125;/*引用，传入2~5个参数*/@include beveled-corners(#58a,15px,5px); 弧形切角–使用径向渐变 1234567891011121314.test&#123;background: #58a;background:radial-gradient(circle at top left,transparent 15px, #58a 0) top left,radial-gradient(circle at top right,transparent 15px, #58a 0) top right,radial-gradient(circle at bottom right,transparent 15px, #58a 0) bottom right,radial-gradient(circle at bottom left,transparent 15px, #58a 0) bottom left;background-size: 50% 50%;background-repeat: no-repeat;&#125; 内联SVG与border-image方案 1234567891011121314.test&#123;/*只需要改变边框大小就能改变切角大小*//*将背景定义为#58a,在不支持barder-image的地方能够平稳退化为普通矩形*/border: 20px solid #58a;/*1对应的是SVG文件的坐标系统*/border-image: 1 url('data:image/svg+xml,\\&lt;svg xmlns=\"http://www.w3.org/2000/svg\"\\width=\"3\" height=\"3\" fill=\"%2358a\"&gt;\\&lt;polygon points=\"0,1 1,0 2,0 3,1 3,2 2,3 1,3 0,2\"/&gt;\\&lt;/svg&gt;');background: #58a;/*避免背景色蔓延到边框区域*/background-clip: padding-box;&#125; 切角使用的SVG图和效果图 裁切路径方案 优点:能够适应任意背景 缺点:内边距不够时会裁切掉文本 12345678.test&#123;background: #58a;clip-path: polygon(20px 0, calc(100% - 20px) 0, 100% 20px,100% calc(100% - 20px), calc(100% - 20px) 100%,20px 100%, 0 calc(100% - 20px), 0 20px);&#125; 梯形标签页 使用CSS的3D旋转来模拟效果 缺点:斜边角度依赖于元素宽度 123456789101112131415161718.tab &#123;position: relative;display: inline-block;padding: .5em 1em .35em;color: white;&#125;.tab::before &#123;content: ''; /* 用伪元素来生成一个矩形 */position: absolute;top: 0; right: 0; bottom: 0; left: 0;z-index: -1;background: #58a;/*放大Y轴，弥补旋转时造成的缩小,并且在不支持该属性的浏览器上能平稳退化*/transform: scaleY(1.3) perspective(.5em)rotateX(5deg);/*以底边作为转轴，增加使底边不至于变宽*/transform-origin: bottom;&#125; 简单的饼图 基于transform,进度指示器 1234567891011121314151617181920212223@keyframes spin &#123;to &#123; transform: rotate(.5turn); &#125;&#125;/*超过50%需要变色，即与前50%看成是两种情况*/@keyframes bg &#123;50% &#123; background: #655; &#125;&#125;.pie &#123;width: 100px; height: 100px;border-radius: 50%;background: yellowgreen;&#125;.pie::before &#123;content: '';display: block;margin-left: 50%;height: 100%;border-radius: 0 100% 100% 0 / 50%;background-color: inherit;transform-origin: left;animation: spin 3s linear infinite,bg 6s step-end infinite;&#125; CSS动画一个负的延时值是合法的,相当于动画直接暂停在延时值的绝对值处 运用动画产生饼图 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div class=\"pie\" style=\"animation-delay: -20s\"&gt;&lt;/div&gt;&lt;div class=\"pie\" style=\"animation-delay: -60s\"&gt;&lt;/div&gt;&lt;style&gt;.pie &#123;position: relative;width: 100px;/*设置行高相当于设置了高度*/line-height: 100px;border-radius: 50%;background: yellowgreen;background-image:linear-gradient(to right, transparent 50%, #655 0);color: transparent;text-align: center;&#125;@keyframes spin &#123;to &#123; transform: rotate(.5turn); &#125;&#125;@keyframes bg &#123;50% &#123; background: #655; &#125;&#125;.pie::before &#123;content: '';/*使用绝对定位防止把文字挤到其他行*/position: absolute;top: 0; left: 50%;width: 50%; height: 100%;border-radius: 0 100% 100% 0 / 50%;background-color: inherit;transform-origin: left;animation: spin 50s linear infinite,bg 100s step-end infinite;animation-play-state: paused;animation-delay: inherit;&#125;&lt;/style&gt;&lt;script&gt;$$('.pie').forEach(function(pie) &#123; var p = parseFloat(pie.textContent); pie.style.animationDelay = '-' + p + 's';&#125;);&lt;/script&gt; SVG方案 增加第三种颜色非常容易,增加另一个圆形，并设置虚线描边，在用stroke-dashoffset来推后描边线段的起始位置即可 可以通过内联样式指定颜色，意味着可以很容易通过脚本控制颜色 1234567891011121314151617181920212223&lt;!-- 使用viewBox,使得svg能够自适应容器大小 --&gt;&lt;svg viewBox=\"0 0 32 32\"&gt; &lt;!-- 圆周为100时半径为16 --&gt; &lt;circle r=\"16\" cx=\"16\" cy=\"16\"&gt;&lt;/circle&gt;&lt;/svg&gt;&lt;style&gt;/*svg也是HTML元素,将SVG设置为一个稍大的圆,将circle超出的描边裁切掉,并把描边转到起始处*/svg &#123;width: 100px; height: 100px;transform: rotate(-90deg);background: yellowgreen;border-radius: 50%;&#125;circle &#123;fill: yellowgreen;stroke: #655;stroke-width: 32;/*表示描边长度为38,间隙为100的宽度*/stroke-dasharray: 38 100; /* 可得到比率为38%的扇区 */&#125;&lt;/style&gt; 使用SVG+JS动态生成饼图 12345678910111213141516171819202122&lt;div class=\"pie\"&gt;20%&lt;/div&gt;&lt;div class=\"pie\"&gt;60%&lt;/div&gt;&lt;script&gt; $$('.pie').forEach(function(pie) &#123; var p = parseFloat(pie.textContent); var NS = \"http://www.w3.org/2000/svg\"; var svg = document.createElementNS(NS, \"svg\"); var circle = document.createElementNS(NS, \"circle\"); var title = document.createElementNS(NS, \"title\"); circle.setAttribute(\"r\", 16); circle.setAttribute(\"cx\", 16); circle.setAttribute(\"cy\", 16); circle.setAttribute(\"stroke-dasharray\", p + \" 100\"); svg.setAttribute(\"viewBox\", \"0 0 32 32\"); title.textContent = pie.textContent; pie.textContent = ''; svg.appendChild(title); svg.appendChild(circle); pie.appendChild(svg); &#125;);&lt;/script&gt; 第4章 视觉效果单侧投影 单侧投影 123.test&#123; box-shadow:0 5px 4px -4px black;&#125; 双侧投影 1234.test&#123; box-shadow:5px 0 5px -5px black, -5px 0 5px -5px black;&#125; 不规则投影 使用滤镜 drop-shadow()滤镜可接收的参数基本上跟box-shadow属性一样 1234.test&#123; filter: url(drop-shadow.svg#drop-shadow); filter: drop-shadow(2px 2px 10px rgba(0,0,0,.5));&#125; 染色方案 基于滤镜的方案 sepia:给图片增加一种降饱和度的橙黄色染色效果,几乎所有像素的色相值会被收敛到35~40 saturate:滤镜来给每个像素提升饱和度 hue-rotate:把每个像素的色相以指定的度数进行偏移 12345678img &#123;transition: .5s filter;filter: sepia(1) saturate(4) hue-rotate(295deg);&#125;img:hover,img:focus &#123;filter: none;&#125; 基于混合模式的方案 把图片包裹在一个容器中,并把容器的背景设置为我们想要的主色调。 不用图片元素，而是用&lt; div&gt;元素——把这个元素的第一层背景设置为要染色的图片,并把第二层的背景设置为我们想要的主色调。 1234567891011121314151617181920/*法1:包裹图片*/a &#123;background: hsl(335, 100%, 50%);&#125;img &#123;mix-blend-mode: luminosity;&#125;/*法2:使用一个div元素，设置多重背景*/.tinted-image &#123;width: 640px; height: 440px;background-size: cover;background-color: hsl(335, 100%, 50%);background-blend-mode: luminosity;transition: .5s background-color;&#125;.tinted-image:hover &#123; /*设置为透明不产生混合效果*/background-color: transparent;&#125; 毛玻璃效果 使用滤镜blur 12345678910111213141516171819202122232425262728293031323334&lt;boldy&gt; &lt;main&gt; &lt;blockquote&gt; \"The only way to get rid of a temptation[...]\" &lt;footer&gt;－ &lt;cite&gt; Oscar Wilde, The Picture of Dorian Gray &lt;/cite&gt; &lt;/footer&gt; &lt;/blockquote&gt; &lt;/main&gt;&lt;/boldy&gt;&lt;style&gt;body, main::before &#123; /*/起到了将背景设置在宽度100%、高度自适应(整个显示屏)，元素位置的那一部分*/background: url(\"tiger.jpg\") 0 / cover fixed;&#125;main &#123;position: relative;background: hsla(0,0%,100%,.3);/*消除超出范围的滤镜效果*/overflow: hidden;&#125;main::before &#123;content: '';position: absolute;top: 0; right: 0; bottom: 0; left: 0;filter: blur(20px);/*为了使得整个元素都覆盖上效果*/margin: -30px;&#125; &lt;/style&gt; 折角效果 使用渐变色(45度角的实现) 123456789.test&#123; background: #58a; /* 回退样式 */ background: linear-gradient(to left bottom, transparent 50%, rgba(0,0,0,.4) 0) no-repeat 100% 0 / 2em 2em, linear-gradient(-135deg, transparent 1.5em, #58a 0);&#125; 任意角度的实现 12345678910111213141516171819202122.note &#123;position: relative;background: #58a; /* 回退样式 */background:linear-gradient(-150deg,transparent 1.5em, #58a 0);border-radius: .5em;&#125;.note::before &#123;content: '';position: absolute;top: 0; right: 0;background: linear-gradient(to left bottom,transparent 50%, rgba(0,0,0,.2) 0, rgba(0,0,0,.4))100% 0 no-repeat;width: 1.73em;height: 3em;transform: translateY(-1.3em) rotate(-30deg);transform-origin: bottom right;border-bottom-left-radius: inherit;box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.15);&#125; SASS代码 12345678910111213141516171819202122232425262728@mixin folded-corner($background, $size,$angle: 30deg) &#123;position: relative;background: $background; /* 回退样式 */background:linear-gradient($angle - 180deg,transparent $size, $background 0);border-radius: .5em;$x: $size / sin($angle);$y: $size / cos($angle);&amp;::before &#123;content: '';position: absolute;top: 0; right: 0;background: linear-gradient(to left bottom,transparent 50%, rgba(0,0,0,.2) 0,rgba(0,0,0,.4)) 100% 0 no-repeat;width: $y; height: $x;transform: translateY($y - $x)rotate(2*$angle - 90deg);transform-origin: bottom right;border-bottom-left-radius: inherit;box-shadow: -.2em .2em .3em -.1em rgba(0,0,0,.2);&#125;&#125;/* 当调用时... */.note &#123;@include folded-corner(#58a, 2em, 40deg);&#125; 第5章 字体排印连字符断行 使用hyphens产生断行效果 12345.test&#123; /*为了确保奏效，需要在HTML标签的lang属性中指定合适的语言。*/ /*仍可以使用软连字符$shy;,hyphens属性会优先处理它们*/ hyphens:auto;&#125; 插入换行 自定义列表根据dt换行 1234567891011dd,dt&#123;display:inline;&#125;dd + dt::before &#123;content: '\\A';white-space: pre;&#125;dd + dd::before &#123;content: ', ';/*消除两个dd之间的空白符*/margin-left:-.25em;font-weight: normal;&#125; 文本行的斑马条纹123456789.test&#123; padding: .5em; line-height: 1.5; background: beige; background-size: auto 3em; background-origin: content-box; background-image: linear-gradient(rgba(0,0,0,.2) 50%, transparent 0);&#125; 调整tab的宽度 使用tab-size可以调整tab符的宽度,pre标签中默认宽度为8 连字12345.test&#123; font-variant-ligatures:common-ligatures no-discretionary-ligatures no-historical-ligatures; &#125; 关闭连字使用font-variant-ligatures:none; 开启连字使用font-variant-ligatures:normal; 华丽的&amp;符号 如果某款字体可用,但仅包括某几个字符,那它就只会用来显示这几个字符;而在显示其他字符时，浏览器就会回退到其他字体,这个规则对本地字体和通过@font-face规则引入的嵌入字体都是有效的; 使用字体回退规则可以给某几个字符设置专用的字体 1234567891011121314151617181920@font-face&#123; font-family:Ampersand; src:url(\"fonts/ampersand.woff\");&#125;h1&#123; font-family:Ampresand,Helvetica,sans-serif;&#125;/*@font-face指定某个字符*/@font-face&#123; font-family:Ampersand; /*指定字体的斜体版本*/ src:local('Baskerville-Italic'), local('GoudyOldStyle-Italic'), local('Palatino-Italic'), local('BookAntiqua-Italic'); /*其他写法(多个区间用逗号隔开):U+4??,U+2665-2670*/ unicode-range:U+20;&#125; 自定义下划线 使用background生成灵活的下划线 123456.test&#123; background: linear-gradient(90deg, gray 66%, transparent 0) repeat-x; background-size: .2em 2px; background-position: 0 1em;&#125; 使用text-shadow来防止下划线穿过文本的降部(文本需为实色背景) 123456.test&#123; background: linear-gradient(gray, gray) no-repeat;background-size: 100% 1px;background-position: 0 1.15em;text-shadow: .05em 0 white, -.05em 0 white;&#125; 现实中的文字效果 凸版印刷效果 原理:出现在底部的浅色投影（ 或者出现在顶部的暗色投影） 会让人产生物体是凹进平面内的错觉。同理，出现在底部的暗色投影（或者出现在顶部的浅色投影）会让人产生物体从平面上凸起的错觉。 12345.test&#123;background: hsl(210, 13%, 60%);color: hsl(210, 13%, 30%);text-shadow: 0 .03em .03em hsla(0,0%,100%,.8);&#125; 空心字效果(比起使用text-shadow效果、性能更好) 1234567891011121314151617181920&lt;h1&gt;&lt;svg width=\"2em\" height=\"1.2em\"&gt; &lt;use xlink:href=\"#css\" /&gt; &lt;text id=\"css\" y=\"1em\"&gt;CSS&lt;/text&gt;&lt;/svg&gt;&lt;/h1&gt;&lt;style&gt;h1&#123;font: 500%/1 Rockwell, serif;background: deeppink;color: white;&#125;h1 text &#123;fill: currentColor;&#125;h1 svg &#123; overflow: visible &#125;h1 use &#123;stroke: black;stroke-width: 6;stroke-linejoin: round;&#125;&lt;/style&gt; 文字外发光效果 使用text-shadow实现 使用模糊滤镜blur()实现 123456789101112131415161718/*使用text-shadow实现*/a &#123;background: #203;color: white;transition: 1s;&#125;a:hover &#123;text-shadow: 0 0 .1em, 0 0 .3em;&#125;/*使用blur()滤镜实现*/a &#123;background: #203;color: white;transition: 1s;&#125;a:hover &#123;filter: blur(.1em);&#125; 文字凸起效果 思路:使用一长串累加的投影,不设模糊并以1px的跨度逐渐错开，使颜色逐渐变暗，然后在底部加一层强烈模糊的暗投影， 从而模拟完整的立体效果。 12345678910111213141516171819202122232425.test&#123; background: #58a;color: white;text-shadow: 0 1px hsl(0,0%,85%),0 2px hsl(0,0%,80%),0 3px hsl(0,0%,75%),0 4px hsl(0,0%,70%),0 5px hsl(0,0%,65%),0 5px 10px black;&#125;/*SCSS代码*/@mixin text-3d($color: white, $depth: 5) &#123;$shadows: ();$shadow-color: $color;@for $i from 1 through $depth &#123;$shadow-color: darken($shadow-color, 10%);$shadows: append($shadows,0 ($i * 1px) $shadow-color, comma);&#125;color: $color;text-shadow: append($shadows,0 ($depth * 1px) 10px black, comma);&#125;h1 &#123; @include text-3d(#eee, 4); &#125; 环形文字123456789101112131415161718192021&lt;div class=\"circular\"&gt;&lt;svg viewBox=\"0 0 100 100\"&gt;&lt;path d=\"M 0,50 a 50,50 0 1,1 0,1 z\"id=\"circle\" /&gt;&lt;text&gt;&lt;textPath xlink:href=\"#circle\"&gt;circular reasoning works because&lt;/textPath&gt;&lt;/text&gt;&lt;/svg&gt;&lt;/div&gt;&lt;style&gt; .circular path &#123; fill: none; &#125; .circular &#123; width: 30em; height: 30em; &#125; .circular svg &#123; display: block; overflow: visible; &#125;&lt;/style&gt; 使用JS直接生成 123456789101112131415161718192021222324&lt;div class=\"circular\"&gt;circular reasoning works because&lt;/div&gt;&lt;script&gt;$$('.circular').forEach(function(el) &#123;var NS = \"http://www.w3.org/2000/svg\";var xlinkNS = \"http://www.w3.org/1999/xlink\";var svg = document.createElementNS(NS, \"svg\");var circle = document.createElementNS(NS, \"path\");var text = document.createElementNS(NS, \"text\");var textPath = document.createElementNS(NS, \"textPath\");svg.setAttribute(\"viewBox\", \"0 0 100 100\");circle.setAttribute(\"d\", \"M0,50 a50,50 0 1,1 0,1z\");circle.setAttribute(\"id\", \"circle\");textPath.textContent = el.textContent;textPath.setAttributeNS(xlinkNS, \"xlink:href\", \"#circle\");text.appendChild(textPath);svg.appendChild(circle);svg.appendChild(text);el.textContent = '';el.appendChild(svg);&#125;);&lt;/script&gt; 第6章 用户体验选择合适的鼠标光标 将光标隐藏 1234.test&#123;cursor: url('transparent.gif');cursor: none;&#125; 扩大可点击区域 使用透明边框方案 1234567.test&#123;border: 10px solid transparent;/*使用内阴影代替边框效果*//*使用外阴影时会产生怪异效果,因为透明边框也会被阴影投射*/box-shadow: 0 0 0 1px rgba(0,0,0,.3) inset;background-clip: padding-box;&#125; 使用伪元素方案 12345678button&#123; position:relative;&#125;button:before&#123; content:''; position:absolute; top:-10px;right:-10px;bottom:-10px;left:-10px;&#125; 自定义复选框 伪类选择符:checked会根据用户的交互进行更新,[checked]不会根据用户的交互进行更新 名词解释:“替换元素的特征在于， 其内容超出了 CSS 格式化模型的范畴， 比如图片、 嵌入的文档或小应用程序等。”原则上我们无法为替换元素添加生成性内容。复选框元素是替换元素 原理使用label代替复选框元素 12345678910111213141516171819202122&lt;input type=\"checkbox\" id=\"awesome\" /&gt;&lt;label for=\"awesome\"&gt;Awesome!&lt;/label&gt;&lt;style&gt; input[type=\"checkbox\"] + label::before &#123; content: '\\a0'; /* 不换行空格 */ display: inline-block; vertical-align: .2em; width: .8em; height: .8em; margin-right: .2em; border-radius: .2em; background: silver; text-indent: .15em; line-height: .65; &#125; input[type=\"checkbox\"]:checked + label::before &#123; content: '\\2713'; background: yellowgreen; &#125;&lt;/style&gt; 开关式按钮 123456789101112131415161718192021input[type=\"checkbox\"] &#123;position: absolute;clip: rect(0,0,0,0);&#125;input[type=\"checkbox\"] + label &#123;display: inline-block;padding: .3em .5em;background: #ccc;background-image: linear-gradient(#ddd, #bbb);border: 1px solid rgba(0,0,0,.2);border-radius: .3em;box-shadow: 0 1px white inset;text-align: center;text-shadow: 0 1px 1px white;&#125;input[type=\"checkbox\"]:checked + label,input[type=\"checkbox\"]:active + label &#123;box-shadow: .05em .1em .2em rgba(0,0,0,.6) inset;border-color: rgba(0,0,0,.3);background: #bbb;&#125; 通过阴影来弱化背景 伪元素产生遮罩层 123456789body.dimmed::before &#123;position: fixed;top: 0;right: 0;bottom: 0;left: 0;z-index: 1;background: rgba(0,0,0,.8);&#125; box-shadow产生遮罩层 123456789.test&#123; /*1vmax相当于1vw和1vh中的较大值*/ /*1vmin相当于1vw和1vh中的较小值*/ /*100vw相当于整个视口的宽度,100vh相当于整个视口的高度*/ box-shadow:0 0 0 50vmax rgba(0,0,0,.8); /*配合固定定位使用，或者页面没有滚动条再使用*/ /*无法阻止用户操纵页面*/ position:fixed;&#125; 使用dialog元素 12345678&lt;dialog id=\"modal\"&gt;Showing Dialog&lt;/dialog&gt;&lt;button onclick=\"document.querySelector('modal').showModal()\"&gt;&lt;/button&gt;&lt;style&gt; /*设置遮罩的样式*/ dialog::backdrop&#123; background: rgba(0,0,0,.8); &#125;&lt;/style&gt; 通过模糊来弱化背景123456789101112131415&lt;!-- 所有非对话框元素都用main包裹起来 --&gt;&lt;main&gt;Bacon Ipsum dolor sit amet...&lt;/main&gt;&lt;dialog&gt;O HAI, I'm a dialog. Click on me to dismiss.&lt;/dialog&gt;&lt;!-- 其他对话框都写在这里 --&gt;&lt;style&gt; main &#123; transition: .6s filter; &#125; main.de-emphasized &#123; filter: blur(5px) contrast(.8) brightness(.8); &#125;&lt;/style&gt; 滚动提示12345678910111213141516171819202122232425262728293031323334353637383940&lt;ul&gt;&lt;li&gt;Ada Catlace&lt;/li&gt;&lt;li&gt;Alan Purring&lt;/li&gt;&lt;li&gt;Schrödingcat&lt;/li&gt;&lt;li&gt;Tim Purrners-Lee&lt;/li&gt;&lt;li&gt;WebKitty&lt;/li&gt;&lt;li&gt;Json&lt;/li&gt;&lt;li&gt;Void&lt;/li&gt;&lt;li&gt;Neko&lt;/li&gt;&lt;li&gt;NaN&lt;/li&gt;&lt;li&gt;Cat5&lt;/li&gt;&lt;li&gt;Vector&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; ul&#123; display: inline-block; overflow: auto; width: 7.2em; height: 7em; border: 1px solid silver; padding: .3em .5em; list-style: none; margin-top: 2em; font: 100 200%/1.6 'Frutiger LT Std', sans-serif; /* 由linear-gradient和radial-gradient组成 linear-gradient产生阴影上部 radial-gradient产生阴影下部 */ background: linear-gradient(white 15px, hsla(0,0%,100%,0)) 0 0 / 100% 50px, radial-gradient(at top, rgba(0,0,0,.2), transparent 70%) 0 0 / 100% 15px, linear-gradient(to top, white 15px, hsla(0,0%,100%,0)) bottom / 100% 50px, radial-gradient(at bottom, rgba(0,0,0,.2), transparent 70%) bottom / 100% 15px; background-repeat: no-repeat; background-attachment: local, scroll, local, scroll; margin-top: 30px;&#125;&lt;/style&gt; 交互式的图片对比控件 CSS resize方案 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class=\"image-slider\"&gt; &lt;div&gt; &lt;img src=\"adamcatlace-before.jpg\" alt=\"Before\" /&gt; &lt;/div&gt; &lt;img src=\"adamcatlace-after.jpg\" alt=\"After\" /&gt;&lt;/div&gt;&lt;style&gt;.image-slider &#123; position:relative; display: inline-block;&#125;.image-slider &gt; div &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 50%; /*防止超出图片*/ max-width: 100%; overflow: hidden; resize: horizontal;&#125;/*设置伪元素使拖动提示更加明显*/.image-slider &gt; div::before &#123; content: ''; position: absolute; right: 0; bottom: 0; width: 12px; height: 12px; padding: 5px; background: linear-gradient(-45deg, white 50%, transparent 0); background-clip: content-box; /*改变鼠标光标为双向箭头*/ cursor: ew-resize; -webkit-filter: drop-shadow(0 0 2px black); filter: drop-shadow(0 0 2px black);&#125;.image-slider img &#123; display: block; /*防止用户误选图片*/ user-select: none;&#125;&lt;/style&gt; 范围输入控件方案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt;.image-slider &#123;position:relative;display: inline-block;&#125;.image-slider &gt; div &#123;position: absolute;top: 0; bottom: 0; left: 0;width: 50%;overflow: hidden;&#125;.image-slider img &#123;display: block;user-select: none;&#125;.image-slider input &#123;position: absolute;left: 0;bottom: 10px;width: 100%;margin: 0;/*使得控件更加明显*/filter: contrast(.5);mix-blend-mode: luminosity;/*使可控区域变大*/width: 50%;transform: scale(2);transform-origin: left bottom;&#125;&lt;/style&gt;&lt;div class=\"image-slider\"&gt; &lt;img src=\"adamcatlace-before.jpg\" alt=\"Before\" /&gt; &lt;img src=\"adamcatlace-after.jpg\" alt=\"After\" /&gt;&lt;/div&gt;&lt;script&gt;$$('.image-slider').forEach(function(slider) &#123;// 创建附加的div元素，并用它包住第一个图片元素var div = document.createElement('div');var img = slider.querySelector('img');slider.insertBefore(img, div);div.appendChild(img);// 创建滑块var range = document.createElement('input');range.type = 'range';range.oninput = function() &#123;div.style.width = this.value + '%';&#125;;slider.appendChild(range);&#125;);&lt;/script&gt; 第7章 结构与布局自适应内部元素 使用min-content属性值 123456789101112131415161718&lt;p&gt;Some text [...]&lt;/p&gt; &lt;figure&gt; &lt;img src=\"adamcatlace.jpg\" /&gt; &lt;figcaption&gt; The great Sir Adam Catlace was named after Countess Ada Lovelace, the first programmer. &lt;/figcaption&gt; &lt;/figure&gt;&lt;p&gt;More text [...].&lt;/p&gt;&lt;style&gt; figure &#123; max-width: 300px; max-width: min-content; margin: auto; &#125;/*用于平稳回退*/figure &gt; img &#123; max-width: inherit; &#125;&lt;/style&gt; 精确控制表格列宽 如果不指定任何宽度，则各列的宽度将是平均分配的；后续的表格行并不会影响列宽；给单元格指定很大的宽度也会直接生效，并不会自动缩小； overflow 和 text-overflo属性都是可以正常生效的；如果overflow的值是visible，则单元格的内容有可能会溢出 1234table&#123; table-layout:fixed; width:100%;&#125; 根据兄弟元素的数量来设置样式 当元素数量等于某个特定值时,选中所有元素 123456789101112131415161718li:first-child:nth-last-child(4),li:first-child:nth-last-child(4) ~ li &#123;/* 当列表正好包含四项时，命中所有列表项 */&#125;/*SCSS*//* 定义mixin */@mixin n-items($n) &#123;&amp;:first-child:nth-last-child(#&#123;$n&#125;),&amp;:first-child:nth-last-child(#&#123;$n&#125;) ~ &amp; &#123;@content;&#125;&#125;/* 调用时是这样的： */li &#123;@include n-items(4) &#123;/* 属性与值写在这里 */&#125;&#125; 当元素数量大于或小于某个特定值时，选中所有元素 123456789li:first-child:nth-last-child(n+4),li:first-child:nth-last-child(n+4) ~ li &#123;/* 当列表至少包含四项时，命中所有列表项 */&#125;li:first-child:nth-last-child(-n+4),li:first-child:nth-last-child(-n+4) ~ li &#123;/* 当列表最多包含四项时，命中所有列表项 */&#125; 满幅的背景，定宽的内容 使用padding、calc()进行设置,比起使用div包裹设置margin:1em auto;的更加DRY 12345footer&#123; padding:1em; padding:1em calc(50% - 450px); background:#333;&#125; 行内元素水平居中,text-align:center; 垂直居中 基于绝对定位的解决方案 如果需要居中的元素已经在高度上超过了视口， 那它的顶部会被视口裁切掉 在某些浏览器中，这个方法可能会导致元素的显示有一些模糊，因为元素可能被放置在半个像素上。 这个问题可以用 transformstyle: preserve-3d来修复 12345678910111213&lt;main&gt; &lt;h1&gt;Am I centered yet?&lt;/h1&gt; &lt;p&gt;Center me, please!&lt;/p&gt;&lt;/main&gt;&lt;style&gt;main &#123;position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);&#125;&lt;/style&gt; 基于视口单位的解决方案(使用上面的html代码) 1234567/*只使用与在视口中居中的场景*/main &#123;width: 18em;padding: 1em 1.5em;margin: 50vh auto 0;transform: translateY(-50%);&#125; 基于Flexbox的解决方案 123456789/*当我们使用 Flexbox 时， margin: auto 不仅在水平方向上将元素居中， 垂直方向上也是如此*/body &#123;display: flex;min-height: 100vh;margin: 0;&#125;main &#123;margin: auto;&#125; 紧贴底部的页脚 使用Flexbox 12345678910111213141516171819202122&lt;header&gt; HTML&lt;h1&gt;Site name&lt;/h1&gt;&lt;/header&gt;&lt;main&gt;&lt;p&gt;Bacon Ipsum dolor sit amet...&lt;!-- 从baconipsum.com那里复制一些示意文字过来 --&gt;&lt;/p&gt;&lt;/main&gt;&lt;footer&gt;&lt;p&gt;© 2015 No rights reserved.&lt;/p&gt;&lt;p&gt;Made with ♥ by an anonymous pastafarian.&lt;/p&gt;&lt;/footer&gt;&lt;style&gt;body &#123;display: flex;/*不指定为列显示，则会水平排布显示*/flex-flow: column;min-height: 100vh;&#125;/*内容区块的高度自动伸展并占满所有空间*/main &#123; flex: 1; &#125;&lt;/style&gt; 第8章 过渡与动画缓动动画 弹跳动画 从逻辑上说,只要我们把控制锚点的水平坐标和垂直坐标互换,就可以得到任何调速函数的反向版本。如:cubic-bezier(.25,.1,.25,1)反向版本cubic-bezier(.1,,.25,1,.25) 123456789101112@keyframes bounce &#123;60%, 80%, to &#123;transform: translateY(400px);animation-timing-function: ease;&#125;70% &#123; transform: translateY(300px); &#125;90% &#123; transform: translateY(360px); &#125;&#125;.ball &#123;/* 外观样式 */animation: bounce 3s cubic-bezier(.1,.25,1,.25);&#125; 弹性过渡 输入框提示元素的放大动画,过程:元素出现-&gt;元素超出大小-&gt;回到原始大小 1234567891011121314151617181920212223@keyframes elastic-grow &#123;from &#123; transform: scale(0); &#125;70% &#123;transform: scale(1.1);animation-timing-function:cubic-bezier(.1,.25,1,.25); /* 反向的ease */&#125;&#125;input:not(:focus) + .callout &#123; transform: scale(0);&#125;input:focus + .callout &#123; animation: elastic-grow .5s; &#125;.callout &#123; transform-origin: 1.4em -.4em; &#125;/*==============使用过渡效果产生动画效果=============*/input:not(:focus) + .callout&#123; /*覆盖了动画函数,动画函数使用默认值ease,同时使用修正了不同函数的动画时间*/ transform:scale(0); /*防止动画效果用在了，诸如背景等属性上产生异样的效果*/ transition:.25s transform;&#125;.callout&#123; transform-origin:1.4em -.4em; transition:.5s cubic-bezier(.25,.1,.3,1.5) transform;&#125; 逐帧动画 使用keyframes制作加载进度条的逐帧动画(图片产生的逐帧动画类似gif) steps()第二个参数用于指定动画在每个循环周期的什么位置发生帧的切换动作 12345678910111213@keyframes loader &#123;to &#123; background-position: -800px 0; &#125;&#125;.loader &#123;width: 100px; height: 100px;background: url(img/loader.png) 0 0;/*steps()将动画均匀分配为8帧,产生图片逐帧播放的效果*/animation: loader 1s infinite steps(8);/* 把文本隐藏起来 */text-indent: 200%;white-space: nowrap;overflow: hidden;&#125; 闪烁效果 平滑闪烁效果 1234@keyframes blink-smooth &#123; to &#123; color: transparent &#125; &#125;.highlight &#123;animation: .5s blink-smooth 6 alternate;&#125; 普通闪烁效果 1234@keyframes blink &#123; 50% &#123; color: transparent &#125; &#125;.highlight &#123; animation: 1s blink 3 steps(1); /* 或用step-end */&#125; 打字动画 单行文本 Tips:ch单位,表示”0”字形的宽度,在等宽字体中，“0”字形的宽度和其他所有字形的宽度是一样的。 12345678910111213141516171819202122232425262728&lt;h1&gt;CSS is awesome!&lt;/h1&gt;&lt;style&gt;@keyframes typing &#123;from &#123; width: 0 &#125;&#125;@keyframes caret &#123;50% &#123; border-color: currentColor; &#125;&#125;h1 &#123;width: 15ch; /* 文本的宽度 */overflow: hidden;/*不让文本折行*/white-space: nowrap;/*使用边框模拟光标闪烁效果,并且在不支持时平稳回退为不显示边框*/border-right: .05em solid transparent;animation: typing 6s steps(15),caret 1s steps(1) infinite;&#125;&lt;/style&gt;&lt;script&gt;/*根据文字长度动态调整动画,文本宽度*/$$('h1').forEach(function(h1) &#123;var len = h1.textContent.length, s = h1.style;s.width = len + 'ch';s.animationTimingFunction = \"steps(\"+len+\"),steps(1)\";&#125;);&lt;/script&gt; 状态平滑的动画 鼠标移开动画暂停 12345678910111213@keyframes panoramic &#123;to &#123; background-position: 100% 0; &#125;&#125;.panoramic &#123;width: 150px; height: 150px;background: url(\"img/naxos-greece.jpg\");background-size: auto 100%;animation: panoramic 10s linear infinite alternate;animation-play-state: paused;&#125;.panoramic:hover, .panoramic:focus &#123;animation-play-state: running;&#125; 沿环形路径平移动画 使用两个元素的解决方案 1234567891011121314151617181920&lt;div class=\"path\"&gt; &lt;div class=\"avatar\"&gt; &lt;img src=\"lea.jpg\" /&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt;/*使用反向旋转抵消图片文字的旋转,变成只转动整个元素*/@keyframes spin &#123;to &#123; transform: rotate(1turn); &#125;&#125;.avatar &#123;animation: spin 3s infinite linear;transform-origin: 50% 150px; /* 150px = 路径的半径 */&#125;.avatar &gt; img &#123; animation: inherit; animation-direction: reverse;&#125;&lt;/style&gt; 单个元素的解决方案 使用translate代替transform-origin 1234567891011.test&#123; transform: rotate(30deg); transform-origin: 200px 300px;&#125;/*等价于*/.test&#123; transform: translate(200px, 300px) rotate(30deg) translate(-200px, -300px); transform-origin: 0 0;&#125; 代码实现 12345678910111213141516171819202122232425262728293031323334@keyframes spin &#123;from &#123;transform: translate(50%, 150px)rotate(0turn)translate(-50%, -150px)translate(50%,50%)rotate(1turn)translate(-50%,-50%)&#125;to &#123;transform: translate(50%, 150px)rotate(1turn)translate(-50%, -150px)translate(50%,50%)rotate(0turn)translate(-50%, -50%);&#125;&#125;.avatar &#123; animation: spin 3s infinite linear; &#125;/*合并代码后可得*/@keyframes spin &#123;from &#123;transform: rotate(0turn)translateY(-150px) translateY(50%)rotate(1turn);&#125;to &#123;transform: rotate(1turn)translateY(-150px) translateY(50%)rotate(0turn);&#125;&#125;.avatar &#123; animation: spin 3s infinite linear; &#125;","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]}]