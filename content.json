[{"title":"Java 8新特性","date":"2017-03-14T08:27:44.875Z","path":"2017/03/14/Java 8新特性/","text":"Java 8新特性 在语言方面: 增加了lambda表达式代替以前的内部类 接口可以有方法的默认实现与静态方法 特殊的方法引用(Car::new,Car::collide) 重复注解,扩展注解 编译器:能够使用反射机制获取到类名 类库:Optional,Stream,Base64,并行(parallel)数组 新的命令行工具:jjs,jdeps &lt;!-- more --&gt; Java 语言的新特性 Lambda表达式 Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。(Java使用的是匿名类的机制实现该功能) 123456789/*参数e是通过编译器推断出来的*/Arrays.asList( \"a\", \"b\", \"d\" ).forEach( e -&gt; System.out.println( e ) );Arrays.asList( \"a\", \"b\", \"d\" ).forEach( e -&gt; &#123; System.out.print( e ); System.out.print( e );&#125; );/*也可以通过把参数类型与参数包括在括号中的形式直接给出参数的类型*/Arrays.asList( \"a\", \"b\", \"d\" ).forEach( ( String e ) -&gt; System.out.println( e ) ); Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。 123456String separator = \",\";Arrays.asList( \"a\", \"b\", \"d\" ).forEach( ( String e ) -&gt; System.out.print( e + separator ) );/*等价于*/final String separator = \",\";//... Lambda可能会返回一个值。返回值的类型也是由编译器推测出来的。如果lambda的函数体只有一行的话，那么没有必要显式使用return语句。 123456Arrays.asList( \"a\", \"b\", \"d\" ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );//等价于Arrays.asList( \"a\", \"b\", \"d\" ).sort( ( e1, e2 ) -&gt; &#123; int result = e1.compareTo( e2 ); return result;&#125; ); 语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。最终采取的方法是：增加函数式接口的概念。函数式接口就是一个具有一个方法的普通接口。像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的两个例子。在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）。让我们看一下这种函数式接口的定义： 1234567/*这使得默认方法与静态方法不影响函数式接口的契约*/@FunctionalInterfacepublic interface Functional &#123; void method(); default void defaultMethod() &#123; &#125; &#125; 接口的默认方法与静态方法 默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。 可以在接口中声明静态默认方法 1234567891011private interface Defaulable &#123; // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() &#123; return \"Default implementation\"; &#125; // Interfaces now allow static methods static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123; return supplier.get(); &#125;&#125; 方法引用 12345678910111213141516171819202122232425262728293031public static class Car &#123; public static Car create( final Supplier&lt; Car &gt; supplier ) &#123; return supplier.get(); &#125; public static void collide( final Car car ) &#123; System.out.println( \"Collided \" + car.toString() ); &#125; public void follow( final Car another ) &#123; System.out.println( \"Following the \" + another.toString() ); &#125; public void repair() &#123; System.out.println( \"Repaired \" + this.toString() ); &#125;&#125;/*==========方法引用示例===========*///第一种方法引用是构造器引用，它的语法是Class::new，或者更一般的Class&lt; T &gt;::new。请注意构造器没有参数。final Car car = Car.create( Car::new );//第二种方法引用是静态方法引用，它的语法是Class::static_method。请注意这个方法接受一个Car类型的参数。cars.forEach( Car::collide );//第三种方法引用是特定类的任意对象的方法引用，它的语法是Class::method。请注意，这个方法没有参数。cars.forEach( Car::repair );//第四种方法引用是特定对象的方法引用，它的语法是instance::method。请注意，这个方法接受一个Car类型的参数final Car police = Car.create( Car::new );cars.forEach( police::follow ); 重复注解 相同的注解可以在同一个地方声明多次。 1234567891011121314151617181920212223242526272829303132333435363738package com.javacodegeeks.java8.repeatable.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/*使用@Repeatable( Filters.class )注解的注解类Filter，Filters仅仅是Filter注解的数组，但Java编译器并不想让程序员意识到Filters的存在。这样，接口Filterable就拥有了两次Filter（并没有提到Filter）注解。 */public class RepeatingAnnotations &#123; @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) public @interface Filters &#123; Filter[] value(); &#125; @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) @Repeatable( Filters.class ) public @interface Filter &#123; String value(); &#125;; @Filter( \"filter1\" ) @Filter( \"filter2\" ) public interface Filterable &#123; &#125; /* 反射相关的API提供了新的函数getAnnotationsByType()来返回重复注解的类型（请注意Filterable.class.getAnnotation( Filters.class )经编译器处理后将会返回Filters的实例）。 */ public static void main(String[] args) &#123; for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123; System.out.println( filter.value() ); &#125; &#125;&#125; 更好的类型推测机制 12345678910111213141516171819202122package com.javacodegeeks.java8.type.inference;public class Value&lt; T &gt; &#123; public static&lt; T &gt; T defaultValue() &#123; return null; &#125; public T getOrDefault( T value, T defaultValue ) &#123; return ( value != null ) ? value : defaultValue; &#125;&#125;/*用法示例*/public class TypeInference &#123; public static void main(String[] args) &#123; final Value&lt; String &gt; value = new Value&lt;&gt;(); /* Value.defaultValue()的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是 Value.&lt; String &gt;defaultValue()。 */ value.getOrDefault( \"22\", Value.defaultValue() ); &#125;&#125; 扩展注解的支持 几乎可以为任何东西添加注解:局部变量、泛型类、父类与接口的实现,就连方法的异常也能添加注解。 1234567891011121314151617181920212223242526package com.javacodegeeks.java8.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.ArrayList;import java.util.Collection;public class Annotations &#123; @Retention( RetentionPolicy.RUNTIME ) @Target( &#123; ElementType.TYPE_USE, ElementType.TYPE_PARAMETER &#125; ) public @interface NonEmpty &#123; &#125; public static class Holder&lt; @NonEmpty T &gt; extends @NonEmpty Object &#123; public void method() throws @NonEmpty Exception &#123; &#125; &#125; @SuppressWarnings( \"unused\" ) public static void main(String[] args) &#123; final Holder&lt; String &gt; holder = new @NonEmpty Holder&lt; String &gt;(); @NonEmpty Collection&lt; @NonEmpty String &gt; strings = new ArrayList&lt;&gt;(); &#125;&#125; Java编译器的新特性 保存参数名字在字节码中,并且能够在运行时获取它们。 1234567891011import java.lang.reflect.Method;import java.lang.reflect.Parameter;public class ParameterNames &#123; public static void main(String[] args) throws Exception &#123; Method method = ParameterNames.class.getMethod( \"main\", String[].class ); for( final Parameter parameter: method.getParameters() ) &#123; System.out.println( \"Parameter: \" + parameter.getName() ); &#125; &#125;&#125; Java类库的新特性 Optional Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 12345678910111213141516171819202122232425/*isPresent()//判断对象是否不为空orElseGet()//为空，则返回一个默认值(回调函数形式)orElse()//为空,返回一个默认值 */Optional&lt; String &gt; fullName = Optional.ofNullable( null );System.out.println( \"Full Name is set? \" + fullName.isPresent() ); System.out.println( \"Full Name: \" + fullName.orElseGet( () -&gt; \"[none]\" ) ); System.out.println( fullName.map( s -&gt; \"Hey \" + s + \"!\" ).orElse( \"Hey Stranger!\" ) );//Output://Full Name is set? false//Full Name: [none]//Hey Stranger!Optional&lt; String &gt; firstName = Optional.of( \"Tom\" );System.out.println( \"First Name is set? \" + firstName.isPresent() ); System.out.println( \"First Name: \" + firstName.orElseGet( () -&gt; \"[none]\" ) ); System.out.println( firstName.map( s -&gt; \"Hey \" + s + \"!\" ).orElse( \"Hey Stranger!\" ) );System.out.println();//Output://First Name is set? true//First Name: Tom//Hey Tom! Stream Stream API极大简化了集合框架的处理(但它的处理范围不仅仅限于集合框架的处理) 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Streams &#123; public static enum Status &#123; OPEN, CLOSED &#125;; public static final class Task &#123; private final Status status; private final Integer points; Task( final Status status, final Integer points ) &#123; this.status = status; this.points = points; &#125; public Integer getPoints() &#123; return points; &#125; public Status getStatus() &#123; return status; &#125; @Override public String toString() &#123; return String.format( \"[%s, %d]\", status, points ); &#125; &#125;&#125;final Collection&lt; Task &gt; tasks = Arrays.asList( new Task( Status.OPEN, 5 ), new Task( Status.OPEN, 13 ), new Task( Status.CLOSED, 8 ) );// Calculate total points of all active tasks using sum()final long totalPointsOfOpenTasks = tasks .stream() .filter( task -&gt; task.getStatus() == Status.OPEN ) .mapToInt( Task::getPoints ) .sum(); System.out.println( \"Total points: \" + totalPointsOfOpenTasks );//Total points: 18 中间操作返回一个新的stream对象。中间操作总是采用惰性求值方式，运行一个像filter这样的中间操作实际上没有进行任何过滤，相反它在遍历元素时会产生了一个新的stream对象，这个新的stream对象包含原始stream中符合给定谓词的所有元素。 最终操作像forEach、sum这样的最终操作可能直接遍历stream，产生一个结果或副作用。当最终操作执行结束之后，stream管道被认为已经被消耗了，没有可能再被使用了。在大多数情况下，最终操作都是采用及早求值方式，及早完成底层数据源的遍历。 原生支持并行运算: 123456789// Calculate total points of all tasksfinal double totalPoints = tasks .stream() .parallel() .map( task -&gt; task.getPoints() ) // or map( Task::getPoints ) .reduce( 0, Integer::sum ); System.out.println( \"Total points (all tasks): \" + totalPoints );//Total points (all tasks): 26.0 流中显示改变数据类型 12345678910111213// Calculate the weight of each tasks (as percent of total points) final Collection&lt; String &gt; result = tasks .stream() // Stream&lt; String &gt; .mapToInt( Task::getPoints ) // IntStream .asLongStream() // LongStream .mapToDouble( points -&gt; points / totalPoints ) // DoubleStream .boxed() // Stream&lt; Double &gt; .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) // LongStream .mapToObj( percentage -&gt; percentage + \"%\" ) // Stream&lt; String&gt; .collect( Collectors.toList() ); // List&lt; String &gt; System.out.println( result );//[19%,50%,30%] Stream处理I/O流 1234567final Path path = new File( \"C:\\\\Users\\\\KINGBOOK\\\\Desktop\\\\list.txt\" ).toPath(); try( Stream&lt; String &gt; lines = Files.lines( path, StandardCharsets.UTF_8 ) ) &#123; //调用Stream关闭方法的回调函数 lines.onClose( () -&gt; System.out.println(\"Done!\") ).forEach( System.out::println ); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; Date/Time API(JSR 310) 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作 Clock类，它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间。Clock可以替换System.currentTimeMillis()与TimeZone.getDefault() 123456// Get the system clock as UTC offset final Clock clock = Clock.systemUTC();System.out.println( clock.instant() );System.out.println( clock.millis() );//2016-12-26T06:13:09.953Z//1482732790198 LocaleDate只持有ISO-8601格式且无时区信息的日期部分。相应的，LocaleTime只持有ISO-8601格式且无时区信息的时间部分。LocaleDate与LocalTime都可以从Clock中得到。 1234567891011121314151617// Get the local date and local timefinal LocalDate date = LocalDate.now();final LocalDate dateFromClock = LocalDate.now( clock ); System.out.println( date );System.out.println( dateFromClock ); // Get the local date and local timefinal LocalTime time = LocalTime.now();final LocalTime timeFromClock = LocalTime.now( clock ); System.out.println( time );System.out.println( timeFromClock );//2016-12-26//2016-12-26//14:16:31.692//06:16:31.692 LocaleDateTime把LocaleDate与LocaleTime的功能合并起来，它持有的是ISO-8601格式无时区信息的日期与时间。 ZoneDateTime持有ISO-8601格式具具有时区信息的日期与时间 在秒与纳秒级别上的一段时间。Duration使计算两个日期间的不同变的十分简单。 12345678910// Get duration between two datesfinal LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );final Duration duration = Duration.between( from, to );System.out.println( \"Duration in days: \" + duration.toDays() );System.out.println( \"Duration in hours: \" + duration.toHours() );//Duration in days: 365//Duration in hours: 8783 JavaScript引擎Nashorn Nashorn就是javax.script.ScriptEngine的另一种实现，并且它们俩遵循相同的规则，允许Java与JavaScript相互调用。 1234567ScriptEngineManager manager = new ScriptEngineManager();ScriptEngine engine = manager.getEngineByName( \"JavaScript\" ); System.out.println( engine.getClass().getName() );System.out.println( \"Result:\" + engine.eval( \"function f() &#123; return 1; &#125;; f() + 1;\" ) );//jdk.nashorn.api.scripting.NashornScriptEngine//Result: 2 Base64 在Java 8中，Base64编码已经成为Java类库的标准。 12345678910111213141516171819202122package com.javacodegeeks.java8.base64;import java.nio.charset.StandardCharsets;import java.util.Base64;public class Base64s &#123; public static void main(String[] args) &#123; final String text = \"Base64 finally in Java 8!\"; final String encoded = Base64 .getEncoder() .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) ); System.out.println( encoded ); final String decoded = new String( Base64.getDecoder().decode( encoded ), StandardCharsets.UTF_8 ); System.out.println( decoded ); &#125;&#125;//QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==//Base64 finally in Java 8! 并行(parallel)数组 Java 8增加了大量的新方法来对数组进行并行处理。可以说，最重要的是parallelSort()方法，因为它可以在多核机器上极大提高数组排序的速度。 1234567891011121314151617181920212223package com.javacodegeeks.java8.parallel.arrays;import java.util.Arrays;import java.util.concurrent.ThreadLocalRandom;public class ParallelArrays &#123; public static void main( String[] args ) &#123; long[] arrayOfLong = new long [ 20000 ]; Arrays.parallelSetAll( arrayOfLong, index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) ); Arrays.stream( arrayOfLong ).limit( 10 ).forEach( i -&gt; System.out.print( i + \" \" ) ); System.out.println(); Arrays.parallelSort( arrayOfLong ); Arrays.stream( arrayOfLong ).limit( 10 ).forEach( i -&gt; System.out.print( i + \" \" ) ); System.out.println(); &#125;&#125;//850472 159091 790811 602830 730454 845568 489915 193547 477322 65829 //25 133 166 191 275 310 384 396 448 454 新的命令行工具 Nashorm引擎:jjs jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。 类依赖分析器jdeps jdeps是一个很有用的命令行工具。它可以显示Java类的包级别或类级别的依赖。它接受一个.class文件，一个目录，或者一个jar文件作为输入。jdeps默认把结果输出到系统输出（控制台）上。 参考链接: Java8新特性","tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/后端/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"WebService","date":"2017-03-10T03:10:06.556Z","path":"2017/03/10/WebService学习/","text":"WebService学习 WebService(jax-ws)三要素 SOAP: 基于HTTP协议，采用XML格式，用来传递信息的格式。 WSDL: 用来描述如何访问具体的服务。 UDDI: 用户自己可以按UDDI标准搭建UDDI服务器，用来管理，分发，查询WebService 。其他用户可以自己注册发布WebService调用。 &lt;!-- more --&gt; SOAP(通讯协议) Simple Object Accrss Protocol，简单对象访问协议是在分散或分布式的环境中交换信息的简单的协议，是一个基于XML的协议，它包括四个部分: 1 SOAP封装(envelop)，封装定义了一个描述消息中的内容是什么，是谁发送的，谁应当接受并处理它，以及如何处理它们的框架; 2 SOAP编码规则，用于表示应用程序需要使用的数据类型的实例。 3 SOAP RPC 表示远程过程调用和应答的协定。 4 SOAP绑定(binding)，使用底层协议交换信息。 请求的协议体 12345678910111213141516POST /weather HTTP/1.1Accept: text/xml, multipart/relatedContent-Type: text/xml; charset=utf-8SOAPAction: \"http://weather.itheima.com/WeatherInterface/getWeatherByCityNameRequest\"User-Agent: JAX-WS RI 2.2.4-b01Host: 127.0.0.1:54321Connection: keep-aliveContent-Length: 235&lt;?xml version=\"1.0\" ?&gt;&lt;S:Envelope xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;S:Body&gt; &lt;ns2:getWeatherByCityName xmlns:ns2=\"http://weather.itheima.com\"&gt; &lt;cityName&gt;北京&lt;/cityName&gt; &lt;/ns2:getWeatherByCityName&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt; 响应的协议体 123456789101112HTTP/1.1 200 OKTransfer-encoding: chunkedContent-type: text/xml; charset=utf-8Date: Fri, 09 Oct 2015 07:23:29 GMT&lt;?xml version=\"1.0\" ?&gt;&lt;S:Envelope xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;S:Body&gt; &lt;ns2:getWeatherByCityNameResponse xmlns:ns2=\"http://weather.itheima.com\"&gt; &lt;WeatherInfo&gt;今天风很大&lt;/WeatherInfo&gt; &lt;/ns2:getWeatherByCityNameResponse&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt; WSDL WSDL(Web Service Description Language)，是一个用来描述Web服务（Web Service）和说明如何与Web服务通信的XML语言。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。 WSDL阅读方法 是从下往上读。 每个wsdl有且只有一个Service节点。 1、先找Service节点 2、Service节点中找port节点。每个port对应一个PortType。 3、Port节点对应一binding节点。每个binding节点对应一个PortType 4、PortType中有operation 节点就是服务的方法。 5、operation 中有Input（参数）和output（返回值） 6、Input（参数）和output（返回值）对应message节点 7、Message对应element节点(定义在XSD中)。Element节点对应complexType节点描述了参数及返回值的数据类型。 使用注解规范 @WebService: 定义服务，在public class上边。 targetNamespace:指定命名空间。 name:portType的名称。 portName:port的名称。 serviceName:服务名称。 @WebResult:定义返回值。 name:返回结果值的名称。 @WebParam:定义参数。 name:指定参数的名称。 @WebMethod exclude:排除指定的方法。 XSD XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，还是64位？这些细节对实现互操作性都是很重要的。W3C制定的XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。Web service平台就是用XSD来作为其数据类型系统的。 UUDI UDDI 是一种目录服务，通过它，企业可注册并搜索 Web services。企业将自己提供的Web Service注册在UDDI，也可以使用别的企业在UDDI注册的web service服务，从而达到资源共享。 UDDI旨在将全球的webservcie资源进行共享，促进全球经济合作。 但是使用webservice并不是必须使用UDDI，因为用户通过WSDL知道了web service的地址，可以直接通过WSDL调用webservice。 使用实例 服务端: 12345678910111213141516171819public interface WeatherInterface &#123; public String getWeatherByCity(String city);&#125;@WebServicepublic class WeatherInterfaceImpl implements WeatherInterface &#123; @Override public String getWeatherByCity(String city) &#123; String result = \",天气寒冷\"; return city + result; &#125;&#125;public class WeatherServer &#123; public static void main(String[] args)&#123; Endpoint.publish(\"http://localhost:12345/weather\", new WeatherInterfaceImpl()); &#125;&#125; 服务端启动后进入客户端工程相应的目录下使用wsimport -s . http://localhost:12345/weather?wsdl生成代码 12345678public class WeatherClient &#123; public static void main(String[] args)&#123; WeatherInterfaceImplService service = new WeatherInterfaceImplService(); WeatherInterfaceImpl portType = service.getWeatherInterfaceImplPort(); String result = portType.getWeatherByCity(\"北京\"); System.out.println(result); &#125;&#125; Apache CXF Apache CXF是一个开源的Web Services框架: 支持多种协议:SOAP1.1,1,2 XML/HTTP、RESTful 或者CORBA 部署灵活:可以运行在Tomcat,Jboss,Jetty(内置),weblogic上面。 可嵌入的Web服务组件：例如可以嵌入到Spring Framework和Geronimo中。 高性能,最小的计算开销。 服务器端 实体类: 1234567public class Weather &#123; private int minTemp; private int maxTemp; private String info; private Date date; &#125; 服务接口与实现: 12345678910111213141516171819202122232425262728@WebServicepublic interface WeatherInterface &#123; public List&lt;Weather&gt; getWeatherByCity(String city);&#125;public class WeatherInterfaceImpl implements WeatherInterface&#123; public List&lt;Weather&gt; getWeatherByCity(String city) &#123; return getWeatherInfo(city); &#125; private List&lt;Weather&gt; getWeatherInfo(String city)&#123; List&lt;Weather&gt; weathers = new ArrayList&lt;&gt;(); Calendar c = Calendar.getInstance(); Date d1 = c.getTime(); c.set(Calendar.DATE, c.get(Calendar.DATE) + 1); Date d2 = c.getTime(); c.set(Calendar.DATE, c.get(Calendar.DATE) + 2); Date d3 = c.getTime(); c.set(Calendar.DATE, c.get(Calendar.DATE) + 3); weathers.add(new Weather(30,20,city+\":今天很热\",d1)); weathers.add(new Weather(31,21,city+\":今天很热\",d2)); weathers.add(new Weather(32,22,city+\":今天很热\",d3)); return weathers; &#125; &#125; 服务启动: 1234567891011121314public class WeatherService &#123; public static void main(String[] args)&#123; //创建JaxWsClientFactoryBean JaxWsServerFactoryBean factoryBean = new JaxWsServerFactoryBean(); //设置SEI接口 factoryBean.setServiceClass(WeatherInterface.class); //设置SEI实现类对象 factoryBean.setServiceBean(new WeatherInterfaceImpl()); //设置服务发布地址 factoryBean.setAddress(\"http://localhost:12345/weather\"); //发布服务 factoryBean.create(); &#125;&#125; 客户端 先使用Apache CXF的wsdl2java -d . http://localhost:12345/weather?wsdl生成客户端代码: 1234567891011121314151617public class CXFClient &#123; public static void main(String[] args)&#123; //创建一个JaxWsProxyFactoryBean JaxWsProxyFactoryBean factoryBean = new JaxWsProxyFactoryBean(); //设置portType的class factoryBean.setServiceClass(WeatherInterface.class); //设置地址 factoryBean.setAddress(\"http://localhost:12345/weather?wsdl\"); //调用create方法生成portType对象 WeatherInterface portType = (WeatherInterface) factoryBean.create(); //调用服务端方法 List&lt;Weather&gt; weathers = portType.getWeatherByCity(\"北京\"); for(Weather w:weathers)&#123; System.out.println(w); &#125; &#125;&#125; 参考链接 WebService基础学习","tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/后端/"}]},{"title":"dojo DOM学习","date":"2017-03-08T05:57:21.660Z","path":"2017/03/08/dojoDom学习/","text":"dojo DOM学习 dojo致力于提供简单、高效、跨浏览器的DOM操作。 dojo/dom 简单的id检索，判断是否为子元素 dom-construct 创建、删除、移动节点 dom-attr 属性相关操作 dom-class 类相关操作 dom-form 表单相关操作 dom-style 样式相关操作 dom-prop 元素属性相关操作 dom-geometry 元素位置、大小信息等。 &lt;!-- more --&gt; dojo/dom 1234//获取Id为one的元素，不存在则返回空。dom.byId(\"one\");//isDescendant(node,ancestor)判断是否为后代元素if(dom.isDescendant(\"bar\", \"foo\"))&#123; ... &#125; dojo/dom-construct 12345678910111213141516171819202122//refNode参考节点,pos:位置信息(after,before,last,first,only,replace)create(tag,attrs,refNode,pos)//Example:domConstruct.create(\"li\", &#123; innerHTML: \"Seven\", className: \"seven\", style: &#123; fontWeight: \"bold\" &#125;&#125;, three, \"after\");//删除节点通过IDdestroy(node)//删除所有子节点通过IDempty(node)//放置节点，通过ID或者新建节点place(node,refNode,position)//Example:domConstruct.place(\"&lt;li&gt;&lt;/li&gt;\", \"someUl\", \"first\");//实例化一个html片段，返回相应的DOMtoDom(frag,doc) dojo/dom-attr 12345678910//通过节点ID或节点,获取属性get(node,name)//从元素属性或者节点属性中获取值getNodeProp(node,name)//判断元素是否有属性has(node,name)//移除某个节点属性remove(node,name) //设置一个属性到html元素中set(node,name,value) dojo/dom-class 12345678910//添加类名add(node,classStr)//是否包含类名contains(node,classStr)//移除类名remove(node,classStr) //移除和替换类replace(node,addClassStr,removeClassStr) //切换类,condition:true添加,false删除toggle(node,classStr,condition) dojo/dom-form 12345678//序列化表单字段为一个js对象(一般的表单为字符串，多选框为列表)fieldToObject(inputNode)//序列化为json字符串toJson(formNode,prettypPrint)//序列化表单为一个对象toObject(formNode)//返回用于查询的字符串toQuery(formNode) dojo/dom-prop 1234//获取html元素属性get(node,name)//设置html元素属性set(node,name,value) dojo/dom-style 12345678//获取样式值get(node,name)//获取计算后的样式值getComputedStyle(node)//设置样式值set(node,name,value) //将样式值转换为像素值（IE中），其他返回一个数值。toPixelValue(node,value) dojo/dom-geometry 12345678//返回&#123;x,y&#125;对象x,y是坐标docScroll(doc) //返回&#123;w,h,x,y&#125;等信息position(node,includeScroll)//修复左滚动值为负值(IE为正值)fixIeBiDiScrollLeft(scrollLeft,doc)//判断当前语言环境是否左到右isBodyLtr(doc) dojo/domReady 延迟require()/define()回调直到完成DOM解析。 Dom函数 DOM API","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"dojo","slug":"dojo","permalink":"http://yoursite.com/tags/dojo/"}]},{"title":"dojo","date":"2017-03-07T03:52:03.920Z","path":"2017/03/07/dojo起步/","text":"dojo起步 简介 dojo是前端js的一个框架,支持js异步加载机制,对js的语句进行了优化，还提供打包工具可以优化JS代码，还提供了所有的UI组件，支持IE6以上的浏览器。dojo解决了企业级开发中大量加载JS导致的浏览器崩溃问题。 &lt;!-- more --&gt; Getting Started Hello Dojo 模块的使用 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Tutorial: Hello Dojo!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"greeting\"&gt;Hello&lt;/h1&gt; &lt;!-- load Dojo --&gt; &lt;!-- 此处只是加载dojo的异步加载模块,包括require,define两个全局函数 --&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\" data-dojo-config=\"async: true\"&gt;&lt;/script&gt; &lt;script&gt; require([ &lt;!-- dom操作相关的模块 --&gt; 'dojo/dom', 'dojo/dom-construct' &lt;!-- 异步加载模块，使用回调函数的机制 --&gt; ], function (dom, domConstruct) &#123; var greetingNode = dom.byId('greeting'); domConstruct.place('&lt;em&gt; Dojo!&lt;/em&gt;', greetingNode); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模块的定义(参考路径是dojo的根目录) 1234567891011121314151617181920define([ 'dojo/dom'], function(dom)&#123; var oldText = &#123;&#125;; return &#123; setText: function (id, text) &#123; var node = dom.byId(id); oldText[id] = node.innerHTML; node.innerHTML = text; &#125;, restoreText: function (id) &#123; var node = dom.byId(id); node.innerHTML = oldText[id]; delete oldText[id]; &#125; &#125;;&#125;); 组合使用CDN模块与自定义模块 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Tutorial: Hello Dojo!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"greeting\"&gt;Hello&lt;/h1&gt; &lt;!-- configure Dojo --&gt; &lt;script&gt; var dojoConfig = &#123; async: true, //配置自定义的路径 packages: [&#123; name: \"demo\", location: location.pathname.replace(/\\/[^/]*$/, '') + '/demo' &#125;] &#125;; &lt;/script&gt; &lt;!-- load Dojo --&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\"&gt;&lt;/script&gt; &lt;script&gt; require([ 'demo/myModule' ], function (myModule) &#123; myModule.setText('greeting', 'Hello Dojo!'); setTimeout(function () &#123; myModule.restoreText('greeting'); &#125;, 3000); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 等待DOM加载 123456789require([ 'dojo/dom', //domReady为插件,通过模块标识符后带\"!\"来激活， //dom加载完毕才执行回调。 'dojo/domReady!'], function (dom) &#123; var greeting = dom.byId('greeting'); greeting.innerHTML += ' from Dojo!';&#125;); 使用dojoConfig配置dojo dojoConfig相当于将配置发送到服务器上，服务器接收参数后定制模块。配置参数是在dojo/_base/config下。dojoConfig必须写在require前。 dojoConfig两种配置方式: 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 一:使用全局变量dojoConfig --&gt;&lt;!-- set Dojo configuration, load Dojo --&gt;&lt;script&gt; dojoConfig= &#123; has: &#123; \"dojo-firebug\": true &#125;, parseOnLoad: false, foo: \"bar\", async: true &#125;;&lt;/script&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\"&gt;&lt;/script&gt;&lt;script&gt;// Require the registry, parser, Dialog, and wait for domReadyrequire([\"dijit/registry\", \"dojo/parser\", \"dojo/json\", \"dojo/_base/config\", \"dijit/Dialog\", \"dojo/domReady!\"], function(registry, parser, JSON, config) &#123; // Explicitly parse the page parser.parse(); // Find the dialog var dialog = registry.byId(\"dialog\"); // Set the content equal to what dojo.config is dialog.set(\"content\", \"&lt;pre&gt;\" + JSON.stringify(config, null, \"\\t\") + \"```\"); // Show the dialog dialog.show();&#125;);&lt;/script&gt;&lt;!-- and later in the page --&gt;&lt;div id=\"dialog\" data-dojo-type=\"dijit/Dialog\" data-dojo-props=\"title: 'dojoConfig / dojo/_base/config'\"&gt;&lt;/div&gt;&lt;!-- 二:写在script标签中 --&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\" data-dojo-config=\"has:&#123;'dojo-firebug': true&#125;, parseOnLoad: false, foo: 'bar', async: 1\"&gt;&lt;/script&gt; 使用has()配置特性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 has: &#123; //启用firebug lite,chrome中的firebug调试插件 \"dojo-firebug\": true, \"dojo-debug-messages\": true, \"dojo-amd-factory-scan\": false &#125;``` #### 加载配置```json//配置异步加载的基本urlbaseUrl: \"/js\",//配置包名和位置packages: [&#123; name: \"myapp\", location: \"/js/myapp\" &#125;],//使用dojo代表dojo16map: &#123; dijit16: &#123; dojo: \"dojo16\" &#125; &#125;,//定制模块到不同的路径packages: [ \"package1\", \"package2\" ], paths: &#123; package1: \"../lib/package1\", package2: \"/js/package2\" &#125;//等价于 packages: [ &#123; name: \"package1\", location: \"../lib/package1\" &#125;, &#123; name: \"package2\", location: \"/js/package2\" &#125; ],//是否异步加载async: true,//dojo加载完毕就开始加载deps: [\"dojo/parser\"],//当文档和deps加载完毕后，使用dojo/parser模块进行解析parseOnLoad: true,//deps中的加载完毕后执行callback: function(parser) &#123; // Use the resources provided here &#125;,//发出模块请求后的等待时间waitSeconds: 5,//不使用缓存策略cacheBust: true 其他的配置对象 其他模块中使用的配置对象,主要是dojox,dijit。 Dijit Editor allowXdRichTextSave dojox GFX dojoxGfxSvgProxyFrameUrl, forceGfxRenderer, gfxRenderer dojox.html metrics fontSizeWatch dojox.io transports and plugins xipClientUrl, dojoCallbackUrl dojox.image preloadImages dojox.analytics plugins sendInterval, inTransitRetry, analyticsUrl, sendMethod, maxRequestSize, idleTime, watchMouseOver, sampleDelay, targetProps, windowConnects, urchin dojox.cometd cometdRoot dojox.form.FileUploader uploaderPath dojox.mobile mblApplyPageStyles, mblHideAddressBar, mblAlwaysHideAddressBar, mobileAnim, mblLoadCompatCssFiles 参考链接: Hello Dojo! Configuring Dojo","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"dojo","slug":"dojo","permalink":"http://yoursite.com/tags/dojo/"}]},{"title":"汽渡船舶防碰撞预警系统平台","date":"2017-02-25T14:24:53.588Z","path":"2017/02/25/汽渡船舶防碰撞预警系统平台/","text":"汽渡船舶防碰撞预警系统平台 汽渡船舶防碰撞预警系统平台功能: 页面动态显示船舶（包括在地图上显示船舶的位置，船舶的航行速度,点击定位能定位到船舶） 提示碰撞警告（查表当将会出现的碰撞时间大于当前时间则生成提示信息，有的船能生成碰撞信息保存到数据库） 推送警告信息(只是将警告信息插入到指定的数据表中) 显示船舶历史轨迹动画 可以在地图上管理标注（标注类型有:点、多段线、多边形等标注）， 基本数据的增删改查、以图表方式展示数据 具有用户操作日志，记录用户的每一个操作。 具有权限管理，给不同的用户设置不同的权限。(也是通过用户关联爹角色形式。) 能够扩展基本数据，便于系统的灵活扩展。 对于地图的操作有:放大、缩小、测量、显示不同的底图（包括矢量图、影像图、黑暗图） 使用到的框架和库: 后台框架:Spring、Spring MVC、MyBatis 前台框架:jQuery、Easy UI、arcgis for js 3.20、jWebAudio（音频库）、Cocurrent.Thread.js jQuery插件:ZeroModal(jQuery弹出层插件)、uploadPreview、ajaxFileUpload、jQuery.cookie 数据库:Oracle &lt;!-- more --&gt; 值得注意的地方 ArcGIS API for JS ArcGIS中，地图由图层组成。GraphicLayer用于创建几何图形层，自定义的图形、绘制的图形都放置其上。ArcGISDynamicMapServiceLayer用于创建ArcGIS服务中得到的图层(背景图)。放置在GraphicLayer上的图形(Graphic)有两种元素构成，记号(Symbol),几何(Geometry)组成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 用到的ArcGIS API for JS * ?:代表可选参数 *//*map及其相关API*///\"esri/map\"var myMap = new Map(divId, options?);//新建一个Map,divId为使用的html标签myMap.addLayer(layer,index?)//添加图层myMap.setExtent(extent, fit?)//设置地图的范围,定位也是通过这个API实现的//\"esri/SpatialReference\"new SpatialReference(wkid)//定义一个空间参考,wkid是数字//\"esri/geometry/Extent\"new Extent(xmin, ymin, xmax, ymax, spatialReference)//右上角与左下角的坐标,/*layer及其相关API*///\"esri/layers/GraphicsLayer\"var gLayer = new GraphicsLayer(options?)//新建图层,建立的是可在上面添加东西的图层gLayer.add(graphic)//添加图形gLayer.remove(graphic)//移除图形//\"esri/layers/ArcGISDynamicMapServiceLayer\"new ArcGISDynamicMapServiceLayer(url, options?)//使用发布arcgis服务作为图层//\"esri/InfoTemplate\"new InfoTemplate(title, content)//创建信息模板//\"esri/graphic\"var graphic = new Graphic(geometry?, symbol?, attributes?, infoTemplate?)//创建一个图形graphic.setInfoTemplate(infoTemplate);//设置图形的信息模板//\"esri/symbols/SimpleLineSymbol\" //创建一个记号 //style，例esri.symbol.SimpleLineSymbol.STYLE_SOLID //color,例esri.Color(\"#00f2fa\")var sys = new SimpleLineSymbol(style, color, width)//创建一个多边形var polylineJson = &#123; \"paths\" : [ [ [ obj.LON, obj.LAT ], [ nextObj.LON, nextObj.LAT ] ] ], \"spatialReference\" : &#123; \"wkid\" : 4326 &#125;&#125;;//\"esri/geometry/Polyline\",\"esri/graphic\"var gLine = new esri.Graphic(new esri.geometry.Polyline( polylineJson), sls);//\"esri/symbols/PictureMarkerSymbol\"new PictureMarkerSymbol(url, width, height)//创建一个图片记号//\"esri/symbols/SimpleMarkerSymbol\"new SimpleMarkerSymbol(style, size, outline, color)//简单标志记号/*操作Map相关工具的API*///\"esri/toolbars/draw\"var drawpoint = new Draw(map, options?)//生成一个用于画点的对象drawpoint.deactivate();//使工具栏无效，并且重新激活导航栏。drawpoint.on(\"draw-end\", addToMapC);//画图结束触发事件//\"esri/toolbars/navigation\"navigationToolbar = new Navigation(myMap);//创建地图工具对象navigationToolbar.activate(Navigation.ZOOM_IN);//放大navigationToolbar.activate(Navigation.ZOOM_OUT);//缩小 保存用户名和密码 使用前台jQuery.cookie读取cookie，后台添加cookie jQuery.cookie相关API 123456//读取cookie,不存在返回null$.cookie('the_cookie'); //删除cookie$.cookie('the_cookie', null); //创建一个cookie并设置 cookie的有效路径(在默认情况下，只有设置 cookie的网页才能读取该 cookie。如果想让一个页面读取另一个页面设 )： $.cookie('the_cookie', 'the_value', &#123; expires: 7, path: '/' &#125;); 后台添加cookie 123456789101112131415161718//添加cookieresponse.addCookie(setCookies(\"pwd\", user.getUserpwd()));//清除Cookiepublic void cleanCookie(HttpServletRequest req,HttpServletResponse res)&#123; Cookie[] cookies = req.getCookies(); EmptyUtil eu = new EmptyUtil(); for(Cookie c : cookies)&#123; if((!eu.isFieldEmpty(c.getName())))&#123; if(c.getName().equals(\"user\")||c.getName().equals(\"pwd\")||c.getName().equals(\"rememberUser\")||c.getName().equals(\"username\"))&#123; c.setValue(null); c.setMaxAge(0);// 立即销毁cookie c.setPath(\"/\"); res.addCookie(c); &#125; &#125; &#125;&#125; 防止用户重新登陆 __实现思路:__设置一个sessionMap管理所有的session,当用户登陆时，检测sessionMap中是否存在该session，如果不存在则添加session到sessionMap中。如果存在，则比较两次登陆的IP是否相同，如果相同则只刷新session，如果不同则删去老的session添加新的session。因为用户操作需要权限，权限又跟cookie挂钩，所以去掉了session的用户在下一次操作时就会发现被挤出。 123456789101112131415161718192021222324252627282930313233343536373839404142public synchronized void addSession(HttpSession session,String username)&#123; if(session!=null)&#123; //防止重复登录，旧登录用户踢出 //addSessionMap是保存了所有session的map Set&lt;Map.Entry&lt;String, Object&gt;&gt; submap = appSessionMap.entrySet(); for(Map.Entry&lt;String, Object&gt; emap: submap)&#123; HttpSession subsession = (HttpSession) emap.getValue(); try &#123; String names = subsession.getAttribute(\"username\").toString(); if(names!=null&amp;&amp;names.equals(username))&#123; ApplicationContext applicationContext = SpringContextLoaderListener.getApplicationContext(); IUserLogServices UserLogServices = (IUserLogServices) applicationContext.getBean(\"UserLogServices\"); sys_userinfo user = (sys_userinfo) session.getAttribute(\"user\"); List&lt;sys_userlog&gt; sys_userlog = UserLogServices.getlastuserlog(user.getGuid()); //从日志中获取用户IP if(sys_userlog!=null&amp;&amp;sys_userlog.size()&gt;0)&#123; String newIp = (String) session.getAttribute(\"ip\"); String ip = sys_userlog.get(0).getIpaddress(); if(!ip.equals(newIp))&#123; UserLogServices.setuserlog(ip, user,\" 该账户在其他ip登录，当前操作用户已登出\"); &#125; &#125; appSessionMap.remove(emap.getKey()); break; &#125; &#125; catch (Exception e) &#123; appSessionMap.remove(emap.getKey()); break; &#125; &#125; //首次登录 if(appSessionMap.get(session.getId())==null)&#123; appSessionMap.put(session.getId(), session); &#125;else&#123; //再次登录更新session appSessionMap.remove(session.getId()); appSessionMap.put(session.getId(), session); &#125; &#125; &#125; 在select中使用select子句 1234select (select st1.shipname from basic_ferryboatsmsg st1 where st1.qdmmsi=t.mmsi) as SHIPNAME,t.mmsi,t.lon,t.lat,t.cog,t.sog,t.timestr, (select st1.adistance from ELEC_SHIPPOSITION st1 where t.mmsi=st1.mmsi) as ADISTANCE, (select st2.bdistance from ELEC_SHIPPOSITION st2 where t.mmsi=st2.mmsi) as BDISTANCE from basic_fusionrealtime t where t.mmsiorarpaid=mmsiorarpaid order by t.mmsi case when...then...else 1234select t.guid,t.shipname,t.mmsi,t.sog,t.cog,t.lon,t.lat, case when t.datatype='F' then '是' else '否' end as datatype,t.mmsi as loca from basic_fusionrealtime t where t.mmsi not in(select t2.qdmmsi from basic_ferryboatsmsg t2) and t.inrange=0 order by t.shipname MyBatis中List&lt;Map&lt;String,String&gt;&gt;参数 123&lt;foreach collection=\"list\" item=\"item\" index=\"index\" separator=\";\"&gt; update table set is_ok=#&#123;item.is_ok&#125; where Admin_id=#&#123;item.Admin_id&#125; &lt;/foreach&gt; XML CDATA &lt;![CDATA[]]&gt;中的文本不会被解析,即可以自由的使用&gt;&lt;等字符。 屏蔽鼠标右键 通过绑定空事件屏蔽鼠标右键 123456789//屏蔽鼠标右键function disableMouseRigth()&#123; $(\"body\").bind(\"contextmenu\", function()&#123; return false; &#125;); $(\"body\").bind(\"selectstart\", function()&#123; return false; &#125;);&#125; 记录用户操作日志 思路:在Filter中根据uri来判断用户进行的操作(查询与uri对应的操作名称的表，可能一个uri对应多个操作)，将用户的的信息(包括用户的ip地址,浏览器类型，操作名，用户名，操作时间记录到日志表中。) Filter中可以这样写: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SessionFilter implements Filter &#123; /** * 记录用户操作，是否有登陆的过滤器。 */ public void doFilter(ServletRequest request,ServletResponse response, FilterChain fc) throws IOException, ServletException &#123; int mark = 0; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse)response; HttpSession session = req.getSession(); //从系统session集合中验证是否存在 SessionMap smap = SessionMap.getMysessionMap(); HttpSession nowSession = smap.getSession(session.getId()); if(nowSession==null)&#123; mark = 1; &#125;else&#123; //session中是否有用户 if(session.getAttribute(\"user\")==null)&#123; mark = 1; &#125; &#125; if(mark==0)&#123; sys_userinfo user = (sys_userinfo) session.getAttribute(\"user\"); String uri = req.getRequestURI(); ApplicationContext applicationContext = SpringContextLoaderListener.getApplicationContext(); IUserLogServices UserLogServices = (IUserLogServices) applicationContext.getBean(\"UserLogServices\"); List&lt;Map&lt;String, Object&gt;&gt; logs = UserLogServices.getlogcontent(uri); for(Map&lt;String, Object&gt; log : logs)&#123; String content = (String) log.get(\"FUNCTIONLOG\"); UserLogServices.setuserlog(req.getRemoteAddr(), user, content); &#125; fc.doFilter(req, res); &#125;else&#123; //没有session中的用户信息跳转回登录页面 RequestDispatcher rd = request.getRequestDispatcher(\"login.do?info=用户名或密码错误！\"); rd.forward(request,response); &#125; &#125;&#125; 感觉不好的地方 代码组织结构 所有js代码都写在jsp中 script标签放在页面的开头（应该放在body闭合标签前），放在开头影响页面的加载 内嵌大量css 频繁使用js插入元素 使用js动态生成元素引发重排重绘，大量使用造成性能严重下降。 冗余标签 使用表格标签布局造成许多冗余标签，影响文档阅读。 使用一个表单记录菜单的开启关闭状态，我觉得使用一个类名来表示或者一个全局标志位即可。 iframe 页面引用别的页面的js使得代码结构变得混乱。 每个页面都要重新插入库 多个定时器 使用多个不同时间(setInternal)的定时器，可能造成冲突，我认为应该将所有需要定时的内容写在一个定时器中。 命名不规范 在设置属性的函数名使用getXXX 有的类用驼峰命名法，有的使用匈牙利命名法。 JS多线程 有的使用Concurrent.Thread.js，有的地方使用setTimeout,有的地方使用setInterval来编写js线程代码，使得结构混乱，代码容易发生冲突。","tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"X市数据管理系统分析","date":"2017-02-14T08:41:22.289Z","path":"2017/02/14/X市数据管理系统/","text":"X市数据管理系统分析 X市数据管理系统功能: 对数据基本的操作，包括增、删、改、查 以图表的方式展示数据 附件的上传、下载 Excel导入导出 具有地图模块显示二维地图，点击定位，根据导入的坐标定位到地图相应位置并显示与坐标相应的轮廓。 基础数据管理，可以增加基础数据(比如:工程级别、类型、施工状态等)，便于系统扩展。 用户权限管理，通过用户关联角色的方式管理用户的权限。 后台:使用了Spring,Spring MVC框架, 前台:jQuery,EasyUI,ArcGIS 数据库:使用的数据库为Oracle,与数据库的交互使用的是Spring JPA的实现和Spring JDBCTemplate, &lt;!-- more --&gt; 值得注意的地方 Session保存常用对象 session对象不仅保存了用户对象还直接保存了用户名,用户名很常用,因此这种做法可以节省大量的时间 12session.setAttribute(\"user\", user);session.setAttribute(\"username\", username); 自定义标签用于权限控制 最终目标 将每个用户划分到不同的角色，每个角色设置不同的权限，用以管理控制每个用户的权限 角色管理图 用户管理图 不同用户登陆的效果图 实现思路 建立一个Resource表,表每一项都是用户可以操作的动作每一项都包含一个自定义的权限标签ID。建立一张Role表,Role与Resource是多对多的关系,建立一张User表,User与Role也是 多对多关系。执行自定义标签，查询用户是否具有该标签的ID,使用JPA能够自动进行关联查询。因为EasyUI在节点关闭且该节点下没有子节点时，在展开时会向后台传递该节点ID以请求节点JSON数据,所以可以通过Resource表自关联实现数据的树形菜单。 使用自定义标签来进行权限控制,有权限则显示相应标签否则不显示标签 privilege.xltd 123456789101112131415161718192021222324&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;privilege&lt;/description&gt; &lt;display-name&gt;tecoa&lt;/display-name&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tecv&lt;/short-name&gt; &lt;uri&gt;dms&lt;/uri&gt; &lt;tag&gt; &lt;description&gt;如果有权限，则显示相应的标签&lt;/description&gt; &lt;name&gt;privilege&lt;/name&gt; &lt;tag-class&gt;TagUtil&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;description&gt;所需资源表的id属性值&lt;/description&gt; &lt;name&gt;id&lt;/name&gt; &lt;!-- 属性是否必须，默认为false --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- 是否可以在属性中使用表达式 --&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 标签类 12345678910111213141516171819202122232425262728293031//置于Spring管理下@Componentpublic class TagUtil extends TagSupport &#123; private static final long serialVersionUID = -3739263210672265762L; private String id; private int flag = SKIP_BODY; @Override public int doStartTag() throws JspException &#123; User user = (User) pageContext.getSession().getAttribute(\"user\"); //对于没有登陆的用户或者没有权限的用户 if (EmptyUtil.isObjEmpty(user) || EmptyUtil.isObjEmpty(user.getResourceCodes()) || user.getResourceCodes().isEmpty()) &#123; flag = SKIP_BODY;//跳过标签体 &#125;else if (\"admin\".equals(user.getUsername())) &#123; flag = EVAL_BODY_INCLUDE;//输出标签体的内容 &#125;else&#123; //for(String code : user.getResourceCodes())&#123; if(user.getResourceCodes().contains(id))&#123; flag = EVAL_BODY_INCLUDE; &#125;else&#123; flag = SKIP_BODY; &#125; //&#125; &#125; return flag; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 基础数据类型扩展 一些基本的数据类型(比如图片格式、项目完成状态、项目等级)可能会随着用户的使用而修改，为了增加系统的扩展性，加入了基础数据类型管理这个功能。 实现思路 建立一张基础数据表,用一个字段(flag)标志不同的基础数据类型(海岛等级(island_grade)、图像数据类型(img_dataype)、所属海区(sea_area)),使用一个字段(value)表示显示的名称。对于可扩展的数据类型，从后台根据标志位(flag)查询出值后，放入前台的下拉框(combobox)中。 多级下拉框(combobox) 省下拉框选择后,市下拉框才有值,市下拉框选择后，县下拉框才有值。 实现思路 一级下拉框在页面初始化后，将类型传入后台获取该下拉框全部的值。由一级下拉框的选择事件触发ajax与后台交互,将一级下拉框选中的值的ID做为Pid(父类ID)、类型作为参数传入后台获取二级下拉框的所有项,多级下拉框与此同理。 一些不错的工具类 CreateUserByAndDate根据session中保存的用户名来自动的添加数据库中的创建人、创建时间、更新人、更新时间 EmptyUtil判断对象是否为空 感觉不好的地方 混用中英文命名 一些代码的组织不太好,比如Excel导入 12345678//将所有的导入逻辑都写在一个方法中造成了这个方法代码量巨大(达到了8000多行),造成了维护上的困难。我认为至少应该要将导入的逻辑分成散为其他的函数(即将if,else if 逻辑里面的代码块重构为一个方法)，以便于以后Excel导入的更新public List&lt;Object&gt; excelImport(Class&lt;?&gt; clazz, InputStream in, String createBy) throws Exception &#123; if (\"dms.vo.sea.FunctionDivisions\".equals(clazz.getName()))&#123; //... &#125;else if(\"dms.vo.sea.OwnerProject\".equals(clazz.getName()))&#123; //... &#125;&#125; 修改官方的jar包。为了使用jotm管理分布式事务，但是spring-tx，4.2版本中已经废弃了jotm库。公司采取了将在jar包中加入jotm的java文件,使得jotm可以使用,这种方法为以后的开发、维护埋下了巨大的隐患。 用户体验较差,比如:查询、登陆无法回车执行,查看一条记录不能双击执行","tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"2016年终总结与未来展望","date":"2016-12-31T15:13:31.605Z","path":"2016/12/31/2016年终总结与未来展望/","text":"2016年终总结与未来展望 ​ 我是一名二本学校电子科学与技术的在校生，目前正在一家公司实习，岗位是Java开发。 ​ 今年开学时，我知道大学所剩的时间不多了。我不想考研，因此找一份自己喜欢的工作就成了合理的选择，思来想去觉得自己只有编程还谈得上喜欢。本专业的嵌入式编程还要涉及硬件，对于硬件我实在是不拿手，不仅仅不擅长焊元器件，硬件故障也不知道该怎么判断，再加上国内嵌入式行业发展前景不够好，种种原因让我选择了软件的开发。开始时，我通过慕课网的视频以及一些网站的教程开始学习编程，不得不说通过视频这种被动的学习方式确实让人不会感到枯燥，一天学习七八个小时完全不疲劳。但是这种学习方式也使得我动手能力极度匮乏，而且这样的学习方式也让我养成了依赖和惰性。为了摆脱这种惰性，也为了牢固自己的基础，我开始了看起了书籍，十分感谢《JavaScript DOM编程艺术》、《Head First Servlet &amp; JSP》是这两本书让我知道了专业书籍可以很有趣味、厚的书籍不一定就晦涩难懂。看了一段时间的书籍之后，我觉的我不能在这样下去了，理论是学不完的而编程是一个需要实战的东西，我不能只是写Demo这样的程序，应该要进行些实战。于是我就开始尝试着写一个自己感兴趣的项目。不上手不知道一上手吓一跳，很多东西到实际操作的时候，根本就想不起来，只能再去查、再去看，碰到很多奇奇怪怪的问题，感到自己很无能、怀疑起自己的能力来。但幸运的是最后还是在自己的努力下完成了项目。感觉对这个软件就像自己的孩子一样，一方面对觉得它百般的不好，一方面又不允许别人否认它。 &lt;!-- more --&gt; ​ 通过一年磕磕绊绊的学习，我发现了我不少的毛病。第一，有严重的拖延症，总是将重要的事情放在最后做。第二，不能很好的控制自己，早睡早起的目标现在都还没实现。第三，死脑筋，代码一出问题就不断的实验尝试，或者不断的去网上找答案，直到耗光自己的精力(我认为应该先分析，尝试自己解决。没成功后再去网上找答案，如果没找到答案，应该先放着去完成其他事，过一段时间后再回来尝试解决)。第四，缺少沟通，就连有名的github也是到最近才会使用。第五，没有正确对待bug，当我发现bug可以被绕过，就采取绕过的办法，没有认真的分析bug产生的原因。 ​ 当然一年也有不少成功的事：1.成功的考下了驾照（虽然科二考了三次）。2.通过自己努力的自学成功的被公司录取软件开发实习生（虽然不是什么大公司，而且也是我面试失败八次后才被录取）。3.认识了一些圈内的大牛（虽然是我认识他们，他们不认识我）。4.对软件设计有了更细致的了解（虽然也不知道对不对）。5.了解了不少提高效率的软件，开发工具（工具太多反而用不过来）。6.变的爱看书了（虽然读的还是很慢）。总之，一年的时间我也有了不小的成长，无论是在技能上还是学习能力上。今年流行一句话，不忘初心、方的始终。现在，我的编程之路也算是开始了，我思考了下我的初心是对编程、软件的热爱，我希望我将来一个人能够写出完整的有创意的不那么大的小程序、小软件，对于大的工程上到架构下到细枝末节能够知道、理解。不希望自己成为一个见识短浅、害怕学习、只知道搬砖的程序猿。 ​ 对于未来的展望，首先就是能够改变自己的态度、习惯。然后希望能够跟其他的人有更多的交流。对于技能方面，希望自己使用的技术栈能够对底层了解的更加深刻，同时希望自己能够有更广阔的视野。具体一点，阅读30本以上好书。github贡献总计超过200天。","tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"未来世界的幸存者","date":"2016-12-31T08:38:27.573Z","path":"2016/12/31/未来世界的幸存者/","text":"未来世界的幸存者 这本书是由阮一峰在2016年写的一本开源书籍，不少的篇章都是以前的博文，经过整理、编排后而发布的书。书中有着大量作者对社会、职业和发展方向的思考，以下是对于我来说比较印象深刻、比较有启发的篇章所归纳而成。 &lt;!-- more --&gt; 旧世界的崩塌 作者由AlaphaGo打败李世石事情、无人车的发明,引发思考，人工智能已经达到了很高的水准，随着社会进一步的发展，人工智能很可能代替现在的各种岗位，什么样的岗位是安全的、什么样的人是对社会有用的人？并且还看到随着技术的发展，人们能够在虚拟世界获得的满足越来越高，那么奋斗的意义何在？ 作者认为世界上没有安全的职业，作者以两个例子，苹果公司表示不支持flash动画而导致flash工程师这个职位消失。诺基亚的塞班系统败给智能手机导致,塞班系统工程师失业。由此得出世界没有安全的职业。 作者认为即使终生学习，也不见得可以保证自己的竞争力，因为技术行业技术层出不穷，随着年龄的增长，很难向年轻人一样保持高度的热情与学习能力。等到技术跟不上时代时，就是被行业淘汰的时候了。因此呼吁我们提升:个性服务能力、人格魅力能力、创意能力、决策领导能力，注重底层知识(因为底层知识不容易变更,懂了底层知识更容易学习和使用新技术)。 作者还提到上班和下班已经过时,根据研究表明不用到公司上班的工作效率，明显高于要到公司上班的工作效率，并且有一些公司开始实行了这种方案，也有一些长期接外包项目的人和公司达成了雇佣关系。之所以无法得到推行，是因为人具有惰性，没有合理的监督手段，员工可能无法按时无法完成工作。 人生的B计划 人生的B计划中提到人生应该要有应急的B计划。它与现在的工作不同，最好不是同一个行业，它比现在的工作要冒险，但是可以给你带来很高的热情，它应该是你现在就能着手准备的，等到出现突发变故的时候，它能够让你更快的适应这个变故（行业不景气等），重新融入这个社会。 Stay hungry, Stay foolish 的原义 文中提到乔布斯在斯坦福演将的一句话stay hungry,stay foolish并放上了乔布斯引用这句话的原照片，虽然文中作者没有提到这句话具体的意思，但是看到这张晨光洒在乡间小路上的照片我想我跟乔布斯的心情是一样的，充满着对未知冒险的激动澎湃的心情。 新方向 个性也是一种竞争力 在这一节中以papi酱获得1200万风投为例子说明了在技术不断发展的当下，技术不断的消除差异，正因此人们也开始越来越重视个性。一个人若能够拥有的粉丝(支持者)数量，表现了他对社会、对市场的影响力，这也同样表现了他的个性受到的认可程度。当一个东西被大量承认价值，并且稀少时，那么自然就珍贵。","tags":[{"name":"书评","slug":"书评","permalink":"http://yoursite.com/tags/书评/"}]}]