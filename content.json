[{"title":"dojo DOM学习","date":"2017-03-08T05:57:21.660Z","path":"2017/03/08/dojoDom学习/","text":"dojo DOM学习dojo致力于提供简单、高效、跨浏览器的DOM操作。 dojo/dom 简单的id检索，判断是否为子元素 dom-construct 创建、删除、移动节点 dom-attr 属性相关操作 dom-class 类相关操作 dom-form 表单相关操作 dom-style 样式相关操作 dom-prop 元素属性相关操作 dom-geometry 元素位置、大小信息等。 dojo/dom1234//获取Id为one的元素，不存在则返回空。dom.byId(\"one\");//isDescendant(node,ancestor)判断是否为后代元素if(dom.isDescendant(\"bar\", \"foo\"))&#123; ... &#125; dojo/dom-construct12345678910111213141516171819202122//refNode参考节点,pos:位置信息(after,before,last,first,only,replace)create(tag,attrs,refNode,pos)//Example:domConstruct.create(\"li\", &#123; innerHTML: \"Seven\", className: \"seven\", style: &#123; fontWeight: \"bold\" &#125;&#125;, three, \"after\");//删除节点通过IDdestroy(node)//删除所有子节点通过IDempty(node)//放置节点，通过ID或者新建节点place(node,refNode,position)//Example:domConstruct.place(\"&lt;li&gt;&lt;/li&gt;\", \"someUl\", \"first\");//实例化一个html片段，返回相应的DOMtoDom(frag,doc) dojo/dom-attr12345678910//通过节点ID或节点,获取属性get(node,name)//从元素属性或者节点属性中获取值getNodeProp(node,name)//判断元素是否有属性has(node,name)//移除某个节点属性remove(node,name) //设置一个属性到html元素中set(node,name,value) dojo/dom-class12345678910//添加类名add(node,classStr)//是否包含类名contains(node,classStr)//移除类名remove(node,classStr) //移除和替换类replace(node,addClassStr,removeClassStr) //切换类,condition:true添加,false删除toggle(node,classStr,condition) dojo/dom-form12345678//序列化表单字段为一个js对象(一般的表单为字符串，多选框为列表)fieldToObject(inputNode)//序列化为json字符串toJson(formNode,prettypPrint)//序列化表单为一个对象toObject(formNode)//返回用于查询的字符串toQuery(formNode) dojo/dom-prop1234//获取html元素属性get(node,name)//设置html元素属性set(node,name,value) dojo/dom-style12345678//获取样式值get(node,name)//获取计算后的样式值getComputedStyle(node)//设置样式值set(node,name,value) //将样式值转换为像素值（IE中），其他返回一个数值。toPixelValue(node,value) dojo/dom-geometry12345678//返回&#123;x,y&#125;对象x,y是坐标docScroll(doc) //返回&#123;w,h,x,y&#125;等信息position(node,includeScroll)//修复左滚动值为负值(IE为正值)fixIeBiDiScrollLeft(scrollLeft,doc)//判断当前语言环境是否左到右isBodyLtr(doc) dojo/domReady延迟require()/define()回调直到完成DOM解析。 Dom函数DOM API","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"dojo","date":"2017-03-07T03:52:03.920Z","path":"2017/03/07/dojo起步/","text":"dojo起步简介dojo是前端js的一个框架,支持js异步加载机制,对js的语句进行了优化，还提供打包工具可以优化JS代码，还提供了所有的UI组件，支持IE6以上的浏览器。dojo解决了企业级开发中大量加载JS导致的浏览器崩溃问题。 Getting StartedHello Dojo模块的使用1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Tutorial: Hello Dojo!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"greeting\"&gt;Hello&lt;/h1&gt; &lt;!-- load Dojo --&gt; &lt;!-- 此处只是加载dojo的异步加载模块,包括require,define两个全局函数 --&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\" data-dojo-config=\"async: true\"&gt;&lt;/script&gt; &lt;script&gt; require([ &lt;!-- dom操作相关的模块 --&gt; 'dojo/dom', 'dojo/dom-construct' &lt;!-- 异步加载模块，使用回调函数的机制 --&gt; ], function (dom, domConstruct) &#123; var greetingNode = dom.byId('greeting'); domConstruct.place('&lt;em&gt; Dojo!&lt;/em&gt;', greetingNode); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模块的定义(参考路径是dojo的根目录)1234567891011121314151617181920define([ 'dojo/dom'], function(dom)&#123; var oldText = &#123;&#125;; return &#123; setText: function (id, text) &#123; var node = dom.byId(id); oldText[id] = node.innerHTML; node.innerHTML = text; &#125;, restoreText: function (id) &#123; var node = dom.byId(id); node.innerHTML = oldText[id]; delete oldText[id]; &#125; &#125;;&#125;); 组合使用CDN模块与自定义模块1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Tutorial: Hello Dojo!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=\"greeting\"&gt;Hello&lt;/h1&gt; &lt;!-- configure Dojo --&gt; &lt;script&gt; var dojoConfig = &#123; async: true, //配置自定义的路径 packages: [&#123; name: \"demo\", location: location.pathname.replace(/\\/[^/]*$/, '') + '/demo' &#125;] &#125;; &lt;/script&gt; &lt;!-- load Dojo --&gt; &lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\"&gt;&lt;/script&gt; &lt;script&gt; require([ 'demo/myModule' ], function (myModule) &#123; myModule.setText('greeting', 'Hello Dojo!'); setTimeout(function () &#123; myModule.restoreText('greeting'); &#125;, 3000); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 等待DOM加载123456789require([ 'dojo/dom', //domReady为插件,通过模块标识符后带\"!\"来激活， //dom加载完毕才执行回调。 'dojo/domReady!'], function (dom) &#123; var greeting = dom.byId('greeting'); greeting.innerHTML += ' from Dojo!';&#125;); 使用dojoConfig配置dojodojoConfig相当于将配置发送到服务器上，服务器接收参数后定制模块。配置参数是在dojo/_base/config下。dojoConfig必须写在require前。dojoConfig两种配置方式: 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 一:使用全局变量dojoConfig --&gt;&lt;!-- set Dojo configuration, load Dojo --&gt;&lt;script&gt; dojoConfig= &#123; has: &#123; \"dojo-firebug\": true &#125;, parseOnLoad: false, foo: \"bar\", async: true &#125;;&lt;/script&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\"&gt;&lt;/script&gt;&lt;script&gt;// Require the registry, parser, Dialog, and wait for domReadyrequire([\"dijit/registry\", \"dojo/parser\", \"dojo/json\", \"dojo/_base/config\", \"dijit/Dialog\", \"dojo/domReady!\"], function(registry, parser, JSON, config) &#123; // Explicitly parse the page parser.parse(); // Find the dialog var dialog = registry.byId(\"dialog\"); // Set the content equal to what dojo.config is dialog.set(\"content\", \"&lt;pre&gt;\" + JSON.stringify(config, null, \"\\t\") + \"```\"); // Show the dialog dialog.show();&#125;);&lt;/script&gt;&lt;!-- and later in the page --&gt;&lt;div id=\"dialog\" data-dojo-type=\"dijit/Dialog\" data-dojo-props=\"title: 'dojoConfig / dojo/_base/config'\"&gt;&lt;/div&gt;&lt;!-- 二:写在script标签中 --&gt;&lt;script src=\"//ajax.googleapis.com/ajax/libs/dojo/1.10.4/dojo/dojo.js\" data-dojo-config=\"has:&#123;'dojo-firebug': true&#125;, parseOnLoad: false, foo: 'bar', async: 1\"&gt;&lt;/script&gt; 使用has()配置特性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 has: &#123; //启用firebug lite,chrome中的firebug调试插件 \"dojo-firebug\": true, \"dojo-debug-messages\": true, \"dojo-amd-factory-scan\": false &#125;``` #### 加载配置```json//配置异步加载的基本urlbaseUrl: \"/js\",//配置包名和位置packages: [&#123; name: \"myapp\", location: \"/js/myapp\" &#125;],//使用dojo代表dojo16map: &#123; dijit16: &#123; dojo: \"dojo16\" &#125; &#125;,//定制模块到不同的路径packages: [ \"package1\", \"package2\" ], paths: &#123; package1: \"../lib/package1\", package2: \"/js/package2\" &#125;//等价于 packages: [ &#123; name: \"package1\", location: \"../lib/package1\" &#125;, &#123; name: \"package2\", location: \"/js/package2\" &#125; ],//是否异步加载async: true,//dojo加载完毕就开始加载deps: [\"dojo/parser\"],//当文档和deps加载完毕后，使用dojo/parser模块进行解析parseOnLoad: true,//deps中的加载完毕后执行callback: function(parser) &#123; // Use the resources provided here &#125;,//发出模块请求后的等待时间waitSeconds: 5,//不使用缓存策略cacheBust: true 其他的配置对象其他模块中使用的配置对象,主要是dojox,dijit。 Dijit EditorallowXdRichTextSave dojox GFXdojoxGfxSvgProxyFrameUrl, forceGfxRenderer, gfxRenderer dojox.html metricsfontSizeWatch dojox.io transports and pluginsxipClientUrl, dojoCallbackUrl dojox.imagepreloadImages dojox.analytics pluginssendInterval, inTransitRetry, analyticsUrl, sendMethod, maxRequestSize, idleTime, watchMouseOver, sampleDelay, targetProps, windowConnects, urchin dojox.cometdcometdRoot dojox.form.FileUploaderuploaderPath dojox.mobilemblApplyPageStyles, mblHideAddressBar, mblAlwaysHideAddressBar, mobileAnim, mblLoadCompatCssFiles 参考链接:Hello Dojo!Configuring Dojo","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"汽渡船舶防碰撞预警系统平台","date":"2017-02-25T14:24:53.588Z","path":"2017/02/25/汽渡船舶防碰撞预警系统平台/","text":"汽渡船舶防碰撞预警系统平台汽渡船舶防碰撞预警系统平台功能: 页面动态显示船舶（包括在地图上显示船舶的位置，船舶的航行速度,点击定位能定位到船舶） 提示碰撞警告（查表当将会出现的碰撞时间大于当前时间则生成提示信息，有的船能生成碰撞信息保存到数据库） 推送警告信息(只是将警告信息插入到指定的数据表中) 显示船舶历史轨迹动画 可以在地图上管理标注（标注类型有:点、多段线、多边形等标注）， 基本数据的增删改查、以图表方式展示数据 具有用户操作日志，记录用户的每一个操作。 具有权限管理，给不同的用户设置不同的权限。(也是通过用户关联爹角色形式。) 能够扩展基本数据，便于系统的灵活扩展。 对于地图的操作有:放大、缩小、测量、显示不同的底图（包括矢量图、影像图、黑暗图）使用到的框架和库:后台框架:Spring、Spring MVC、MyBatis前台框架:jQuery、Easy UI、arcgis for js 3.20、jWebAudio（音频库）、Cocurrent.Thread.jsjQuery插件:ZeroModal(jQuery弹出层插件)、uploadPreview、ajaxFileUpload、jQuery.cookie数据库:Oracle 值得注意的地方ArcGIS API for JSArcGIS中，地图由图层组成。GraphicLayer用于创建几何图形层，自定义的图形、绘制的图形都放置其上。ArcGISDynamicMapServiceLayer用于创建ArcGIS服务中得到的图层(背景图)。放置在GraphicLayer上的图形(Graphic)有两种元素构成，记号(Symbol),几何(Geometry)组成。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 用到的ArcGIS API for JS * ?:代表可选参数 *//*map及其相关API*///\"esri/map\"var myMap = new Map(divId, options?);//新建一个Map,divId为使用的html标签myMap.addLayer(layer,index?)//添加图层myMap.setExtent(extent, fit?)//设置地图的范围,定位也是通过这个API实现的//\"esri/SpatialReference\"new SpatialReference(wkid)//定义一个空间参考,wkid是数字//\"esri/geometry/Extent\"new Extent(xmin, ymin, xmax, ymax, spatialReference)//右上角与左下角的坐标,/*layer及其相关API*///\"esri/layers/GraphicsLayer\"var gLayer = new GraphicsLayer(options?)//新建图层,建立的是可在上面添加东西的图层gLayer.add(graphic)//添加图形gLayer.remove(graphic)//移除图形//\"esri/layers/ArcGISDynamicMapServiceLayer\"new ArcGISDynamicMapServiceLayer(url, options?)//使用发布arcgis服务作为图层//\"esri/InfoTemplate\"new InfoTemplate(title, content)//创建信息模板//\"esri/graphic\"var graphic = new Graphic(geometry?, symbol?, attributes?, infoTemplate?)//创建一个图形graphic.setInfoTemplate(infoTemplate);//设置图形的信息模板//\"esri/symbols/SimpleLineSymbol\" //创建一个记号 //style，例esri.symbol.SimpleLineSymbol.STYLE_SOLID //color,例esri.Color(\"#00f2fa\")var sys = new SimpleLineSymbol(style, color, width)//创建一个多边形var polylineJson = &#123; \"paths\" : [ [ [ obj.LON, obj.LAT ], [ nextObj.LON, nextObj.LAT ] ] ], \"spatialReference\" : &#123; \"wkid\" : 4326 &#125;&#125;;//\"esri/geometry/Polyline\",\"esri/graphic\"var gLine = new esri.Graphic(new esri.geometry.Polyline( polylineJson), sls);//\"esri/symbols/PictureMarkerSymbol\"new PictureMarkerSymbol(url, width, height)//创建一个图片记号//\"esri/symbols/SimpleMarkerSymbol\"new SimpleMarkerSymbol(style, size, outline, color)//简单标志记号/*操作Map相关工具的API*///\"esri/toolbars/draw\"var drawpoint = new Draw(map, options?)//生成一个用于画点的对象drawpoint.deactivate();//使工具栏无效，并且重新激活导航栏。drawpoint.on(\"draw-end\", addToMapC);//画图结束触发事件//\"esri/toolbars/navigation\"navigationToolbar = new Navigation(myMap);//创建地图工具对象navigationToolbar.activate(Navigation.ZOOM_IN);//放大navigationToolbar.activate(Navigation.ZOOM_OUT);//缩小 保存用户名和密码使用前台jQuery.cookie读取cookie，后台添加cookiejQuery.cookie相关API 123456//读取cookie,不存在返回null$.cookie('the_cookie'); //删除cookie$.cookie('the_cookie', null); //创建一个cookie并设置 cookie的有效路径(在默认情况下，只有设置 cookie的网页才能读取该 cookie。如果想让一个页面读取另一个页面设 )： $.cookie('the_cookie', 'the_value', &#123; expires: 7, path: '/' &#125;); 后台添加cookie 123456789101112131415161718//添加cookieresponse.addCookie(setCookies(\"pwd\", user.getUserpwd()));//清除Cookiepublic void cleanCookie(HttpServletRequest req,HttpServletResponse res)&#123; Cookie[] cookies = req.getCookies(); EmptyUtil eu = new EmptyUtil(); for(Cookie c : cookies)&#123; if((!eu.isFieldEmpty(c.getName())))&#123; if(c.getName().equals(\"user\")||c.getName().equals(\"pwd\")||c.getName().equals(\"rememberUser\")||c.getName().equals(\"username\"))&#123; c.setValue(null); c.setMaxAge(0);// 立即销毁cookie c.setPath(\"/\"); res.addCookie(c); &#125; &#125; &#125;&#125; 防止用户重新登陆实现思路:设置一个sessionMap管理所有的session,当用户登陆时，检测sessionMap中是否存在该session，如果不存在则添加session到sessionMap中。如果存在，则比较两次登陆的IP是否相同，如果相同则只刷新session，如果不同则删去老的session添加新的session。因为用户操作需要权限，权限又跟cookie挂钩，所以去掉了session的用户在下一次操作时就会发现被挤出。 123456789101112131415161718192021222324252627282930313233343536373839404142public synchronized void addSession(HttpSession session,String username)&#123; if(session!=null)&#123; //防止重复登录，旧登录用户踢出 //addSessionMap是保存了所有session的map Set&lt;Map.Entry&lt;String, Object&gt;&gt; submap = appSessionMap.entrySet(); for(Map.Entry&lt;String, Object&gt; emap: submap)&#123; HttpSession subsession = (HttpSession) emap.getValue(); try &#123; String names = subsession.getAttribute(\"username\").toString(); if(names!=null&amp;&amp;names.equals(username))&#123; ApplicationContext applicationContext = SpringContextLoaderListener.getApplicationContext(); IUserLogServices UserLogServices = (IUserLogServices) applicationContext.getBean(\"UserLogServices\"); sys_userinfo user = (sys_userinfo) session.getAttribute(\"user\"); List&lt;sys_userlog&gt; sys_userlog = UserLogServices.getlastuserlog(user.getGuid()); //从日志中获取用户IP if(sys_userlog!=null&amp;&amp;sys_userlog.size()&gt;0)&#123; String newIp = (String) session.getAttribute(\"ip\"); String ip = sys_userlog.get(0).getIpaddress(); if(!ip.equals(newIp))&#123; UserLogServices.setuserlog(ip, user,\" 该账户在其他ip登录，当前操作用户已登出\"); &#125; &#125; appSessionMap.remove(emap.getKey()); break; &#125; &#125; catch (Exception e) &#123; appSessionMap.remove(emap.getKey()); break; &#125; &#125; //首次登录 if(appSessionMap.get(session.getId())==null)&#123; appSessionMap.put(session.getId(), session); &#125;else&#123; //再次登录更新session appSessionMap.remove(session.getId()); appSessionMap.put(session.getId(), session); &#125; &#125; &#125; 在select中使用select子句1234select (select st1.shipname from basic_ferryboatsmsg st1 where st1.qdmmsi=t.mmsi) as SHIPNAME,t.mmsi,t.lon,t.lat,t.cog,t.sog,t.timestr, (select st1.adistance from ELEC_SHIPPOSITION st1 where t.mmsi=st1.mmsi) as ADISTANCE, (select st2.bdistance from ELEC_SHIPPOSITION st2 where t.mmsi=st2.mmsi) as BDISTANCE from basic_fusionrealtime t where t.mmsiorarpaid=mmsiorarpaid order by t.mmsi case when…then…else1234select t.guid,t.shipname,t.mmsi,t.sog,t.cog,t.lon,t.lat, case when t.datatype='F' then '是' else '否' end as datatype,t.mmsi as loca from basic_fusionrealtime t where t.mmsi not in(select t2.qdmmsi from basic_ferryboatsmsg t2) and t.inrange=0 order by t.shipname MyBatis中List","tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"curses模块学习","date":"2017-02-17T14:26:05.822Z","path":"2017/02/17/curses模块学习/","text":"curses学习基本curses模块提供了以文本显示为基础的像linux的控制台的API,包括绘制以及键盘处理等 打开和关闭一个curses应用程序打开curses 12345678# 初始化curses,该函数根据不同设备返回一个windows对象代表整个屏幕,这个对象通常叫做stdscrstdscr = curses.initscr()# 使用curses通常要关闭回显,目的是读取字符尽在适当的环境下输出。curses.noecho()# 设置为立即响应模式curses.cbreak()# 使得程序能够处理特殊的按键如PgUp,Home等curses.keypad(1) 关闭cursesu. 12345678# 关闭字符终端功能curses.nocbreak()# 关闭特殊按键的接收stdscr.keypad(0)# 打开输入回显功能curses.echo()# 调用endwin()恢复默认设置curses.endwin() 可以导入curses.wrapper模块。这个函数做了一些初始化的工作，包括上面提到的和颜色的初始化。然后再执行你提供的函数，最后重置。而且被调用的函数写在try-catch中。也就是应用了curses.wrapper模块只需要考虑代码逻辑即可。 打开新窗口通常调用initscr()获取一个window对象代表全部屏幕。但是很多程序希望划分屏幕为几个小的窗口，为了重绘，擦出这些工作在小窗口中独立进行。newwin()函数就是用来新建一个新的窗口，需要给定窗口尺寸，并返回新的window对象的。curses需要你使用refresh()函数明确指出重绘窗口。 123begin_x = 20; begin_y = 7height = 5; width = 40win = curses.newwin(height, width, begin_y, begin_x) padpad是window的特例。pad可以比显示的屏幕大，一次只显示pad的一部分。创建一个pad很简单，只需要提供宽高即可。但是刷新pad需要提供屏幕上显示的部分pad的坐标。 123456789101112pad = curses.newpad(100, 100)# These loops fill the pad with letters; this is# explained in the next sectionfor y in range(0, 100): for x in range(0, 100): try: pad.addch(y,x, ord('a') + (x*x+y*y) % 26) except curses.error: pass# Displays a section of the pad in the middle of the screenpad.refresh(0,0, 5,5, 20,75) 同时由多个window或者多个pad，有一问题：刷新某个window或pad时屏幕会闪烁。 避免闪烁的方法：在每个window调用noutrefresh()方法。 然后使用refresh()方法的最后再调用doupdate()方法。 API显示字符或字符串,如果没有坐标，字符显示在上一次操作完的位置。 start_color()初始化了8中基本颜色：0:black, 1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan, and 7:white。 init_pair(n,f,b)修改颜色对n，让f为前景色，b为背景色。颜色对0天生的黑白色，不允许改。 1234# 修改color1为红色文本，白色背景：curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)# 使用：stdscr.addstr(0,0, \"RED ALERT!\", curses.color_pair(1)) getch()方法，这个方法暂停等待用户输入，getch()返回一个整数 ，在0到255之间，表示输入字符的ASCII值。打印255的是些特殊字符，比如Page Up,Home。 小例子显示为一个小房子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#! python3# -*- coding:utf-8 -*-import cursesfrom random import randrange# 代表窗口的全局变量stdscr = Nonex = Noney = Nonecont = 0def smoke(): global cont set_color(randrange(0, 3)) if cont == 0: stdscr.addch(y - 19, x - 6, ord('.')) elif cont == 1: stdscr.addch(y - 19, x - 6, ord('o')) elif cont == 2: stdscr.addch(y - 19, x - 6, ord('O')) elif cont == 3: stdscr.addch(y - 19 - 1, x - 7, ord('-')) stdscr.addstr(y - 19, x - 7 - 1, \"|.|\") stdscr.addch(y - 19 + 1, x - 7, ord('-')) elif cont == 4: stdscr.addch(y - 19 - 2, x - 7, ord('-')) stdscr.addstr(y - 19 - 1, x - 7 - 1, \"/ \\\\\") stdscr.addstr(y - 19, x - 7 - 2, \"| O |\") stdscr.addstr(y - 19 + 1, x - 7 - 1, \"\\\\ /\") stdscr.addch(y - 19 + 2, x - 7, ord('-')) elif cont == 5: stdscr.addch(y - 19 - 2, x - 7, ord(' ')) stdscr.addstr(y - 19 - 1, x - 7 - 1, \" \") stdscr.addstr(y - 19, x - 7 - 2, \" \") stdscr.addstr(y - 19 + 1, x - 7 - 1, \" \") stdscr.addch(y - 19 + 2, x - 7, ord(' ')) cont += 1 cont %= 6# 设置颜色def set_color(z): color = curses.color_pair(z) stdscr.attrset(color)# 显示房子def house(): global x global y x = curses.COLS // 2 y = curses.LINES - 2 set_color(0) # 显示房体 for i in range(20): stdscr.addch(y - 8, x - 10 + i, ord('_')) stdscr.addch(y, x - 10 + i, ord('_')) for i in range(8): stdscr.addch(y - i, x - 10, ord('|')) stdscr.addch(y - i, x + 9, ord('|')) # 显示门 for i in range(6): stdscr.addch(y - 3, x - 3 + i, ord('_')) stdscr.addch(y, x - 3 + i, ord('_')) for i in range(3): stdscr.addch(y - i, x - 3, ord('|')) stdscr.addch(y - i, x + 2, ord('|')) # 显示房顶 for i in range(10): stdscr.addch(y - 8 - i, x - 10 + i, ord('/')) stdscr.addch(y - 8 - i, x + 9 - i, ord('\\\\')) # 显示窗户 for i in range(8): stdscr.addch(y - 9, x - 4 + i, '_') stdscr.addch(y - 11, x - 4 + i, '_') for i in range(2): stdscr.addch(y - 9 - i, x - 5, '|') stdscr.addch(y - 9 - i, x + 4, '|') # 显示烟囱 for i in range(4): stdscr.addch(y - 15 + i, x - 7, '|') for i in range(2): stdscr.addch(y - 15 + i, x - 5, '|') for i in range(4): stdscr.addch(y - 15, x - 8 + i, '_') stdscr.addch(y - 17, x - 8 + i, '_') for i in range(2): stdscr.addch(y - 16 + i, x - 9, '|') stdscr.addch(y - 16 + i, x - 4, '|')def main(win): global stdscr stdscr = win # 判断终端是否可以显示颜色 if curses.has_colors(): bg = curses.COLOR_BLACK curses.init_pair(1, curses.COLOR_BLUE, bg) curses.init_pair(2, curses.COLOR_CYAN, bg) # 开启新行模式 curses.nl() # 关闭输入回显 curses.noecho() # 设置为非阻塞模式读取 stdscr.timeout(0) while True: # 显示房子 house() smoke() ch = stdscr.getch() if ch == ord('q') or ch == ord('Q'): return elif ch == ord('s'): # 部进显示 stdscr.nodelay(0) elif ch == ord(' '): # 非延迟显示 stdscr.nodelay(1) # 睡眠50ms curses.napms(50)if __name__ == '__main__': curses.wrapper(main) 结果展示: 参考链接cursesAPI参考文档python curses使用curses programming with pythoncurses DEMO","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"X市数据管理系统分析","date":"2017-02-14T08:41:22.289Z","path":"2017/02/14/X市数据管理系统/","text":"X市数据管理系统分析X市数据管理系统功能: 对数据基本的操作，包括增、删、改、查 以图表的方式展示数据 附件的上传、下载 Excel导入导出 具有地图模块显示二维地图，点击定位，根据导入的坐标定位到地图相应位置并显示与坐标相应的轮廓。 基础数据管理，可以增加基础数据(比如:工程级别、类型、施工状态等)，便于系统扩展。 用户权限管理，通过用户关联角色的方式管理用户的权限。后台:使用了Spring,Spring MVC框架,前台:jQuery,EasyUI,ArcGIS数据库:使用的数据库为Oracle,与数据库的交互使用的是Spring JPA的实现和Spring JDBCTemplate, 值得注意的地方Session保存常用对象 session对象不仅保存了用户对象还直接保存了用户名,用户名很常用,因此这种做法可以节省大量的时间 12session.setAttribute(\"user\", user);session.setAttribute(\"username\", username); 自定义标签用于权限控制最终目标 将每个用户划分到不同的角色，每个角色设置不同的权限，用以管理控制每个用户的权限 角色管理图 用户管理图 不同用户登陆的效果图 实现思路建立一个Resource表,表每一项都是用户可以操作的动作每一项都包含一个自定义的权限标签ID。建立一张Role表,Role与Resource是多对多的关系,建立一张User表,User与Role也是多对多关系。执行自定义标签，查询用户是否具有该标签的ID,使用JPA能够自动进行关联查询。因为EasyUI在节点关闭且该节点下没有子节点时，在展开时会向后台传递该节点ID以请求节点JSON数据,所以可以通过Resource表自关联实现数据的树形菜单。 使用自定义标签来进行权限控制,有权限则显示相应标签否则不显示标签 privilege.xltd 123456789101112131415161718192021222324&lt;taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\" version=\"2.0\"&gt; &lt;description&gt;privilege&lt;/description&gt; &lt;display-name&gt;tecoa&lt;/display-name&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;tecv&lt;/short-name&gt; &lt;uri&gt;dms&lt;/uri&gt; &lt;tag&gt; &lt;description&gt;如果有权限，则显示相应的标签&lt;/description&gt; &lt;name&gt;privilege&lt;/name&gt; &lt;tag-class&gt;TagUtil&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;description&gt;所需资源表的id属性值&lt;/description&gt; &lt;name&gt;id&lt;/name&gt; &lt;!-- 属性是否必须，默认为false --&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- 是否可以在属性中使用表达式 --&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 标签类 12345678910111213141516171819202122232425262728293031//置于Spring管理下@Componentpublic class TagUtil extends TagSupport &#123; private static final long serialVersionUID = -3739263210672265762L; private String id; private int flag = SKIP_BODY; @Override public int doStartTag() throws JspException &#123; User user = (User) pageContext.getSession().getAttribute(\"user\"); //对于没有登陆的用户或者没有权限的用户 if (EmptyUtil.isObjEmpty(user) || EmptyUtil.isObjEmpty(user.getResourceCodes()) || user.getResourceCodes().isEmpty()) &#123; flag = SKIP_BODY;//跳过标签体 &#125;else if (\"admin\".equals(user.getUsername())) &#123; flag = EVAL_BODY_INCLUDE;//输出标签体的内容 &#125;else&#123; //for(String code : user.getResourceCodes())&#123; if(user.getResourceCodes().contains(id))&#123; flag = EVAL_BODY_INCLUDE; &#125;else&#123; flag = SKIP_BODY; &#125; //&#125; &#125; return flag; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 基础数据类型扩展一些基本的数据类型(比如图片格式、项目完成状态、项目等级)可能会随着用户的使用而修改，为了增加系统的扩展性，加入了基础数据类型管理这个功能。 实现思路建立一张基础数据表,用一个字段(flag)标志不同的基础数据类型(海岛等级(island_grade)、图像数据类型(img_dataype)、所属海区(sea_area)),使用一个字段(value)表示显示的名称。对于可扩展的数据类型，从后台根据标志位(flag)查询出值后，放入前台的下拉框(combobox)中。 多级下拉框(combobox)省下拉框选择后,市下拉框才有值,市下拉框选择后，县下拉框才有值。 实现思路一级下拉框在页面初始化后，将类型传入后台获取该下拉框全部的值。由一级下拉框的选择事件触发ajax与后台交互,将一级下拉框选中的值的ID做为Pid(父类ID)、类型作为参数传入后台获取二级下拉框的所有项,多级下拉框与此同理。 一些不错的工具类 CreateUserByAndDate根据session中保存的用户名来自动的添加数据库中的创建人、创建时间、更新人、更新时间 EmptyUtil判断对象是否为空 感觉不好的地方 混用中英文命名 一些代码的组织不太好,比如Excel导入 12345678//将所有的导入逻辑都写在一个方法中造成了这个方法代码量巨大(达到了8000多行),造成了维护上的困难。我认为至少应该要将导入的逻辑分成散为其他的函数(即将if,else if 逻辑里面的代码块重构为一个方法)，以便于以后Excel导入的更新public List&lt;Object&gt; excelImport(Class&lt;?&gt; clazz, InputStream in, String createBy) throws Exception &#123; if (\"dms.vo.sea.FunctionDivisions\".equals(clazz.getName()))&#123; //... &#125;else if(\"dms.vo.sea.OwnerProject\".equals(clazz.getName()))&#123; //... &#125;&#125; 修改官方的jar包。为了使用jotm管理分布式事务，但是spring-tx，4.2版本中已经废弃了jotm库。公司采取了将在jar包中加入jotm的java文件,使得jotm可以使用,这种方法为以后的开发、维护埋下了巨大的隐患。 用户体验较差,比如:查询、登陆无法回车执行,查看一条记录不能双击执行","tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"2016年终总结与未来展望","date":"2016-12-31T15:13:31.605Z","path":"2016/12/31/2016年终总结与未来展望/","text":"2016年终总结与未来展望​ 我是一名二本学校电子科学与技术的在校生，目前正在一家公司实习，岗位是Java开发。 ​ 今年开学时，我知道大学所剩的时间不多了。我不想考研，因此找一份自己喜欢的工作就成了合理的选择，思来想去觉得自己只有编程还谈得上喜欢。本专业的嵌入式编程还要涉及硬件，对于硬件我实在是不拿手，不仅仅不擅长焊元器件，硬件故障也不知道该怎么判断，再加上国内嵌入式行业发展前景不够好，种种原因让我选择了软件的开发。开始时，我通过慕课网的视频以及一些网站的教程开始学习编程，不得不说通过视频这种被动的学习方式确实让人不会感到枯燥，一天学习七八个小时完全不疲劳。但是这种学习方式也使得我动手能力极度匮乏，而且这样的学习方式也让我养成了依赖和惰性。为了摆脱这种惰性，也为了牢固自己的基础，我开始了看起了书籍，十分感谢《JavaScript DOM编程艺术》、《Head First Servlet &amp; JSP》是这两本书让我知道了专业书籍可以很有趣味、厚的书籍不一定就晦涩难懂。看了一段时间的书籍之后，我觉的我不能在这样下去了，理论是学不完的而编程是一个需要实战的东西，我不能只是写Demo这样的程序，应该要进行些实战。于是我就开始尝试着写一个自己感兴趣的项目。不上手不知道一上手吓一跳，很多东西到实际操作的时候，根本就想不起来，只能再去查、再去看，碰到很多奇奇怪怪的问题，感到自己很无能、怀疑起自己的能力来。但幸运的是最后还是在自己的努力下完成了项目。感觉对这个软件就像自己的孩子一样，一方面对觉得它百般的不好，一方面又不允许别人否认它。 ​ 通过一年磕磕绊绊的学习，我发现了我不少的毛病。第一，有严重的拖延症，总是将重要的事情放在最后做。第二，不能很好的控制自己，早睡早起的目标现在都还没实现。第三，死脑筋，代码一出问题就不断的实验尝试，或者不断的去网上找答案，直到耗光自己的精力(我认为应该先分析，尝试自己解决。没成功后再去网上找答案，如果没找到答案，应该先放着去完成其他事，过一段时间后再回来尝试解决)。第四，缺少沟通，就连有名的github也是到最近才会使用。第五，没有正确对待bug，当我发现bug可以被绕过，就采取绕过的办法，没有认真的分析bug产生的原因。 ​ 当然一年也有不少成功的事：1.成功的考下了驾照（虽然科二考了三次）。2.通过自己努力的自学成功的被公司录取软件开发实习生（虽然不是什么大公司，而且也是我面试失败八次后才被录取）。3.认识了一些圈内的大牛（虽然是我认识他们，他们不认识我）。4.对软件设计有了更细致的了解（虽然也不知道对不对）。5.了解了不少提高效率的软件，开发工具（工具太多反而用不过来）。6.变的爱看书了（虽然读的还是很慢）。总之，一年的时间我也有了不小的成长，无论是在技能上还是学习能力上。今年流行一句话，不忘初心、方的始终。现在，我的编程之路也算是开始了，我思考了下我的初心是对编程、软件的热爱，我希望我将来一个人能够写出完整的有创意的不那么大的小程序、小软件，对于大的工程上到架构下到细枝末节能够知道、理解。不希望自己成为一个见识短浅、害怕学习、只知道搬砖的程序猿。 ​ 对于未来的展望，首先就是能够改变自己的态度、习惯。然后希望能够跟其他的人有更多的交流。对于技能方面，希望自己使用的技术栈能够对底层了解的更加深刻，同时希望自己能够有更广阔的视野。具体一点，阅读30本以上好书。github贡献总计超过200天。","tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"未来世界的幸存者","date":"2016-12-31T08:38:27.573Z","path":"2016/12/31/未来世界的幸存者/","text":"未来世界的幸存者这本书是由阮一峰在2016年写的一本开源书籍，不少的篇章都是以前的博文，经过整理、编排后而发布的书。书中有着大量作者对社会、职业和发展方向的思考，以下是对于我来说比较印象深刻、比较有启发的篇章所归纳而成。 旧世界的崩塌作者由AlaphaGo打败李世石事情、无人车的发明,引发思考，人工智能已经达到了很高的水准，随着社会进一步的发展，人工智能很可能代替现在的各种岗位，什么样的岗位是安全的、什么样的人是对社会有用的人？并且还看到随着技术的发展，人们能够在虚拟世界获得的满足越来越高，那么奋斗的意义何在？ 作者认为世界上没有安全的职业，作者以两个例子，苹果公司表示不支持flash动画而导致flash工程师这个职位消失。诺基亚的塞班系统败给智能手机导致,塞班系统工程师失业。由此得出世界没有安全的职业。 作者认为即使终生学习，也不见得可以保证自己的竞争力，因为技术行业技术层出不穷，随着年龄的增长，很难向年轻人一样保持高度的热情与学习能力。等到技术跟不上时代时，就是被行业淘汰的时候了。因此呼吁我们提升:个性服务能力、人格魅力能力、创意能力、决策领导能力，注重底层知识(因为底层知识不容易变更,懂了底层知识更容易学习和使用新技术)。 作者还提到上班和下班已经过时,根据研究表明不用到公司上班的工作效率，明显高于要到公司上班的工作效率，并且有一些公司开始实行了这种方案，也有一些长期接外包项目的人和公司达成了雇佣关系。之所以无法得到推行，是因为人具有惰性，没有合理的监督手段，员工可能无法按时无法完成工作。 人生的B计划人生的B计划中提到人生应该要有应急的B计划。它与现在的工作不同，最好不是同一个行业，它比现在的工作要冒险，但是可以给你带来很高的热情，它应该是你现在就能着手准备的，等到出现突发变故的时候，它能够让你更快的适应这个变故（行业不景气等），重新融入这个社会。 Stay hungry, Stay foolish 的原义文中提到乔布斯在斯坦福演将的一句话stay hungry,stay foolish并放上了乔布斯引用这句话的原照片，虽然文中作者没有提到这句话具体的意思，但是看到这张晨光洒在乡间小路上的照片我想我跟乔布斯的心情是一样的，充满着对未知冒险的激动澎湃的心情。 新方向个性也是一种竞争力在这一节中以papi酱获得1200万风投为例子说明了在技术不断发展的当下，技术不断的消除差异，正因此人们也开始越来越重视个性。一个人若能够拥有的粉丝(支持者)数量，表现了他对社会、对市场的影响力，这也同样表现了他的个性受到的认可程度。当一个东西被大量承认价值，并且稀少时，那么自然就珍贵。","tags":[{"name":"书评","slug":"书评","permalink":"http://yoursite.com/tags/书评/"}]}]