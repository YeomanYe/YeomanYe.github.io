title: 计算机程序的思维逻辑-泛型
tags:
    - Java
    - 笔记
    - 基础知识
comments: true
date: 2017-4-18
brief: 基础知识
categories:
    - 笔记
---
# [笔记]计算机思维逻辑-泛型
计算机程序的思维逻辑是“老马”的系列文章，文章通过Java语言来介绍计算机技术的本质。第四章节泛型，介绍了泛型的语法，JVM对泛型的处理机制，通配符，泛型的局限等内容。
[原文目录(35-37章)](http://www.cnblogs.com/swiftma/p/5631311.html)

<!-- more -->

## 基本概念
对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，将类型参数T擦除，替换为Object，插入必要的强制类型转换。Java虚拟机实际执行的时候，它是不知道泛型这回事的

使用泛型的好处:
- 更好的安全性
- 更好的可读性

泛型语法:
```java
//泛型类
public class DynamicArray<T extends Object>{}
//泛型方法
public static <T extends E> int indexOf(T[] arr,T elem);
//泛型接口
public interface Comparator<T>{};
```

虽然Integer是Number的子类，但`DynamicArray<Integer>`并不是`DynamicArray<Number>`的子类，`DynamicArray<Integer>`的对象也不能赋值给`DynamicArray<Number>`的变量

泛型是计算机程序中一种重要的思维方式，它将数据结构和算法与数据类型相分离，使得同一套数据结构和算法，能够应用于各种数据类型，而且还可以保证类型安全，提高可读性。

## 通配符
`<T extends E>`用于定义类型参数，它声明了一个类型参数T，可放在泛型类定义中类名后面、泛型方法返回值前面。

`<? extends E>`用于实例化类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的某个子类型。

```java
//参数只用于读取时,两种方法都行
public void addAll(DynamicArray<? extends E> c);
public <T extends E> void addAll(DynamicArray<T> c);
```

通配符`<? extends E>`,`<?>`标识的泛型形参,只能读不能写。能被类型参数替代(`<T extends E>`)。
```java
DynamicArray<Integer> ints = new DynamicArray<>();
DynamicArray<? extends Number> numbers = ints;
Number n = new Double(23.0);
Object o = new String("hello world");
numbers.add(n);
numbers.add(o);
```

泛型交换
```java
//这种写法会报错,?标示的泛型参数只能读不能写
public static void swap(DynamicArray<?> arr, int i, int j){
    Object tmp = arr.get(i);
    arr.set(i, arr.get(j));
    arr.set(j, tmp);
}
//改为这种写法就没问题了
private static <T> void swapInternal(DynamicArray<T> arr, int i, int j){
    T tmp = arr.get(i);
    arr.set(i, arr.get(j));
    arr.set(j, tmp);
}

public static void swap(DynamicArray<?> arr, int i, int j){
    swapInternal(arr, i, j);
}
```

如果允许写入Object或Number类型，则最后两行编译就是正确的，也就是说，Java将允许把Double或String对象放入Integer容器，这显然就违背了Java关于类型安全的承诺。

超类型通配符`<? super E>`。不能被类型参数替代。用于灵活比较

```java
//Comparable<T>接口内方法
public static <T extends Comparable<T>> T max(DynamicArray<T> arr)

class Base implements Comparable<Base>{
    private int sortOrder;
    
    public Base(int sortOrder) {
        this.sortOrder = sortOrder;
    }
    
    @Override
    public int compareTo(Base o) {
        if(sortOrder < o.sortOrder){
            return -1;
        }else if(sortOrder > o.sortOrder){
            return 1;
        }else{
            return 0;
        }
    }
}

class Child extends Base {
    public Child(int sortOrder) {
        super(sortOrder);
    }
}

//编译将会报错
DynamicArray<Child> childs = new DynamicArray<Child>();
childs.add(new Child(20));
childs.add(new Child(80));
Child maxChild = max(childs);
```
Java会将max方法的类型参数T推断为Child类型，但类型T的要求是extends Comparable<T>，而Child并没有实现Comparable<Child>，它实现的是Comparable<Base>。

应该使用超类型通配符`<? super E>`
```java
public static <T extends Comparable<? super T>> T max(DynamicArray<T> arr)
```

## 局限性
基本类型不能用于实例化类型参数(即`Pair<int>`写法是错误的)

类的类型信息属于Class类,可以通过Class<?> cls = obj.getClass()来获得该对象;但泛型无法获取该类型信息对象,`Pair<Integer>.class`错误;但具有Pair.class的写法

一个泛型对象的getClass方法的返回值与原始类型对象也是相同的
```java
Pair<Integer> p1 = new Pair<Integer>(1,100);
Pair<String> p2 = new Pair<>("Hello","world");
//结果都为true
System.out.println(Pair.class==p1.getClass());
System.out.println(Pair.class==p2.getClass());
```

类型擦除引起的错误
```java
class Base implements Comparable<Base>{}
//错误,泛型接口不能被两次实现,因为类型擦除后实际只能有一个
//可以通过继承实现泛型的类,复写父类的方法来实现
class Child extends Base implements Comparable<Child>{}

//不能这么定义重载方法
//因为类型擦除后,声明是一样的
public static void test(DynamicArray<Integer> intArr);
public static void test(DynamicArray<String> strArr);
```

不能通过类型参数创建对象，但可以创建泛型句柄`T t = new Object()`
```java
//这种写法错误
//由于类型擦除创建的都是Object对象
T elem = new T();
T[] arr = new T[10];
//只能使用反射机制创建
public static <T> T create(Class<T> type){
    try{
        return type.newInstance();
    }catch(Exception e){
        return null;
    }
}
```

不能用于静态变量和静态方法返回值
```java
//因为如果可行,对于每个实例化的对象都存在一个不同的类型,
//但类型擦除,singleton只有一份变成只存在一份静态变量和方法
//以下错误
public static T instance;
public static T getInstance(){return instance;}
```

多个类型限定的语法
> T extends Base & Comparable & Serializable

不能创建泛型数组(为了规避如下的问题)
```java
//如果可以创建泛型数组,则以下代码不会引起异常,但存在着隐患
Pair<Object,Integer>[] options = new Pair<Object,Integer>[3];
Object[] objs = options;
objs[0] = new Pair<Double,String>(12,34,"hello");
```

转换泛型容器为数组
```java
public E[] toArray(Class<E> type){
    Object copy = Array.newInstance(type,size);
    System.arraycopy(elementData,0,copy,0,size);
    return (E[])copy;
}
```