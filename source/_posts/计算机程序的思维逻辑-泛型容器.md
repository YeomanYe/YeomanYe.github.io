title: 计算机程序的思维逻辑-泛型容器
tags:
    - Java
    - 文章总结
    - 基础知识
comments: true
date: 2017-4-21
brief: 基础知识
categories:
    - 总结
---
# 计算机思维逻辑-泛型容器
计算机程序的思维逻辑是“老马”的系列文章，文章通过Java语言来介绍计算机技术的本质。第五章节泛型容器，剖析了各类容器，包括ArrayList、LinkedList、HashMap、HashSet、TreeMap、TreeSet、PriorityQueue、EnumMap等，介绍了容器基于的数据结构、容器的内部表示、容器的实现机制，如何通过抽像容器类定制容器、Collections方法等。
[原文目录(38-55章)](http://www.cnblogs.com/swiftma/p/5631311.html)

<!-- more -->

## 剖析ArrayList
### 内部组成
ArrayList内部组成，ArrayList元素的组织使用的是数组
```java
//存放数组元素
private transient Object[] elementData;
//记录实际元素个数
private int size;
//代表修改次数
private int modCount;
```

### 内部迭代器组成
实现了Iterable接口的对象都可以使用forEach方法
ArrayList内部迭代器:
```java
//下一个要返回的元素位置
int cursor;
//最后一个返回的索引位置
int lastRet = -1;
//期望修改次数
int expectedModCount = modCount;
```

迭代过程中不能使用ArrayList的方法来添加,删除,插入元素到ArrayList中,因为会造成expectedModCount与modCount不同(只能通过迭代器的方法来改变)

### 主要实现接口
ArrayList实现的主要接口
- Collection:表示一个数据集合，数据间没有位置或顺序的概念(包含contains,add等方法)
- List:扩展了Collection,表示有顺序或位置的数据集合(主要增加的方法indexOf,get,set,subList等方法)
- Iterable:可迭代性
- RandomAccess:标记接口,没有任何方法和变量(可以根据是否有无该接口而采用不同的算法)

### 与数组互换
ArrayList与数组的相互转换
```java
//返回对应的数组
intList.toArray();
//转换为ArrayList
int[] a = {1,2,3};
//asList()返回的不是一个ArrayList对象而是Arrays的一个内部类
List<Integer> list = new ArrayList<Integer>(Arrays.asList(a));
```

## 剖析LinkedList
### 内部组成
LinkedList内部是基于链表实现的
```java
//LinkedList内不能3个实例变量
transient int size = 0;
transient Node<E> first;
transient Node<E> last;
//Node内部
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

### 实现接口
实现的接口
- List:列表
- Queue:队列
- Deque:双向队列

常用API
```java
//Java没有Stack接口，Stack类已被废弃
//Deque具有与栈相关的方法
void push(E e);
E pop();
E peek();
//双端操作相关的函数
void addFirst(E e);
void addLast(E e);
E getFirst();
E getLast();
boolean offerFirst(E e);
boolean offerLast(E e);
E peekFirst();
E peekLast();
E pollFirst();
E pollLast();
E removeFirst();
E removeLast();
//方向迭代的方法
Iterator<E> descendingIterator();
```

## 剖析HashMap
### 内部组成
内部是由Entry数组进行结构数据组织，Entry又使用链表进行结构组织
```java
//table是一个Entry类型的数组，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
//键值对个数
transient int size;
//阈值，当size>=threshold时,进行扩容
int threshold;
//负载因子,表示整体上table被占用的程度，是一个浮点数，默认为0.75
//threadshold = loadFactor*size;
final float loadFactor;

//内部Entry实现
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;

    Entry(int h, K k, V v, Entry<K,V> n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }
} 
```

HashMap存取对象主要依赖于已存储的哈希值，而不是与其他对象进行比较。存取效率高O(1)，无顺序。

__注意：__因为保存了对象的hash值，因此当键对象发生改变时，可能无法找到对应的key。

![HashMap结构图](resources/images/HashMap结构图.png)

### 返回视图
返回视图,即对其进行改动，Map中也会相应改动
```java
Set<K> keySet();
Collection<V> values();
Set<Map.Entry<K, V>> entrySet();
```

## 剖析HashSet
### 内部组成
通过HashMap实现，HashSet只相当于键，值都是相同的固定值Object对象
```java
private transient HashMap<E,Object> map;

private static final Object PRESENT = new Object();
```

特点:
- 没有重复元素
- 可以高效的添加,删除，判断元素是否存在,效率都为O(1)
- 没有顺序

### API说明
批量操作的API
```java
// 保留参数集合，删除其他元素
boolean retainAll(Collection c)
// 批量添加,重复元素不添加,有一个添加成功返回true
boolean addAll(Collection c)
```

## 排序二叉树
排序二叉树，左子树不为空，左子树上所有节点都小于该节点;右子树不为空，右子树上所有节点都大于该节点。

查找(插入类似)
- 小于该节点,查找左子树
- 等于,即为该节点
- 大于带节点，查找右子树

遍历
- 访问左子树
- 访问当前节点
- 访问右子树

删除
- 叶子节点:直接删除
- 一个孩子:替换待删节点为孩子节点
- 两个孩子:右第一个节点替换父节点，删除该节点

大致平衡与高度平衡：
二叉树高度平衡,即任何节点的左右子树的高度差最多为一。AVL树，满足高度平衡的二叉树。

二叉树大致平衡,根到叶子节点的路径，没有一条路径长过两倍。红黑树,满足大致平衡的二叉树。

## 剖析TreeMap
### 内部组成
内部都是使用键的比较函数(或compare函数)进行比较的

TreeMap是用红黑树实现的,内部组成
```java
private final Comparator<? super K> comparator;
private transient Entry<K,V> root = null;
private transient int size = 0;

static final class Entry<K,V> implements Map.Entry<K,V> {
    K key;
    V value;
    Entry<K,V> left = null;
    Entry<K,V> right = null;
    Entry<K,V> parent;
    boolean color = BLACK;

    /**
     * Make a new cell with given key, value, and parent, and with
     * {@code null} child links, and BLACK color.
     */
    Entry(K key, V value, Entry<K,V> parent) {
        this.key = key;
        this.value = value;
        this.parent = parent;
    }
} 
```

### put源码(排序二叉树实现put)

```java
public V put(K key, V value) {
    Entry<K,V> t = root;
    if (t == null) {
        //为了检查key的类型和null，如果类型不匹配或为null，compare方法会抛出异常。
        compare(key, key); // type (and possibly null) check

        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    //不是第一次添加的情况
    //设置了comparable
    int cmp;
    Entry<K,V> parent;
    // split comparator and comparable paths
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    //不设置comparator的情况
    else {
    if (key == null)
        throw new NullPointerException();
    Comparable<? super K> k = (Comparable<? super K>) key;
    do {
        parent = t;
        cmp = k.compareTo(t.key);
        if (cmp < 0)
            t = t.left;
        else if (cmp > 0)
            t = t.right;
        else
            return t.setValue(value);
    } while (t != null);
    }
}
```

### 剖析TreeSet
基于TreeMap实现，内部组成
```java
//set背后的map
private transient NavigableMap<E,Object> m;
//PRESENT固定的共享值
private static final Object PRESENT = new Object();
```

## 数据结构-堆
满二叉树是指，除了最后一层外，每个节点都有两个孩子，而最后一层都是叶子节点，都没有孩子。

完全二叉树,满二叉树一定是完全二叉树，但完全二叉树不要求最后一层是满的，但如果不满，则要求所有节点必须集中在最左边，从左到右是连续的，中间不能有空的。

堆逻辑概念上是一颗完全二叉树，而物理存储上使用数组

最大堆是指，每个节点都不大于其父节点。根节点就是所有节点中最大的。

![最大_最小堆](resources/images/最大_最小堆.png)

### 添加元素
添加元素算法
- 添加元素到最后位置
- 与父节点比较若大/小(最大堆/最小堆)则交换直到根节点。这种自低向上比较、交换，使得树重新满足堆的性质的过程，我们称之为siftup。

![堆添加算法](resources/images/堆添加算法.png)

### 删除元素
删除元素算法
头部
- 用最后一个元素替换头部元素，并删掉最后一个元素。
- 将新的头部与两个孩子节点中较小的比较，如果不大于该孩子节点，则满足堆的性质，结束，否则与较小的孩子进行交换，交换后，再与较小的孩子比较和交换，一直到没有孩子，或者不大于两个孩子节点。这个过程我们般称为siftdown。

从中间删除:

与从头部删除一样，都是先用最后一个元素替换待删元素。不过替换后，有两种情况，如果该元素大于某孩子节点，则需向下调整(siftdown)，否则，如果小于父节点，则需向上调整(siftup)。

![堆删除元素](resources/images/堆删除元素.png)

### 初始化堆
将普通无序数组变为堆的过程我们称之为heapify

从最后一个非叶子节点开始，一直往前直到根，对每个节点，执行向下调整siftdown。换句话说，是自底向上，先使每个最小子树为堆，然后每对左右子树和其父节点合并，调整为更大的堆，因为每个子树已经为堆，所以调整就是对父节点执行siftdown，就这样一直合并调整直到根。这个算法的伪代码是：
```java
void heapify() {
    for (int i=size/2; i >= 1; i--)
        siftdown(i);
}
```

## 剖析PriorityQueue
PriorityQueue内部由堆实现,队头元素优先级最高

PriorityQueue从头部逐个删除元素有序

内部组成:
```java
//实际存储元素的数组
private transient Object[] queue;
//表示元素个数
private int size = 0;
//比较器对象,若为空，则要求元素实现Comparable接口
private final Comparator<? super E> comparator;
private transient int modCount = 0;
```

## 堆和PriorityQueue的应用
### 求前K个最大的元素
思路:维护一个长度为K的数组，最前面的K个元素就是目前最大的K个元素，以后每来一个新元素的时候，都先找数组中的最小值，将新元素与最小值相比，如果小于最小值，则什么都不用变，如果大于最小值，则将最小值替换为新元素。

代码实现
```java
public class TopK <E> {
    private PriorityQueue<E> p;
    private int k;

    public TopK(int k){
        this.k = k;
        this.p = new PriorityQueue<>(k);
    }

    public void addAll(Collection<? extends E> c){
        for(E e : c){
            add(e);
        }
    }

    public void add(E e) {
        if(p.size()<k){
            p.add(e);
            return;
        }
        Comparable<? super E> head = (Comparable<? super E>)p.peek();
        if(head.compareTo(e)>0){
            //小于TopK中的最小值，不用变
            return;
        }
        //新元素替换掉原来的最小值成为Top K之一。
        p.poll();
        p.add(e);
    }

    public <T> T[] toArray(T[] a){
        return p.toArray(a);
    }

    public E getKth(){
        return p.peek();
    }
}   
```

### 无穷元素求中值
思路:使用两个堆，一个最大堆，一个最小堆
1. 假设当前的中位数为m，最大堆维护的是<=m的元素，最小堆维护的是>=m的元素，但两个堆都不包含m。
2. 当新的元素到达时，比如为e，将e与m进行比较，若e<=m，则将其加入到最大堆中，否则将其加入到最小堆中。
3. 第二步后，如果此时最小堆和最大堆的元素个数的差值>=2 ，则将m加入到元素个数少的堆中，然后从元素个数多的堆将根节点移除并赋值给m。

图解:
![图解无穷元素求中值](resources/images/使用堆求中值.png.)

代码实现:
```java
public class Median <E> {
    private PriorityQueue<E> minP; // 最小堆
    private PriorityQueue<E> maxP; //最大堆
    private E m; //当前中值

    public Median(){
        this.minP = new PriorityQueue<>();
        this.maxP = new PriorityQueue<>(11, Collections.reverseOrder());
    }

    private int compare(E e, E m){
        Comparable<? super E> cmpr = (Comparable<? super E>)e;
        return cmpr.compareTo(m);
    }

    public void add(E e){
        if(m==null){ //第一个元素
            m = e;
            return;
        }
        if(compare(e, m)<=0){
            //小于中值, 加入最大堆
            maxP.add(e);
        }else{
            minP.add(e);
        }
        if(minP.size()-maxP.size()>=2){
            //最小堆元素个数多，即大于中值的数多
            //将m加入到最大堆中，然后将最小堆中的根移除赋给m
            maxP.add(this.m);
            //移除堆根节点，赋给中值
            this.m = minP.poll();
        }else if(maxP.size()-minP.size()>=2){
            minP.add(this.m);
            this.m = maxP.poll();
        }
    }

    public void addAll(Collection<? extends E> c){
        for(E e : c){
            add(e);
        }
    }

    public E getM() {
        return m;
    }
}
```

## 剖析ArrayDeque
内部组成
```java
private transient E[] elements;
private transient int head;
private transient int tail;
```

虽然使用了数组组织元素但不能直接通过下标查找

图解循环数组
![循环数组](resources/images/循环数组.png)

### API简析
add方法
```java
public boolean add(E e) {
    addLast(e);
    return true;
}

public void addLast(E e) {
    //元素不能为空值，因为查找、比较以空值作为结尾。
    if (e == null)
        throw new NullPointerException();
    elements[tail] = e;
    //当尾部元素指向头部元素时，进行扩容
    //因为容量为2^n，所以elements.length-1二进制必定为"111"的形式
    //使用这种形式可以形成从0到该值的循环，并且兼容负值(从尾部往前循环)
    if ( (tail = (tail + 1) & (elements.length - 1)) == head)
        //容量扩大两倍
        doubleCapacity();
}
```

元素不能为空，因为通过元素是否为空来判断元素查询是否结束

contains查看是否包含元素
```java
public boolean contains(Object o) {
    if (o == null)
        return false;
    int mask = elements.length - 1;
    int i = head;
    E x;
    //逐个比较直到为空。
    //tail永远指向空
    while ( (x = elements[i]) != null) {
        if (o.equals(x))
            return true;
        i = (i + 1) & mask;
    }
    return false;
}
```

## 剖析LinkedHashMap
能够按插入有序或按访问有序

LinkedHashMap是HashMap的子类，但内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于这个双向链表中。

内部组成
```java
//比起HashMap内部增加了
//表示双向链表的头
private transient Entry<K,V> header;
//表示是按访问顺序还是插入顺序
private final boolean accessOrder;

//内部Entry的定义
private static class Entry<K,V> extends HashMap.Entry<K,V> {
    Entry<K,V> before, after;

    Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {
        super(hash, key, value, next);
    }

    private void remove() {
        before.after = after;
        after.before = before;
    }

    private void addBefore(Entry<K,V> existingEntry) {
        after  = existingEntry;
        before = existingEntry.before;
        before.after = this;
        after.before = this;
    }
    //将访问节点的位置放到开头(设置按访问顺序时)。
    void recordAccess(HashMap<K,V> m) {
        LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;
        if (lm.accessOrder) {
            lm.modCount++;
            remove();
            addBefore(lm.header);
        }
    }
    //移除节点
    void recordRemoval(HashMap<K,V> m) {
        remove();
    }
}
```


### API简析
put方法
```java
void addEntry(int hash, K key, V value, int bucketIndex) {
    super.addEntry(hash, key, value, bucketIndex);

    // Remove eldest entry if instructed
    Entry<K,V> eldest = header.after;
    if (removeEldestEntry(eldest)) {
        removeEntryForKey(eldest.key);
    }
}
//父类addEntry()调用createEntry()
void createEntry(int hash, K key, V value, int bucketIndex) {
    HashMap.Entry<K,V> old = table[bucketIndex];
    Entry<K,V> e = new Entry<>(hash, key, value, old);
    table[bucketIndex] = e;
    e.addBefore(header);
    size++;
}
```

LinkedHashMap可以作用于缓存。put方法中的removeEntry方式使用的就是LRU缓存策略。LRU(Least Recently Used)缓存策略,思路是，最近刚被使用的很快再次被用的可能性最高，而最久没被访问的很快再次被用的可能性最低，所以被优先清理。

```java
//LRU缓存实现
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private int maxEntries;

    public LRUCache(int maxEntries){
        super(16, 0.75f, true);
        this.maxEntries = maxEntries;
    }

    //当removeEldestEntry返回true时,删除最下面(最久没被访问)的键值对
    @Override
    protected boolean removeEldestEntry(Entry<K, V> eldest) {
        return size() > maxEntries;
    }
}  
```

![LinkedHashMap](resources/images/LinkedHashMap.png)


containsValue方法使用逐条比较的方式进行判断
```java
public boolean containsValue(Object value) {
    // Overridden to take advantage of faster iterator
    if (value==null) {
        //逐个比较，直到一圈
        for (Entry e = header.after; e != header; e = e.after)
            if (e.value==null)
                return true;
    } else {
        for (Entry e = header.after; e != header; e = e.after)
            if (value.equals(e.value))
                return true;
    }
    return false;
}
```

LinkedHashSet继承HashSet,但内部使用LinkedHashMap

## 剖析EnumMap
### 内部组成
EnumMap是保证顺序的，输出是按键在枚举中的顺序

内部组成
```java
private final Class<K> keyType;
//全部的键，即全部的枚举对象
private transient K[] keyUniverse;
private transient Object[] vals;
private transient int size = 0;
```

内部将键与值分别用两个数组存放

构造函数，使用构造函数时需要传递一个enum的class信息
```java
public EnumMap(Class<K> keyType) {
    this.keyType = keyType;
    keyUniverse = getKeyUniverse(keyType);
    vals = new Object[keyUniverse.length];
}
public EnumMap(EnumMap<K, ? extends V> m)
public EnumMap(Map<K, ? extends V> m)
```

### API简析
EnumSet会将enum对像相对应的数值作为索引

put方法，使用null判断元素是否存在，所以需要将null打包成一个对象
```java
public V put(K key, V value) {
    typeCheck(key);
    
    //ordinal获取enum对象对应的数字
    int index = key.ordinal();
    Object oldValue = vals[index];
    //将null值打包或解包为NULL
    vals[index] = maskNull(value);
    //原枚举对象为空，则说明是新增
    if (oldValue == null)
        size++;
    //将NULL值解包为null
    return unmaskNull(oldValue);
}
//检查方法
private void typeCheck(K key) {
    Class keyClass = key.getClass();
    if (keyClass != keyType && keyClass.getSuperclass() != keyType)
        throw new ClassCastException(keyClass + " != " + keyType);
}
//打包、解包方法以及NULL对象
private static final Object NULL = new Object() {
    public int hashCode() {
        return 0;
    }

    public String toString() {
        return "java.util.EnumMap.NULL";
    }
};

private Object maskNull(Object value) {
    return (value == null ? NULL : value);
}

private V unmaskNull(Object value) {
    return (V) (value == NULL ? null : value);
}
```

get方法，直接根据枚举对应的数字定位
```java
public V get(Object key) {
    return (isValidKey(key) ?
            unmaskNull(vals[((Enum)key).ordinal()]) : null);
}
//检测键是否有效
private boolean isValidKey(Object key) {
    if (key == null)
        return false;

    // Cheaper than instanceof Enum followed by getDeclaringClass
    Class keyClass = key.getClass();
    return keyClass == keyType || keyClass.getSuperclass() == keyType;
}
```

## 剖析EnumSet
### 内部组成
EnumSet不是通过EnumMap实现的

EnumSet内部组成
```java
//枚举类型信息
final Class<E> elementType;
//所有枚举值
final Enum[] universe;

//RegularEnumSet用一个long类型表示位向量
private long elements = 0L;
//没有定义表示元素个数的变量，是实时计算出来的，计算代码:
private int size(){
    return Long.bitCount(elements);
}

//JumboEnumSet(枚举数量超大时使用数组来表示)用一个long数组表示，有单独的size变量
private long elements[];
private int size = 0;
```

位向量，用一个位表示一个元素的状态，用一组位表示一个集合的状态。

### API简析
EnumSet在构建对象时就获得了全部的枚举对象并置于universe数组中，添加、删除、查找都是通过控制位向量达到控制集合内元素的目的。

add添加，通过将elements上对应的位置为1来实现
```java
//RegularEnumSet
public boolean add(E e) {
    typeCheck(e);

    long oldElements = elements;
    elements |= (1L << ((Enum)e).ordinal());
    return elements != oldElements;
}

//JumboEnumSet的add方法
public boolean add(E e) {
    typeCheck(e);

    int eOrdinal = e.ordinal();
    int eWordNum = eOrdinal >>> 6;

    long oldElements = elements[eWordNum];
    elements[eWordNum] |= (1L << eOrdinal);
    boolean result = (elements[eWordNum] != oldElements);
    if (result)
        size++;
    return result;
}
```

remove删除，通过将elements置1来实现:
```java
public boolean remove(Object e) {
    if (e == null)
        return false;
    Class eClass = e.getClass();
    if (eClass != elementType && eClass.getSuperclass() != elementType)
        return false;

    long oldElements = elements;
    //从集合中除去元素，即从位向量中将相关位变成0。
    elements &= ~(1L << ((Enum)e).ordinal());
    return elements != oldElements;
}
```

### 实例
EnumSet很适合用于集合的运算
```java
//表示工作人员的类Worker
class Worker {
    String name;
    Set<Day> availableDays;

    public Worker(String name, Set<Day> availableDays) {
        this.name = name;
        this.availableDays = availableDays;
    }

    public String getName() {
        return name;
    }

    public Set<Day> getAvailableDays() {
        return availableDays;
    }
}
//初始化
Worker[] workers = new Worker[]{
        new Worker("张三", EnumSet.of(
                Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY, Day.FRIDAY)),
        new Worker("李四", EnumSet.of(
                Day.TUESDAY, Day.THURSDAY, Day.SATURDAY)),
        new Worker("王五", EnumSet.of(
                Day.TUESDAY, Day.THURSDAY)),
};
/*
哪些天一个人都不会来
 */
Set<Day> days = EnumSet.allOf(Day.class);
for(Worker w : workers){
    days.removeAll(w.getAvailableDays());
}
System.out.println(days);
/*
那些天至少一个人会来?
 */
Set<Day> days = EnumSet.noneOf(Day.class);
for(Worker w : workers){
    days.addAll(w.getAvailableDays());
}
System.out.println(days);
/*
哪些天所有人都会来?
 */
Set<Day> days = EnumSet.allOf(Day.class);
for(Worker w : workers){
    days.retainAll(w.getAvailableDays());
}
System.out.println(days);
/*
哪些人周一和周二会来?
 */
Set<Worker> availableWorkers = new HashSet<Worker>();
for(Worker w : workers){
    if(w.getAvailableDays().containsAll(
            EnumSet.of(Day.MONDAY,Day.TUESDAY))){
        availableWorkers.add(w);
    }
}
for(Worker w : availableWorkers){
    System.out.println(w.getName());
}
```

## 抽像容器类
容器类是一个大家庭，它们之间可以方便的协作，比如很多方法的参数和返回值都是容器接口对象，实现了容器接口，就可以方便的参与进这种协作。

Java有一个类Collections，提供了很多针对容器接口的通用算法和功能，实现了容器接口，就可以直接利用Collections中的算法和功能。

容器类关系图
![容器类关系图](resources/images/容器类关系图.png)

每个Collection接口的实现类都应该提供至少两个标准的构造方法，一个是默认构造方法，另一个接受一个Collection类型的参数

### AbstractCollection
AbstractCollection: 实现了Collection接口，被抽象类AbstractList, AbstractSet, AbstractQueue,ArrayDeque继承

AbstractCollection类默认实现了addAll,remove,contains等方法，这些方法基于基本的方法，因此只需要实现基本的方法就好了
```java
//add默认实现，如果容器类不可添加，则不需要更改
public boolean add(E e) {
    throw new UnsupportedOperationException();
}
public abstract int size();
public abstract Iterator<E> iterator();

//还需要重写迭代器类Iterator中的几个方法
boolean hasNext();
E next();
void remove();
```

扩展例子
```java
public class MyCollection<E> extends AbstractCollection<E> {
    DynamicArray<E> darr;

    public MyCollection(){
        darr = new DynamicArray<>();
    }

    public MyCollection(Collection<? extends E> c){
        this();
        addAll(c);
    }

    @Override
    public Iterator<E> iterator() {
        return new DynamicArrayIterator<>(darr);
    }

    @Override
    public int size() {
        return darr.size();
    }

    @Override
    public boolean add(E e) {
        darr.add(e);
        return true;
    }
    
    //实际的容器类
    public class DynamicArray<E> {
        //... ..
        public E remove(int index) {
            E oldValue = get(index);
            int numMoved = size - index - 1;
            if (numMoved > 0)
                System.arraycopy(elementData, index + 1, elementData, index,
                        numMoved);
            elementData[--size] = null;
            return oldValue;
        }

        public void add(int index, E element) {
            ensureCapacity(size + 1);  
            System.arraycopy(elementData, index, elementData, index + 1,
                             size - index);
            elementData[index] = element;
            size++;
        }
    }
    
    //重写迭代器
    public class DynamicArrayIterator<E>  implements Iterator<E>{
        DynamicArray<E> darr;
        int cursor;      
        int lastRet = -1;

        public DynamicArrayIterator(DynamicArray<E> darr){
            this.darr = darr;
        }

        @Override
        public boolean hasNext() {
             return cursor != darr.size();
        }

        @Override
        public E next() {
            int i = cursor;
            if (i >= darr.size())
                throw new NoSuchElementException();
            cursor = i + 1;
            lastRet = i;
            return darr.get(i);
        }

        @Override
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            darr.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
        }
    }    
}     
```

### 其他抽象类基础方法
AbstractList提供了List接口的基础实现，扩展AbstractList需要实现以下基础方法
```java
public abstract int size();
abstract public E get(int index);
public E set(int index, E element)
public void add(int index, E element)
public E remove(int index)
```

AbstractSequentialList基础方法
```java
//子类必须重写该方法，并实现迭代器接口
//AbstractSequentialList的其他实现的方法是通过iterator的内部方法实现的
public abstract ListIterator<E> listIterator(int index);
```

AbstractMap基础方法
```java
public V put(K key, V value);
//通过返回的集合的迭代器的方法实现各种对集合的操作
public abstract Set<Entry<K,V>> entrySet();
```

AbstractQueue基础方法
```java
E peek();
E poll();
boolean offer(E e);
```

## 剖析Collections-算法
Collections功能
- 对容器接口对象进行操作
- 返回一个容器接口对象

对于第一类，大概可以分为:
- 查找和替换
- 排序和调整顺序
- 添加和修改

对于第二类，大概可以分为:
- 适配器:将其他类型的数据转换为容器接口对象。
- 装饰器:修饰一个给定容器接口对象，增加某种性质。

### 查找和替换
```java
//二分查找
public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)
public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c)

//查找最大最小值
public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp) 
public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll)
public static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp)

//查找元素出现次数
public static int frequency(Collection<?> c, Object o)

//查找子List
public static int indexOfSubList(List<?> source, List<?> target)
public static int lastIndexOfSubList(List<?> source, List<?> target)

//查找两个集合是否有交集
public static boolean disjoint(Collection<?> c1, Collection<?> c2)

//替换
public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)
```

查找子List
```java
List<Integer> source = Arrays.asList(new Integer[]{
        35, 24, 13, 12, 8, 24, 13, 7, 1
});
System.out.println(Collections.indexOfSubList(source, Arrays.asList(new Integer[]{24, 13})));
System.out.println(Collections.lastIndexOfSubList(source, Arrays.asList(new Integer[]{24, 13})));
/*
输出为:
1
5
 */
```

### 排序和调整顺序
```java
//排序
public static <T extends Comparable<? super T>> void sort(List<T> list)
public static <T> void sort(List<T> list, Comparator<? super T> c)

//交换元素位置
public static void swap(List<?> list, int i, int j)

//翻转列表顺序
public static void reverse(List<?> list) 

//随机化重排
public static void shuffle(List<?> list)
public static void shuffle(List<?> list, Random rnd)

//循环移位
public static void rotate(List<?> list, int distance)
```

### 添加和修改
```java
//批量添加
public static <T> boolean addAll(Collection<? super T> c, T... elements)
//填充固定值
public static <T> void fill(List<? super T> list, T obj)
//批量拷贝
public static <T> void copy(List<? super T> dest, List<? extends T> src)
```

## 剖析Collections-设计模式
### 适配器模式
单一对象方法(将单独对象转化为标准容器接口对象)
```java
public static <T> Set<T> singleton(T o)
public static <T> List<T> singletonList(T o)
public static <K,V> Map<K,V> singletonMap(K key, V value)

/*
singleton详解
 */
public static <T> Set<T> singleton(T o) {
    return new SingletonSet<>(o);
}

private static class SingletonSet<E>
    extends AbstractSet<E>
{
    private final E element;

    SingletonSet(E e) {element = e;}

    public Iterator<E> iterator() {
        return singletonIterator(element);
    }

    public int size() {return 1;}

    public boolean contains(Object o) {return eq(o, element);}
}

//singletonIterator()源码
//迭代器代码更加符合单一对象容器
static <E> Iterator<E> singletonIterator(final E e) {
    return new Iterator<E>() {
        private boolean hasNext = true;
        public boolean hasNext() {
            return hasNext;
        }
        public E next() {
            if (hasNext) {
                hasNext = false;
                return e;
            }
            throw new NoSuchElementException();
        }
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}
```

### 装饰器模式
写安全(将集合变为只读，写入会抛出异常UnsupportedOperationException)

```java
public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c)
public static <T> List<T> unmodifiableList(List<? extends T> list)
public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)
public static <T> Set<T> unmodifiableSet(Set<? extends T> s)
public static <K,V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K, ? extends V> m)
public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> s)

public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
    return new UnmodifiableCollection<>(c);
}
```

UnmodifiableCollection源代码(添加和删除等相关的修改方法重写为抛出异常)

```java
static class UnmodifiableCollection<E> implements Collection<E>, Serializable {
    private static final long serialVersionUID = 1820017752578914078L;

    final Collection<? extends E> c;

    UnmodifiableCollection(Collection<? extends E> c) {
        if (c==null)
            throw new NullPointerException();
        this.c = c;
    }

    public int size()                   {return c.size();}
    public boolean isEmpty()            {return c.isEmpty();}
    public boolean contains(Object o)   {return c.contains(o);}
    public Object[] toArray()           {return c.toArray();}
    public <T> T[] toArray(T[] a)       {return c.toArray(a);}
    public String toString()            {return c.toString();}

    public Iterator<E> iterator() {
        return new Iterator<E>() {
            private final Iterator<? extends E> i = c.iterator();

            public boolean hasNext() {return i.hasNext();}
            public E next()          {return i.next();}
            public void remove() {
                throw new UnsupportedOperationException();
            }
        };
    }

    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }
    public boolean remove(Object o) {
        throw new UnsupportedOperationException();
    }

    public boolean containsAll(Collection<?> coll) {
        return c.containsAll(coll);
    }
    public boolean addAll(Collection<? extends E> coll) {
        throw new UnsupportedOperationException();
    }
    public boolean removeAll(Collection<?> coll) {
        throw new UnsupportedOperationException();
    }
    public boolean retainAll(Collection<?> coll) {
        throw new UnsupportedOperationException();
    }
    public void clear() {
        throw new UnsupportedOperationException();
    }
}
```

## 容器类总结
容器类中的数据结构:
- 动态数组：ArrayList内部就是动态数组，HashMap内部的链表数组也是动态扩展的，ArrayDeque和PriorityQueue内部也都是动态扩展的数组。
- 链表：LinkedList是用双向链表实现的，HashMap中映射到同一个链表数组的键值对是通过单向链表链接起来的，LinkedHashMap中每个元素还加入到了一个双向链表中以维护插入或访问顺序。
- 哈希表：HashMap是用哈希表实现的，HashSet, LinkedHashSet和LinkedHashMap基于HashMap，内部当然也是哈希表。
- 排序二叉树：TreeMap是用红黑树(基于排序二叉树)实现的，TreeSet内部使用TreeMap，当然也是红黑树，红黑树能保持元素的顺序且综合性能很高。
- 堆：PriorityQueue是用堆实现的，堆逻辑上是树，物理上是动态数组，堆可以高效地解决一些其他数据结构难以解决的问题。
- 循环数组：ArrayDeque是用循环数组实现的，通过对头尾变量的维护，实现了高效的队列操作。
- 位向量：EnumSet是用位向量实现的，对于只有两种状态，且需要进行集合运算的数据，使用位向量进行表示、位运算进行处理，精简且高效。

每一种算法都是在空间与时间方面取得平衡
- 动态扩展算法：动态数组的扩展策略，一般是指数级扩展的，是在两方面进行平衡，一方面是希望减少内存消耗，另一方面希望减少内存分配、移动和拷贝的开销。
- 哈希算法：哈希表中键映射到链表数组索引的算法，算法要快，同时要尽量随机和均匀。
- 排序二叉树的平衡算法：排序二叉树的平衡非常重要，红黑树是一种平衡算法，AVL树是另一种，平衡算法一方面要保证尽量平衡，另一方面要尽量减少综合开销。
