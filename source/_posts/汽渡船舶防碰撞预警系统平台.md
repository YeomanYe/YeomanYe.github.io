title: 汽渡船舶防碰撞预警系统平台
tags:
    - 系统分析
comments: true
brief: 汽渡船舶防碰撞预警系统平台
categories:
    - 总结
---

# 汽渡船舶防碰撞预警系统平台
汽渡船舶防碰撞预警系统平台功能:
1. 页面动态显示船舶（包括在地图上显示船舶的位置，船舶的航行速度,点击定位能定位到船舶）
2. 提示碰撞警告（查表当将会出现的碰撞时间大于当前时间则生成提示信息，有的船能生成碰撞信息保存到数据库）
3. 推送警告信息(只是将警告信息插入到指定的数据表中)
4. 显示船舶历史轨迹动画
5. 可以在地图上管理标注（标注类型有:点、多段线、多边形等标注），
6. 基本数据的增删改查、以图表方式展示数据
7. 具有用户操作日志，记录用户的每一个操作。
8. 具有权限管理，给不同的用户设置不同的权限。(也是通过用户关联爹角色形式。)
9. 能够扩展基本数据，便于系统的灵活扩展。
10. 对于地图的操作有:放大、缩小、测量、显示不同的底图（包括矢量图、影像图、黑暗图）
使用到的框架和库:
后台框架:Spring、Spring MVC、MyBatis
前台框架:jQuery、Easy UI、arcgis for js 3.20、jWebAudio（音频库）、Cocurrent.Thread.js
jQuery插件:ZeroModal(jQuery弹出层插件)、uploadPreview、ajaxFileUpload、jQuery.cookie
数据库:Oracle
<!-- more -->
## 值得注意的地方
### ArcGIS API for JS 
ArcGIS中，地图由图层组成。GraphicLayer用于创建几何图形层，自定义的图形、绘制的图形都放置其上。ArcGISDynamicMapServiceLayer用于创建ArcGIS服务中得到的图层(背景图)。放置在GraphicLayer上的图形(Graphic)有两种元素构成，记号(Symbol),几何(Geometry)组成。
```js
/**
 * 用到的ArcGIS API for JS
 * ?:代表可选参数
 */
/*map及其相关API*/
//"esri/map"
var myMap = new Map(divId, options?);//新建一个Map,divId为使用的html标签
myMap.addLayer(layer,index?)//添加图层
myMap.setExtent(extent, fit?)//设置地图的范围,定位也是通过这个API实现的
//"esri/SpatialReference"
new SpatialReference(wkid)//定义一个空间参考,wkid是数字
//"esri/geometry/Extent"
new Extent(xmin, ymin, xmax, ymax, spatialReference)//右上角与左下角的坐标,

/*layer及其相关API*/
//"esri/layers/GraphicsLayer"
var gLayer = new GraphicsLayer(options?)//新建图层,建立的是可在上面添加东西的图层
gLayer.add(graphic)//添加图形
gLayer.remove(graphic)//移除图形
//"esri/layers/ArcGISDynamicMapServiceLayer"
new ArcGISDynamicMapServiceLayer(url, options?)//使用发布arcgis服务作为图层
//"esri/InfoTemplate"
new InfoTemplate(title, content)//创建信息模板
//"esri/graphic"
var graphic = new Graphic(geometry?, symbol?, attributes?, infoTemplate?)//创建一个图形
graphic.setInfoTemplate(infoTemplate);//设置图形的信息模板
//"esri/symbols/SimpleLineSymbol"
 //创建一个记号
 //style，例esri.symbol.SimpleLineSymbol.STYLE_SOLID
 //color,例esri.Color("#00f2fa")
var sys = new SimpleLineSymbol(style, color, width)
//创建一个多边形
var polylineJson = {
    "paths" : [ [ [ obj.LON, obj.LAT ],
            [ nextObj.LON, nextObj.LAT ] ] ],
    "spatialReference" : {
        "wkid" : 4326
    }
};
//"esri/geometry/Polyline","esri/graphic"
var gLine = new esri.Graphic(new esri.geometry.Polyline(
        polylineJson), sls);
//"esri/symbols/PictureMarkerSymbol"
new PictureMarkerSymbol(url, width, height)//创建一个图片记号
//"esri/symbols/SimpleMarkerSymbol"
new SimpleMarkerSymbol(style, size, outline, color)//简单标志记号

/*操作Map相关工具的API*/
//"esri/toolbars/draw"
var drawpoint = new Draw(map, options?)//生成一个用于画点的对象
drawpoint.deactivate();//使工具栏无效，并且重新激活导航栏。
drawpoint.on("draw-end", addToMapC);//画图结束触发事件
//"esri/toolbars/navigation"
navigationToolbar = new Navigation(myMap);//创建地图工具对象
navigationToolbar.activate(Navigation.ZOOM_IN);//放大
navigationToolbar.activate(Navigation.ZOOM_OUT);//缩小
```

### 保存用户名和密码
使用前台jQuery.cookie读取cookie，后台添加cookie
jQuery.cookie相关API

```js
//读取cookie,不存在返回null
$.cookie('the_cookie'); 
//删除cookie
$.cookie('the_cookie', null); 
//创建一个cookie并设置 cookie的有效路径(在默认情况下，只有设置 cookie的网页才能读取该 cookie。如果想让一个页面读取另一个页面设 )： 
$.cookie('the_cookie', 'the_value', { expires: 7, path: '/' }); 
```

后台添加cookie

```java
//添加cookie
response.addCookie(setCookies("pwd", user.getUserpwd()));
//清除Cookie
public void cleanCookie(HttpServletRequest req,HttpServletResponse res){
    Cookie[] cookies = req.getCookies();
   
    EmptyUtil eu = new EmptyUtil();
    for(Cookie c : cookies){
        if((!eu.isFieldEmpty(c.getName()))){
            if(c.getName().equals("user")||c.getName().equals("pwd")||c.getName().equals("rememberUser")||c.getName().equals("username")){
                c.setValue(null);
                c.setMaxAge(0);// 立即销毁cookie
                c.setPath("/");
                res.addCookie(c);
            }
        }
    }
}
```

### 防止用户重新登陆
__实现思路:__设置一个sessionMap管理所有的session,当用户登陆时，检测sessionMap中是否存在该session，如果不存在则添加session到sessionMap中。如果存在，则比较两次登陆的IP是否相同，如果相同则只刷新session，如果不同则删去老的session添加新的session。因为用户操作需要权限，权限又跟cookie挂钩，所以去掉了session的用户在下一次操作时就会发现被挤出。

```java
public synchronized void addSession(HttpSession session,String username){
        if(session!=null){
            //防止重复登录，旧登录用户踢出
            //addSessionMap是保存了所有session的map
            Set<Map.Entry<String, Object>> submap = appSessionMap.entrySet();
            for(Map.Entry<String, Object> emap: submap){
                HttpSession subsession = (HttpSession) emap.getValue();
                try {
                    String names = subsession.getAttribute("username").toString();
                    if(names!=null&&names.equals(username)){
                        ApplicationContext applicationContext = SpringContextLoaderListener.getApplicationContext();
                        IUserLogServices UserLogServices =  (IUserLogServices) applicationContext.getBean("UserLogServices");
                        sys_userinfo user = (sys_userinfo) session.getAttribute("user");
                        List<sys_userlog> sys_userlog = UserLogServices.getlastuserlog(user.getGuid());
                        //从日志中获取用户IP
                        if(sys_userlog!=null&&sys_userlog.size()>0){
                            String newIp = (String) session.getAttribute("ip");
                            String ip = sys_userlog.get(0).getIpaddress();
                            if(!ip.equals(newIp)){
                                UserLogServices.setuserlog(ip, user," 该账户在其他ip登录，当前操作用户已登出");
                            }
                        }
                        appSessionMap.remove(emap.getKey());
                        break;
                    }
                    
                } catch (Exception e) {
                    appSessionMap.remove(emap.getKey());
                    break;
                }
            }
        
            //首次登录
            if(appSessionMap.get(session.getId())==null){
                appSessionMap.put(session.getId(), session);
            }else{
                //再次登录更新session
                appSessionMap.remove(session.getId());
                appSessionMap.put(session.getId(), session);
            }
        }
    }
```

### 在select中使用select子句
```sql
select (select st1.shipname from basic_ferryboatsmsg st1 where st1.qdmmsi=t.mmsi) as SHIPNAME,t.mmsi,t.lon,t.lat,t.cog,t.sog,t.timestr,
            (select st1.adistance from ELEC_SHIPPOSITION st1 where t.mmsi=st1.mmsi) as ADISTANCE,
            (select st2.bdistance from ELEC_SHIPPOSITION st2 where t.mmsi=st2.mmsi) as BDISTANCE 
            from basic_fusionrealtime t where t.mmsiorarpaid=mmsiorarpaid order by t.mmsi
```

### case when...then...else
```sql
select t.guid,t.shipname,t.mmsi,t.sog,t.cog,t.lon,t.lat,
            case when t.datatype='F' then '是'
            else '否' end  as datatype,t.mmsi as loca
        from basic_fusionrealtime t where t.mmsi not in(select t2.qdmmsi from basic_ferryboatsmsg t2) and t.inrange=0 order by t.shipname
```

### MyBatis中List<Map<String,String>>参数
```xml
<foreach collection="list" item="item" index="index" separator=";">
    update table set is_ok=#{item.is_ok} where Admin_id=#{item.Admin_id}
    </foreach>
```

### XML CDATA
`<![CDATA[]]>`中的文本不会被解析,即可以自由的使用><等字符。

### 屏蔽鼠标右键
通过绑定空事件屏蔽鼠标右键

```js
//屏蔽鼠标右键
function disableMouseRigth(){
    $("body").bind("contextmenu", function(){
        return false;
    });
    $("body").bind("selectstart", function(){
        return false;
    });
}
```

### 记录用户操作日志
思路:在Filter中根据uri来判断用户进行的操作(查询与uri对应的操作名称的表，可能一个uri对应多个操作)，将用户的的信息(包括用户的ip地址,浏览器类型，操作名，用户名，操作时间记录到日志表中。)

Filter中可以这样写:
```java
public class SessionFilter implements Filter {

    /**
     * 记录用户操作，是否有登陆的过滤器。
     */
    public void doFilter(ServletRequest request,ServletResponse response, FilterChain fc)
            throws IOException, ServletException {
        int mark = 0;
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse res = (HttpServletResponse)response;
        HttpSession session = req.getSession();
        
        //从系统session集合中验证是否存在
        SessionMap smap = SessionMap.getMysessionMap();
        HttpSession nowSession = smap.getSession(session.getId());
        
        if(nowSession==null){
            mark = 1;
        }else{
            //session中是否有用户
            if(session.getAttribute("user")==null){
                mark = 1;
            }
        }
        if(mark==0){
            sys_userinfo user = (sys_userinfo) session.getAttribute("user");
            String uri = req.getRequestURI();
            
            ApplicationContext applicationContext = SpringContextLoaderListener.getApplicationContext();
            IUserLogServices UserLogServices =  (IUserLogServices) applicationContext.getBean("UserLogServices");
            List<Map<String, Object>> logs = UserLogServices.getlogcontent(uri);
            for(Map<String, Object> log : logs){
                String content = (String) log.get("FUNCTIONLOG");
                UserLogServices.setuserlog(req.getRemoteAddr(), user, content);
            }
            
            fc.doFilter(req, res);
        }else{
            //没有session中的用户信息跳转回登录页面
            RequestDispatcher rd = request.getRequestDispatcher("login.do?info=用户名或密码错误！");
            rd.forward(request,response);
        }
    }
}
```

## 感觉不好的地方
### 代码组织结构
1. 所有js代码都写在jsp中
2. script标签放在页面的开头（应该放在body闭合标签前），放在开头影响页面的加载
3. 内嵌大量css

### 频繁使用js插入元素
使用js动态生成元素引发重排重绘，大量使用造成性能严重下降。

### 冗余标签
1. 使用表格标签布局造成许多冗余标签，影响文档阅读。
2. 使用一个表单记录菜单的开启关闭状态，我觉得使用一个类名来表示或者一个全局标志位即可。

### iframe
1. 页面引用别的页面的js使得代码结构变得混乱。
2. 每个页面都要重新插入库

### 多个定时器
使用多个不同时间(setInternal)的定时器，可能造成冲突，我认为应该将所有需要定时的内容写在一个定时器中。

### 命名不规范
1. 在设置属性的函数名使用getXXX
2. 有的类用驼峰命名法，有的使用匈牙利命名法。

### JS多线程
有的使用Concurrent.Thread.js，有的地方使用setTimeout,有的地方使用setInterval来编写js线程代码，使得结构混乱，代码容易发生冲突。