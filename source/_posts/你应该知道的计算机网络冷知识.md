title: 你需要知道的网络冷知识
tags:
    - 网络
comments: true
brief: 你需要知道的网络冷知识
date: 2019-5-12
categories:
    - 网络
---
# 你需要知道的网络冷知识

网络是我们每个开发人员必打交道的一个环节，了解计算机网络的知识有助于我们对底层的理解。而知道些网络的冷知识，能够帮助我们开阔眼界查缺补漏。

## 端口

1~1023的端口都是被系统使用的，为了防止冲突我们一般使用大于10000的端口号。看起来似乎有些不对，那之间的端口号干什么用了？

1024~5000的端口号是用于临时分配给服务器与客户端的。

大于5000的端口用于分配给一些知名的服务器。（如：tomcat 8080等）

### 标准简单服务
1~1023这些著名的端口号由 Internet 号分配机构（Internet Assigned Numbers Authority, IANA）来管理。

因为历史原因，Unix系统在256~1023之间提供了一些特定的Unix服务。与Internet扩展服务的一个区别是Telnet和Rlogin服务。Telnet采用端口号为23的TCP/IP标准且几乎可以在所有操作系统上进行实现。Rlogin最初只是为Unix系统设计的端口号为513。

有一些标准的简单服务几乎每种实现都要提供，常用的如下所示。

| 名字    | TCP端口号 | UDP端口号 | 描述                                                                                                       |
| :--:    | :--:      | :--:      | :--:                                                                                                       |
| echo    | 7         | 7         | 服务器返回客户发送的所有内容                                                                               |
| discard | 9         | 9         | 服务器丢弃客户发送消息的所有内容                                                                           |
| daytime | 13        | 13        | 服务器以可读形式返回时间和日期                                                                             |
| chargen | 19        | 19        | 当客户发送一个数据报时：TCP服务器发送一串连续的字符流，直到客户中断连接；UDP服务器发送一个随机长度的数据报 |
| time    | 37        | 37        | 服务器返回一个二进制形式的32bit数，表示从UTC时间1900年1月1日午夜至今的秒数                                 |

然而使用Linux查询端口占用情况命令`netstat -ntulp`却发现这些服务都不存在，原因是这些服务都没有被内置到Linux系统中。在CentOS下需要安装xinetd（wiki：一个运行于类Unix操作系统的开放源代码的超级服务器守护进程），然后进行相关的配置后即可使用服务，步骤如下：

1. 安装`sudo yum install xinetd`
2. 修改目录`/etc/xinetd.d/`中的配置文件（stream代表tcp配置，dgram代表udp配置），将其中的disable的yes修改为no即可。
3. 启动服务`service xinetd start`

做完以上的步骤后，使用tcp或udp进行访问云服务器，你可能会发现并不成功。原因是云服务器为了保证安全只开放了一些特定的端口，要想这些服务能被访问到，需要将这些端口配置到安全规则中才行。

__TCP客户端__

```js
var net = require('net');

var client = new net.Socket();
//19代表端口号，xxx请换成自己的服务器端地址
client.connect(19, 'xxx.xxx.xxx.xxx', function() {
    console.log('Connected');
    client.write("Hello, server! I'm Client.");
});

client.on('data', function(data) {
    console.log('Received: ' + data);
    client.destroy(); // kill client after server's response
});

client.on('close', function() {
    console.log('Connection closed');
});
```

__UDP客户端__

```js
var dgram = require('dgram');
var mess = Buffer.from("Hello, server! I'm Client.");
var client = dgram.createSocket('udp4');
//19代表端口号，xxx请换成自己的服务器端地址
client.send(mess,0,mess.length,19,'xxx.xxx.xxx.xxx',function (err, bytes) {
    if(err) console.log('Send Err!');
});
client.on('message',function (msg, rinfo) {
    console.log('Received：%s',msg);
    console.log('Server address：%s',rinfo.address);
    console.log('Server port：%s',rinfo.port);
    client.close();
});
client.on('close',function () {
    console.log('onClose');
});
```

__daytime__

    12 MAY 2019 22:53:57 CST

__chargen__

_TCP_

```txt
Connected
Received: YZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?@ABC

Connection closed
```

_UDP_

```txt
Received：KLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./012345
LMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456
MNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./01234567
NOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./012345678
OPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789
PQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:
QRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;
RSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<
STUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=
TUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>
UVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?
VWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?@
WXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?@A
XYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456

Server address：xxx.xxx.xxx.xxx
Server port：19
onClose
```

__time__
如果按照上面的代码直接进行访问会返回一串乱码。因为其返回的是__4位无符号整形数__代表从__1900年1月1日0时__（不是1970）至今的__秒数__，需要将数据解析部分按照如下方式修改才能获得正确的数值。

```js
var buf = new ArrayBuffer(4);
var view = new DataView(buf);
for (let i = 0; i < 4; i++) {
    view.setUint8(i, data[i]);
}
console.log('Received: ' + view.getUint32(0));
```

结果：3766664509

认真观察，这些端口号都是奇数的。因为这些端口号都是从NCP端口号派生出来的（NCP，即网络控制协议，是ARPANET的运输层协议，是TCP的前身）。 NCP是单工的，不是全双工的，因此每个应用程序需要两个连接，需预留一对奇数和偶数端口号。当TCP和UDP成为标准的运输层协议时，每个应用程序只需要一个端口号，因此就使用了NCP中的奇数。

## 标准


## IP
众所周知IP地址分为内网IP和外网IP，但又多少人知道IP地址分为了哪几类，

## 术语

internet（全小写）：是用一个共同的协议族把多个网络连接在一起。
Internet（首字母大写）：指的是世界范围内通过 TCP/IP 互相通信的所有主机集合

Internet是一个internet，但是internet不等于Internet。