title: 你需要知道的网络冷知识
tags:
    - 网络
comments: true
brief: 你需要知道的网络冷知识
date: 2019-05-12
copyright: true
photos:
    - "http://www.jituwang.com/uploads/allimg/140316/259560-140316153U717.jpg"
categories:
    - 网络
---

为什么你应该知道网络冷知识？为了吹牛灌水？

当然不系，了解这些冷知识有利于我们对体系知识差缺补漏，建立建全知识体系。

废话不多说，让我们来看下哪些是平常不易被注意到的冷知识。

<!-- more -->

## 端口

### 端口分类

1~1023的端口都是被系统使用的（由 Internet 号分配机构（Internet Assigned Numbers Authority, IANA）来管理），为了防止冲突我们一般使用大于10000的端口号。看起来似乎有些不对，那之间的端口号干什么用了？

1024~5000的端口号是用于临时分配给服务器与客户端的。

大于5000的端口用于分配给一些知名的服务器。（如：tomcat 8080等）

### 标准简单服务
这些标准服务从Unix时代开始就被规定好了，但是在现实中却并没有发现它们被使用过。可能的原因是过于简单实际中没什么用，那么我为什么要介绍它。因为是个冷知识。。。也不全是，我觉得如果将这些服务作为TCP与UDP的测试服务，就不需要自己费力的编写一个测试服务了，直接掌握他们就好了。

| 名字    | TCP端口号 | UDP端口号 | 描述                                                                                                       |
| :--:    | :--:      | :--:      | :--:                                                                                                       |
| echo    | 7         | 7         | 服务器返回客户发送的所有内容                                                                               |
| discard | 9         | 9         | 服务器丢弃客户发送消息的所有内容                                                                           |
| daytime | 13        | 13        | 服务器以可读形式返回时间和日期                                                                             |
| chargen | 19        | 19        | 当客户发送一个数据报时：TCP服务器发送一串连续的字符流，直到客户中断连接；UDP服务器发送一个随机长度的数据报 |
| time    | 37        | 37        | 服务器返回一个二进制形式的32bit数，表示从UTC时间1900年1月1日午夜至今的秒数                                 |

然而使用Linux查询端口占用情况命令`netstat -ntulp`却发现这些服务都不存在，原因是这些服务都没有被内置到Linux系统中。在CentOS下需要安装xinetd（wiki：一个运行于类Unix操作系统的开放源代码的超级服务器守护进程），然后进行相关的配置后即可使用服务，步骤如下：

1. 安装`sudo yum install xinetd`
2. 修改目录`/etc/xinetd.d/`中的配置文件（stream代表tcp配置，dgram代表udp配置），将其中的disable的yes修改为no即可。
3. 启动服务`service xinetd start`

做完以上的步骤后，使用tcp或udp进行访问云服务器，你可能会发现并不成功。原因是云服务器为了保证安全只开放了一些特定的端口（类似于防火墙的功能），要想这些服务能被访问到，需要将这些端口配置到安全规则中才行。

以下是实验需要用到的TCP与UDP客户端，使用nodejs编写。代码比较简单就不介绍了。

__TCP客户端__

```js
var net = require('net');

var client = new net.Socket();
//19代表端口号，xxx请换成自己的服务器端地址
client.connect(19, 'xxx.xxx.xxx.xxx', function() {
    console.log('Connected');
    client.write("Hello, server! I'm Client.");
});

client.on('data', function(data) {
    console.log('Received: ' + data);
    client.destroy(); // kill client after server's response
});

client.on('close', function() {
    console.log('Connection closed');
});
```

__UDP客户端__

```js
var dgram = require('dgram');
var mess = Buffer.from("Hello, server! I'm Client.");
var client = dgram.createSocket('udp4');
//19代表端口号，xxx请换成自己的服务器端地址
client.send(mess,0,mess.length,19,'xxx.xxx.xxx.xxx',function (err, bytes) {
    if(err) console.log('Send Err!');
});
client.on('message',function (msg, rinfo) {
    console.log('Received：%s',msg);
    console.log('Server address：%s',rinfo.address);
    console.log('Server port：%s',rinfo.port);
    client.close();
});
client.on('close',function () {
    console.log('onClose');
});
```

_以下是访问标准服务器的结果，能够被预测到的echo和discard就不写出来了_

__daytime__

    12 MAY 2019 22:53:57 CST

__chargen__

_TCP_

```txt
Connected
Received: YZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?@ABC

Connection closed
```

_UDP_

```txt
Received：KLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./012345
LMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456
MNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./01234567
NOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./012345678
OPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789
PQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:
QRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;
RSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<
STUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=
TUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>
UVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?
VWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?@
WXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456789:;<=>?@A
XYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}!"#$%&'()*+,-./0123456

Server address：xxx.xxx.xxx.xxx
Server port：19
onClose
```

__time__

如果按照上面的代码直接进行访问会返回一串乱码。因为其返回的是__4位无符号整形数__代表从__1900年1月1日0时__（不是1970）至今的__秒数__，需要将数据解析部分按照如下方式修改才能获得正确的数值。

```js
var buf = new ArrayBuffer(4);
var view = new DataView(buf);
for (let i = 0; i < 4; i++) {
    view.setUint8(i, data[i]);
}
console.log('Received: ' + view.getUint32(0));
```

结果：3766664509

认真观察，这些端口号都是奇数的。因为这些端口号都是从NCP端口号派生出来的（NCP，即网络控制协议，是ARPANET的运输层协议，是TCP的前身）。 NCP是单工的，不是全双工的，因此每个应用程序需要两个连接，需预留一对奇数和偶数端口号。当TCP和UDP成为标准的运输层协议时，每个应用程序只需要一个端口号，因此就使用了NCP中的奇数。

## IP
大家都知道IP地址分为内网IP和外网IP，然而按照这样的划分方式太宽泛。IP地址其实是按照A、B、C、D、E五类进行的划分。如下所示：

![IP分类](IP地址分类.jpg)

其中A、B、C又可以分为一类，它是我们常见的IP地址段。其中绝大部分都是__公有地址__（能够通过公网访问的），每一类又划分一部分作为__私有地址__（作为局域网地址，常见的192.168就在其中）。

![ABC类IP地址.jpg](ABC类IP地址.jpg)

__D类地址__

范围：224.0.0.0-239.255.255.255
作为组播地址之用，其中又可分为三类：

- 专用地址（局部多播地址，224.0.0.0-224.0.0.255），为路由协议和其他用途保留的地址，路由器并不转发属于此范围的IP包。是被IANA规定的知名多播地址（224.0.0.1：所有组播主机；224.0.0.2：所有组播路由器）
- 公用地址（预留多播地址，224.0.1.0-238.255.255.255），可用于全球范围（如Internet）或网络协议。
- 私用地址（管理权限多播地址，239.0.0.0-239.255.255.255），可供组织内部使用，类似于私有IP地址，不能用于Internet，可限制多播范围。

__E类地址__

范围：240.0.0.0-247.255.255.255
保留，仅作为搜索、Internet的实验和开发之用。

## 规范
internet（全小写）：是用一个共同的协议族把多个网络连接在一起。
Internet（首字母大写）：指的是世界范围内通过 TCP/IP 互相通信的所有主机集合

Internet是一个internet，但是internet不等于Internet。

### RFC
RFC（Request for Comment）是指所有关于Internet的正式标准（可以认为是标准文档），它又分为：

- 赋值RFC（Assigned Numbers RFC）：列出了所有Internet协议中使用的数字和常数。
- Internet 正式协议标准：描述了各种 Internet 协议标准化的现状。
- 主机需求RFC：详细描述网络的各个层（链路层、网络层、传输层、应用层）
- 路由器需求RFC：单独描述了路由器的需求。

### 标准化组织

- Internet协会（ISOC，Internet Society）：推动 Internet发展。
    + Internet体系结构委员会（IAB，Internet Architecture Board）：负责 Internet 标准的最后编辑和技术审核
        + Internet研究专门小组（IRIF，Internet Research Task Force）：主要对长远的项目进行研究。
        + Internet工程专门小组（IETF，Internet Engineering Task Force）：负责互联网标准的开发和推动

就如以上的层级关系那样：IRIF与IETF属于IAB，IAB属于ISOC。

## 总结

本篇文章介绍了：

1. 约定俗称的端口号规则
2. 标准简单服务及检验
3. IP地址分类
4. 规范：标准化组织、RFC

什么？你说这些知识不够冷，并且你都知道了。

(￣ω￣;)emmmm...别打我的脸就行。