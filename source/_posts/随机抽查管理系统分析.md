title: 随机抽查管理系统分析
tags:
    - 系统分析
comments: true
brief: 随机抽查管理系统分析
date: 2017-4-5
categories:
    - 总结
---

# 随机抽查系统分析
项目功能:
- 备查项目管理、执法人员管理(对数据的增、删、改、查、Excel的导入)
- 根据抽取条件(人员数、项目数等),随机分配人员对项目进行抽查
- 权限管理，使用的是用户关联角色的模式。

框架使用:
- 前端:easyui,jquery,
- 后端:spring,spring mvc,mybatis

<!-- more -->

## 值得注意的地方
### 使用了插件进行分页
使用了第三方的Mybatis的插件(PageHelper)进行分页的操作
mybatis根标签下:

```xml
<plugins>
    <!-- com.github.pagehelper为PageHelper类所在包名 -->  
        <plugin interceptor="com.github.pagehelper.PageHelper">  
            <!-- 4.0.0以后版本可以不设置该参数 -->  
            <property name="dialect" value="oracle"/>  
            <!-- 该参数默认为false -->  
            <!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 -->  
            <!-- 和startPage中的pageNum效果一样-->  
            <property name="offsetAsPageNum" value="true"/>  
            <!-- 该参数默认为false -->  
            <!-- 设置为true时，使用RowBounds分页会进行count查询 -->  
            <property name="rowBoundsWithCount" value="true"/>  
            <!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 -->  
            <!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）-->  
            <property name="pageSizeZero" value="true"/>  
            <!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 -->  
            <!-- 启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页 -->  
            <!-- 禁用合理化时，如果pageNum<1或pageNum>pages会返回空数据 -->  
            <property name="reasonable" value="true"/>  
            <!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 -->  
            <!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 -->  
            <!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,orderBy,不配置映射的用默认值 -->  
            <!-- 不理解该含义的前提下，不要随便复制该配置 -->  
            <property name="params" value="pageNum=start;pageSize=limit;"/>  
            <!-- 支持通过Mapper接口参数来传递分页参数 -->  
            <property name="supportMethodsArguments" value="true"/>  
            <!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page -->  
            <property name="returnPageInfo" value="check"/>  
        </plugin>  
    </plugins>
```

后端调用:
```java
//设置当前页面以及分页大小,这个方法后的第一个查询方法会被分页
PageHelper.startPage(currentPage, pageSize);
//执行dao方法获取结果集
List<Student> student = dao.selectStudent();
/**
 * 如果只需要分页查询，那么上面的两行代码就够了
 */
//将执行结果注入到PageInfo中,可以从该对象获取分页相关的信息和当前页面的内容
PageInfo<Student> studentListPage = new PageInfo<Student>(student);
//本次查询总条数
studentListPage.getTotal();
//本次查询的结果
studentListPage.getList();
```

除了项目中使用的方式外的其他几种重要的使用方式:
```java
//第一种，RowBounds方式的调用
List<Country> list = sqlSession.selectList("x.y.selectIf", null, new RowBounds(0, 10));

//第二种，Mapper接口方式的调用，推荐这种使用方式。
PageHelper.startPage(1, 10);
List<Country> list = countryMapper.selectIf(1);

//第三种，Mapper接口方式的调用，推荐这种使用方式。
PageHelper.offsetPage(1, 10);
List<Country> list = countryMapper.selectIf(1);

//第四种，参数方法调用
//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数
public interface CountryMapper {
    List<Country> selectByPageNumSize(
            @Param("user") User user,
            @Param("pageNum") int pageNum, 
            @Param("pageSize") int pageSize);
}
//配置supportMethodsArguments=true
//在代码中直接调用：
List<Country> list = countryMapper.selectByPageNumSize(user, 1, 10);

//第五种，参数对象
//如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页
//有如下 User 对象
public class User {
    //其他fields
    //下面两个参数名和 params 配置的名字一致
    private Integer pageNum;
    private Integer pageSize;
}
//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数
public interface CountryMapper {
    List<Country> selectByPageNumSize(User user);
}
//当 user 中的 pageNum!= null && pageSize!= null 时，会自动分页
List<Country> list = countryMapper.selectByPageNumSize(user);

//第六种，ISelect 接口方式
//jdk6,7用法，创建接口
Page<Country> page = PageHelper.startPage(1, 10).doSelectPage(new ISelect() {
    @Override
    public void doSelect() {
        countryMapper.selectGroupBy();
    }
});
//jdk8 lambda用法
Page<Country> page = PageHelper.startPage(1, 10).doSelectPage(()-> countryMapper.selectGroupBy());

//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPage
pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(new ISelect() {
    @Override
    public void doSelect() {
        countryMapper.selectGroupBy();
    }
});
//对应的lambda用法
pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -> countryMapper.selectGroupBy());

//count查询，返回一个查询语句的count数
long total = PageHelper.count(new ISelect() {
    @Override
    public void doSelect() {
        countryMapper.selectLike(country);
    }
});
//lambda
total = PageHelper.count(()->countryMapper.selectLike(country));
```

Mybatis插件的编写:
```java
@Intercepts({@Signature(
  type= Executor.class,//拦截的时机
  method = "update",//拦截的方法
  //方法的参数
  args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
    //拦截后具体执行什么
  public Object intercept(Invocation invocation) throws Throwable {
    //最后一个语句一定的是这个，否则拦截器链就断了
    return invocation.proceed();
  }
  //将目标对象包装到拦截器中，生成一个代理对象
  public Object plugin(Object target) {
    return Plugin.wrap(target, this);
  }
  //设置属性
  public void setProperties(Properties properties) {
  }
}
```

__参考文档：__
[官方说明](https://github.com/pagehelper/Mybatis-PageHelper)
[插件原理](http://blog.csdn.net/hupanfeng/article/details/9247379)

### 使用了MyBatis Generator
MBG(MyBatis Generator)一个通过读取配置文件并根据数据库中对应的表生成实体类、以及映射文件、对应DAO层的工具。(该系统中只是简单测试了下这个生成器的功能)
配置文件:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <classPathEntry    location="ojdbc6.jar"/>
    <context id="testTables" targetRuntime="MyBatis3">
       <commentGenerator>
           <!-- 是否去除自动生成的注释 true：是： false:否 -->
           <property name="suppressAllComments" value="true"/>
       </commentGenerator>
       <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->
      <jdbcConnection driverClass="oracle.jdbc.OracleDriver"
           connectionURL="jdbc:oracle:thin:@localhost:1521:orcl"
           userId="ots"
           password="ots">
       </jdbcConnection>
       <!-- 默认false，把JDBC DECIMAL和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和
           NUMERIC 类型解析为java.math.BigDecimal -->
       <javaTypeResolver>
           <property name="forceBigDecimals" value="false"/>
       </javaTypeResolver>
       <!-- targetProject:生成PO类的位置 -->
       <javaModelGenerator targetPackage="po"
           targetProject=".\src">
           <!--enableSubPackages:是否让schema作为包的后缀 -->
           <property name="enableSubPackages" value="false"/>
           <!-- 从数据库返回的值被清理前后的空格 -->
           <property name="trimStrings" value="true"/>
       </javaModelGenerator>
        <!-- targetProject:mapper映射文件生成的位置 -->
       <sqlMapGenerator targetPackage="map"
           targetProject=".\src">
           <!--enableSubPackages:是否让schema作为包的后缀 -->
           <property name="enableSubPackages" value="false"/>
       </sqlMapGenerator>
       <!-- targetPackage：mapper接口生成的位置 -->
       <javaClientGenerator type="XMLMAPPER"
           targetPackage="dao"
           targetProject=".\src">
           <!--enableSubPackages:是否让schema作为包的后缀 -->
           <property name="enableSubPackages" value="false"/>
       </javaClientGenerator>
       <!-- 指定数据库表 -->
       <table tableName="Subject"></table>
    </context>
</generatorConfiguration>
```

使用java生成:
```java
List<String> warnings = new ArrayList<String>();
boolean overwrite = true;
File configFile = new File("generatorConfig.xml");
ConfigurationParser cp = new ConfigurationParser(warnings);
Configuration config = cp.parseConfiguration(configFile);
DefaultShellCallback callback = new DefaultShellCallback(overwrite);
MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
myBatisGenerator.generate(null);
```

使用命令行生成`java -jar mybatis-generator-core-1.3.2.jar -configfile generatorConfig.xml -overwrite`,需要将对应的jar包、驱动jar包、配置文件放在当前目录下并且保证targetProject存在。

生成的文件包括:Subject.java,SubjectExample.java(用于设置条件),SubjectMapper.xml(映射文件),SubjectMapper.java(接口，即Dao层)

```java
public interface SubjectMapper {
    int countByExample(SubjectExample example);
    
    int deleteByExample(SubjectExample example);

    int deleteByPrimaryKey(String uuid);

    int insert(Subject record);
    /**
     * 可选插入,record中不为空的字段将插入
     * xml中使用if标签配置
     */
    int insertSelective(Subject record);
    /**
     * 根据条件进行查询
     */
    List<Subject> selectByExample(SubjectExample example);

    Subject selectByPrimaryKey(String uuid);

    int updateByExampleSelective(@Param("record") Subject record, @Param("example") SubjectExample example);

    int updateByExample(@Param("record") Subject record, @Param("example") SubjectExample example);

    int updateByPrimaryKeySelective(Subject record);

    int updateByPrimaryKey(Subject record);
}
```

条件配置示例:
```java
TestTableExample example = new TestTableExample();

  example.or()
    .andField1EqualTo(5)
    .andField2IsNull();

  example.or()
    .andField3NotEqualTo(9)
    .andField4IsNotNull();

  List<Integer> field5Values = new ArrayList<Integer>();
  field5Values.add(8);
  field5Values.add(11);
  field5Values.add(14);
  field5Values.add(22);

  example.or()
    .andField5In(field5Values);

  example.or()
    .andField6Between(3, 7);
```

对应的sql条件为:
```sql
 where (field1 = 5 and field2 is null)
     or (field3 <> 9 and field4 is not null)
     or (field5 in (8, 11, 14, 22))
     or (field6 between 3 and 7)
```

实现机制:Example内部具有三个类(GeneratedCriteria(抽像类，表示条件的集合，条件间使用or相隔开)、Criteria(抽线类的实现类)、Criterion(表示条件,包括条件的关键字等等)),xml获取example的oredCriteria(Criteria的集合),迭代条件每个条件用or相连接。

__参考文档：__
[快速起步](http://www.mybatis.org/generator/quickstart.html)
[MBG运行](http://www.mybatis.org/generator/running/running.html)
[Example类的使用](http://www.mybatis.org/generator/generatedobjects/exampleClassUsage.html)

## 觉得不好的地方
### 控制层含有业务操作
控制层应该只进行逻辑判定、参数传递的操作，不应该有业务层的代码。

### 对功能不理解
比如对mybatis分页插件pagehelper使用不理解，造成许多冗余的代码。

```java
PageHelper.startPage(currentPage, pageSize);
marshalsList = marshalsDao.selectMarshalsLike(marshals);
PageInfo<Marshals> marshalsListPage = new PageInfo<Marshals>(marshalsList);
Map<String, Object> data = new HashMap<String, Object>();
Iterator<Marshals> datas = marshalsListPage.getList().iterator();
List<Marshals> marshalsDatas = new ArrayList<>();
while (datas.hasNext()) {
    marshalsDatas.add(datas.next());
}
data.put("rows", marshalsDatas);
data.put("total", marshalsListPage.getTotal());
//因为前端使用的是easyui的数据表格，后端只需要返回一个json,
//rows为数组对象,total为页面大小,所以只需要分页查询就够了
PageHelper.startPage(currentPage, pageSize);
marshalsList = marshalsDao.selectMarshalsLike(marshals);
data.put("rows", marshalsList);
data.put("total", marshalsList.size());
```